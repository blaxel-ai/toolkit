// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/blaxel-ai/toolkit/cli/register"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Agent Agent
type Agent struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Agent specification
	Spec *AgentSpec `json:"spec,omitempty"`

	// Status Agent status
	Status *string `json:"status,omitempty"`
}

// AgentSpec defines model for AgentSpec.
type AgentSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Description Description, small description computed from the prompt
	Description *string `json:"description,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Repository Repository
	Repository *Repository `json:"repository,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	// ApiKey Api key
	ApiKey *string `json:"apiKey,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// ExpiresIn Duration until expiration (in seconds)
	ExpiresIn *string `json:"expires_in,omitempty"`

	// Id Api key id, to retrieve it from the API
	Id *string `json:"id,omitempty"`

	// Name Name for the API key
	Name *string `json:"name,omitempty"`

	// Sub User subject identifier
	Sub *string `json:"sub,omitempty"`

	// SubType Subject type
	SubType *string `json:"sub_type,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Configuration Configuration
type Configuration struct {
	// Continents Continents
	Continents *[]Continent `json:"continents,omitempty"`

	// Countries Countries
	Countries *[]Country `json:"countries,omitempty"`

	// PrivateLocations Private locations managed with blaxel operator
	PrivateLocations *[]PrivateLocation `json:"privateLocations,omitempty"`

	// Regions Regions
	Regions *[]Region `json:"regions,omitempty"`
}

// Continent Continent
type Continent struct {
	// DisplayName Continent display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Continent code
	Name *string `json:"name,omitempty"`
}

// CoreEvent Core event
type CoreEvent struct {
	// CanaryRevision Canary revisionID link to the event
	CanaryRevision *string `json:"canaryRevision,omitempty"`

	// Message Event message
	Message *string `json:"message,omitempty"`

	// Revision RevisionID link to the event
	Revision *string `json:"revision,omitempty"`

	// Status Event status
	Status *string `json:"status,omitempty"`

	// Time Event time
	Time *string `json:"time,omitempty"`

	// Type Event type
	Type *string `json:"type,omitempty"`
}

// CoreEvents Core events
type CoreEvents = []CoreEvent

// CoreSpec Core specification
type CoreSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`
}

// Country Configuration
type Country struct {
	// DisplayName Country display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Country code
	Name *string `json:"name,omitempty"`
}

// CreateJobExecutionRequest Request to create a job execution
type CreateJobExecutionRequest struct {
	// ExecutionId Execution ID (optional, will be generated if not provided)
	ExecutionId *string `json:"executionId,omitempty"`

	// Id Unique message ID
	Id *string `json:"id,omitempty"`

	// JobId Job ID
	JobId *string `json:"jobId,omitempty"`

	// Tasks Array of task parameters for parallel execution
	Tasks *[]map[string]interface{} `json:"tasks,omitempty"`

	// WorkspaceId Workspace ID
	WorkspaceId *string `json:"workspaceId,omitempty"`
}

// CustomDomain Custom domain for preview deployments
// The custom domain represents a base domain (e.g., example.com) that will be used
// to serve preview deployments. Each preview will be accessible at a subdomain:
// <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
type CustomDomain struct {
	// Metadata Custom domain metadata
	Metadata *CustomDomainMetadata `json:"metadata,omitempty"`

	// Spec Custom domain specification
	Spec *CustomDomainSpec `json:"spec,omitempty"`
}

// CustomDomainMetadata defines model for CustomDomainMetadata.
type CustomDomainMetadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Display name for the custom domain
	DisplayName *string `json:"displayName,omitempty"`

	// Labels Labels
	Labels *MetadataLabels `json:"labels,omitempty"`

	// Name Domain name (e.g., "example.com")
	Name *string `json:"name,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// CustomDomainSpec Custom domain specification
type CustomDomainSpec struct {
	// CnameRecords CNAME target for the domain
	CnameRecords *string `json:"cnameRecords,omitempty"`

	// LastVerifiedAt Last verification attempt timestamp
	LastVerifiedAt *string `json:"lastVerifiedAt,omitempty"`

	// Region Region that the custom domain is associated with
	Region *string `json:"region,omitempty"`

	// Status Current status of the domain (pending, verified, failed)
	Status *string `json:"status,omitempty"`

	// TxtRecords Map of TXT record names to values for domain verification
	TxtRecords *map[string]string `json:"txtRecords,omitempty"`

	// VerificationError Error message if verification failed
	VerificationError *string `json:"verificationError,omitempty"`
}

// ExpirationPolicy Expiration policy for sandbox lifecycle management
type ExpirationPolicy struct {
	// Action Action to take when policy is triggered
	Action *string `json:"action,omitempty"`

	// Type Type of expiration policy
	Type *string `json:"type,omitempty"`

	// Value Duration value (e.g., '1h', '24h', '7d')
	Value *string `json:"value,omitempty"`
}

// Flavor A type of hardware available for deployments
type Flavor struct {
	// Name Flavor name (e.g. t4)
	Name *string `json:"name,omitempty"`

	// Type Flavor type (e.g. cpu, gpu)
	Type *string `json:"type,omitempty"`
}

// Flavors Types of hardware available for deployments
type Flavors = []Flavor

// Function Function
type Function struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Function specification
	Spec *FunctionSpec `json:"spec,omitempty"`

	// Status Function status
	Status *string `json:"status,omitempty"`
}

// FunctionSpec defines model for FunctionSpec.
type FunctionSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Description Function description, very important for the agent function to work with an LLM
	Description *string `json:"description,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// Image defines model for Image.
type Image struct {
	Metadata *ImageMetadata `json:"metadata,omitempty"`
	Spec     *ImageSpec     `json:"spec,omitempty"`
}

// ImageMetadata defines model for ImageMetadata.
type ImageMetadata struct {
	// CreatedAt The date and time when the image was created.
	CreatedAt *string `json:"createdAt,omitempty"`

	// DisplayName The display name of the image (registry/workspace/repository).
	DisplayName *string `json:"displayName,omitempty"`

	// LastDeployedAt The date and time when the image was last deployed (most recent across all tags).
	LastDeployedAt *string `json:"lastDeployedAt,omitempty"`

	// Name The name of the image (repository name).
	Name *string `json:"name,omitempty"`

	// ResourceType The resource type of the image.
	ResourceType *string `json:"resourceType,omitempty"`

	// UpdatedAt The date and time when the image was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Workspace The workspace of the image.
	Workspace *string `json:"workspace,omitempty"`
}

// ImageSpec defines model for ImageSpec.
type ImageSpec struct {
	// Size The size of the image in bytes.
	Size *int `json:"size,omitempty"`

	// Tags List of tags available for this image.
	Tags *[]ImageTag `json:"tags,omitempty"`
}

// ImageTag defines model for ImageTag.
type ImageTag struct {
	// CreatedAt The date and time when the tag was created.
	CreatedAt *string `json:"createdAt,omitempty"`

	// Name The name of the tag.
	Name *string `json:"name,omitempty"`

	// Size The size of the image in bytes.
	Size *int `json:"size,omitempty"`

	// UpdatedAt The date and time when the tag was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Integration Integration
type Integration struct {
	// AdditionalInfos Integration additional infos
	AdditionalInfos *map[string]string `json:"additionalInfos,omitempty"`

	// Endpoints Integration endpoints
	Endpoints *IntegrationEndpoints `json:"endpoints,omitempty"`

	// Headers Integration headers
	Headers *IntegrationHeaders `json:"headers,omitempty"`

	// Name Integration name
	Name *string `json:"name,omitempty"`

	// Organizations Integration organizations
	Organizations *[]IntegrationOrganization `json:"organizations,omitempty"`

	// Params Integration query params
	Params *IntegrationQueryParams `json:"params,omitempty"`

	// Repositories Integration repositories
	Repositories *[]IntegrationRepository `json:"repositories,omitempty"`
}

// IntegrationConnection Integration Connection
type IntegrationConnection struct {
	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Integration connection specification
	Spec *IntegrationConnectionSpec `json:"spec,omitempty"`
}

// IntegrationConnectionSpec Integration connection specification
type IntegrationConnectionSpec struct {
	// Config Additional configuration for the integration
	Config *map[string]string `json:"config,omitempty"`

	// Integration Integration type
	Integration *string `json:"integration,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Secret Integration secret
	Secret *map[string]string `json:"secret,omitempty"`
}

// IntegrationConnectionsList defines model for IntegrationConnectionsList.
type IntegrationConnectionsList = []string

// IntegrationEndpoint Integration endpoint
type IntegrationEndpoint struct {
	// Body Integration endpoint body
	Body *string `json:"body,omitempty"`

	// IgnoreModels Integration endpoint ignore models
	IgnoreModels *[]interface{} `json:"ignoreModels,omitempty"`

	// Method Integration endpoint method
	Method *string `json:"method,omitempty"`

	// Models Integration endpoint models
	Models *[]interface{} `json:"models,omitempty"`

	// StreamKey Integration endpoint stream key
	StreamKey *string `json:"streamKey,omitempty"`

	// StreamToken Integration endpoint token
	StreamToken *IntegrationEndpointToken `json:"streamToken,omitempty"`

	// Token Integration endpoint token
	Token *IntegrationEndpointToken `json:"token,omitempty"`
}

// IntegrationEndpointToken Integration endpoint token
type IntegrationEndpointToken struct {
	// Received Integration endpoint token received
	Received *string `json:"received,omitempty"`

	// Sent Integration endpoint token sent
	Sent *string `json:"sent,omitempty"`

	// Total Integration endpoint token total
	Total *string `json:"total,omitempty"`
}

// IntegrationEndpoints Integration endpoints
type IntegrationEndpoints map[string]IntegrationEndpoint

// IntegrationHeaders Integration headers
type IntegrationHeaders map[string]string

// IntegrationOrganization Integration organization
type IntegrationOrganization struct {
	// AvatarUrl Provider organization avatar URL
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// DisplayName Provider organization display name
	DisplayName *string `json:"displayName,omitempty"`

	// Id Provider organization ID
	Id *string `json:"id,omitempty"`

	// Name Provider organization name
	Name *string `json:"name,omitempty"`
}

// IntegrationQueryParams Integration query params
type IntegrationQueryParams map[string]string

// IntegrationRepository Integration repository
type IntegrationRepository struct {
	// Id Repository ID
	Id *string `json:"id,omitempty"`

	// IsBl Whether the repository has Blaxel imports
	IsBl *bool `json:"isBl,omitempty"`

	// Name Repository name
	Name *string `json:"name,omitempty"`

	// Organization Repository owner
	Organization *string `json:"organization,omitempty"`

	// Url Repository URL
	Url *string `json:"url,omitempty"`
}

// Job Job
type Job struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Job specification
	Spec *JobSpec `json:"spec,omitempty"`

	// Status Job status
	Status *string `json:"status,omitempty"`
}

// JobExecution Job execution
type JobExecution struct {
	// Metadata Job execution metadata
	Metadata *JobExecutionMetadata `json:"metadata,omitempty"`

	// Spec Job execution specification
	Spec *JobExecutionSpec `json:"spec,omitempty"`

	// Stats Job execution statistics
	Stats *JobExecutionStats `json:"stats,omitempty"`

	// Status Job execution status
	Status *JobExecutionStatus `json:"status,omitempty"`

	// Tasks List of execution tasks
	Tasks *[]JobExecutionTask `json:"tasks,omitempty"`
}

// JobExecutionMetadata Job execution metadata
type JobExecutionMetadata struct {
	// Cluster Cluster ID
	Cluster *string `json:"cluster,omitempty"`

	// CompletedAt Completion timestamp
	CompletedAt *string `json:"completedAt,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"createdAt,omitempty"`

	// DeletedAt Deletion timestamp
	DeletedAt *string `json:"deletedAt,omitempty"`

	// ExpiredAt Expiration timestamp
	ExpiredAt *string `json:"expiredAt,omitempty"`

	// Id Execution ID
	Id *string `json:"id,omitempty"`

	// Job Job name
	Job *string `json:"job,omitempty"`

	// StartedAt Start timestamp
	StartedAt *string `json:"startedAt,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Workspace Workspace ID
	Workspace *string `json:"workspace,omitempty"`
}

// JobExecutionSpec Job execution specification
type JobExecutionSpec struct {
	// Parallelism Number of parallel tasks
	Parallelism *int `json:"parallelism,omitempty"`

	// Tasks List of execution tasks
	Tasks *[]JobExecutionTask `json:"tasks,omitempty"`

	// Timeout Job timeout in seconds (captured at execution creation time)
	Timeout *int `json:"timeout,omitempty"`
}

// JobExecutionStats Job execution statistics
type JobExecutionStats struct {
	// Cancelled Number of cancelled tasks
	Cancelled *int `json:"cancelled,omitempty"`

	// Failure Number of failed tasks
	Failure *int `json:"failure,omitempty"`

	// Retried Number of retried tasks
	Retried *int `json:"retried,omitempty"`

	// Running Number of running tasks
	Running *int `json:"running,omitempty"`

	// Success Number of successful tasks
	Success *int `json:"success,omitempty"`

	// Total Total number of tasks
	Total *int `json:"total,omitempty"`
}

// JobExecutionStatus Job execution status
type JobExecutionStatus = string

// JobExecutionTask Job execution task
type JobExecutionTask struct {
	// Conditions Task conditions
	Conditions *[]JobExecutionTaskCondition `json:"conditions,omitempty"`

	// Metadata Job execution task metadata
	Metadata *JobExecutionTaskMetadata `json:"metadata,omitempty"`

	// Spec Job execution task specification
	Spec *JobExecutionTaskSpec `json:"spec,omitempty"`

	// Status Job execution task status
	Status *JobExecutionTaskStatus `json:"status,omitempty"`
}

// JobExecutionTaskCondition Job execution task condition
type JobExecutionTaskCondition struct {
	// ExecutionReason Execution reason
	ExecutionReason *string `json:"executionReason,omitempty"`

	// Message Condition message
	Message *string `json:"message,omitempty"`

	// Reason Condition reason
	Reason *string `json:"reason,omitempty"`

	// Severity Condition severity
	Severity *string `json:"severity,omitempty"`

	// State Condition state
	State *string `json:"state,omitempty"`

	// Type Condition type
	Type *string `json:"type,omitempty"`
}

// JobExecutionTaskMetadata Job execution task metadata
type JobExecutionTaskMetadata struct {
	// CompletedAt Completion timestamp
	CompletedAt *string `json:"completedAt,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"createdAt,omitempty"`

	// Name Task name
	Name *string `json:"name,omitempty"`

	// ScheduledAt Scheduled timestamp
	ScheduledAt *string `json:"scheduledAt,omitempty"`

	// StartedAt Start timestamp
	StartedAt *string `json:"startedAt,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// JobExecutionTaskSpec Job execution task specification
type JobExecutionTaskSpec struct {
	// MaxRetries Maximum number of retries
	MaxRetries *int `json:"maxRetries,omitempty"`

	// Timeout Task timeout duration
	Timeout *string `json:"timeout,omitempty"`
}

// JobExecutionTaskStatus Job execution task status
type JobExecutionTaskStatus = string

// JobSpec defines model for JobSpec.
type JobSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Region Region where the job should be created (e.g. us-was-1, eu-lon-1)
	Region *string `json:"region,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// LocationResponse Location availability for policies
type LocationResponse struct {
	// Continent Continent of the location
	Continent *string `json:"continent,omitempty"`

	// Country Country of the location
	Country *string `json:"country,omitempty"`

	// Flavors Hardware flavors available in the location
	Flavors *[]Flavor `json:"flavors,omitempty"`

	// Location Name of the location
	Location *string `json:"location,omitempty"`

	// Region Region of the location
	Region *string `json:"region,omitempty"`

	// Status Status of the location
	Status *string `json:"status,omitempty"`
}

// MCPDefinition defines model for MCPDefinition.
type MCPDefinition struct {
	// Categories Categories of the artifact
	Categories *[]interface{} `json:"categories,omitempty"`

	// ComingSoon If the artifact is coming soon
	ComingSoon *bool `json:"coming_soon,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// Description Description of the artifact
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the artifact
	DisplayName *string `json:"displayName,omitempty"`

	// Enterprise If the artifact is enterprise
	Enterprise *bool `json:"enterprise,omitempty"`

	// Entrypoint Entrypoint of the artifact
	Entrypoint *map[string]interface{} `json:"entrypoint,omitempty"`

	// Form Form of the artifact
	Form *map[string]interface{} `json:"form,omitempty"`

	// Hidden If the artifact is hidden
	Hidden *bool `json:"hidden,omitempty"`

	// HiddenSecrets Hidden secrets of the artifact
	HiddenSecrets *[]string `json:"hiddenSecrets,omitempty"`

	// Icon Icon of the artifact
	Icon *string `json:"icon,omitempty"`

	// Image Image of the artifact
	Image *string `json:"image,omitempty"`

	// Integration Integration of the artifact
	Integration *string `json:"integration,omitempty"`

	// LongDescription Long description of the artifact
	LongDescription *string `json:"longDescription,omitempty"`

	// Name Name of the artifact
	Name *string `json:"name,omitempty"`

	// Transport Transport compatibility for the MCP, can be "websocket" or "http-stream"
	Transport *string `json:"transport,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Url URL of the artifact
	Url *string `json:"url,omitempty"`
}

// Metadata defines model for Metadata.
type Metadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Model display name
	DisplayName *string `json:"displayName,omitempty"`

	// Labels Labels
	Labels *MetadataLabels `json:"labels,omitempty"`

	// Name Model name
	Name *string `json:"name,omitempty"`

	// Plan Plan
	Plan interface{} `json:"plan,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Url URL
	Url *string `json:"url,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// MetadataLabels Labels
type MetadataLabels map[string]string

// Model Logical object representing a model
type Model struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Model specification
	Spec *ModelSpec `json:"spec,omitempty"`

	// Status Model status
	Status *string `json:"status,omitempty"`
}

// ModelSpec defines model for ModelSpec.
type ModelSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`
}

// OwnerFields Owner fields for Persistance
type OwnerFields struct {
	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// PendingInvitation defines model for PendingInvitation.
type PendingInvitation struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// Email User email
	Email *string `json:"email,omitempty"`

	// InvitedBy User sub
	InvitedBy *string `json:"invitedBy,omitempty"`

	// Role ACL role
	Role *string `json:"role,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PendingInvitationAccept Pending invitation accept
type PendingInvitationAccept struct {
	// Email User email
	Email *string `json:"email,omitempty"`

	// Workspace Workspace
	Workspace *Workspace `json:"workspace,omitempty"`
}

// PendingInvitationRender Pending invitation in workspace
type PendingInvitationRender struct {
	// Email User email
	Email *string `json:"email,omitempty"`

	// InvitedAt Invitation date
	InvitedAt *string `json:"invitedAt,omitempty"`

	// InvitedBy Invited by
	InvitedBy *PendingInvitationRenderInvitedBy `json:"invitedBy,omitempty"`

	// Role ACL role
	Role *string `json:"role,omitempty"`

	// Workspace Workspace
	Workspace *PendingInvitationRenderWorkspace `json:"workspace,omitempty"`

	// WorkspaceDetails Workspace details
	WorkspaceDetails *PendingInvitationWorkspaceDetails `json:"workspaceDetails,omitempty"`
}

// PendingInvitationRenderInvitedBy Invited by
type PendingInvitationRenderInvitedBy struct {
	// Email User email
	Email *string `json:"email,omitempty"`

	// FamilyName User family name
	FamilyName *string `json:"family_name,omitempty"`

	// GivenName User given name
	GivenName *string `json:"given_name,omitempty"`

	// Sub User sub
	Sub *string `json:"sub,omitempty"`
}

// PendingInvitationRenderWorkspace Workspace
type PendingInvitationRenderWorkspace struct {
	// DisplayName Workspace display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Workspace name
	Name *string `json:"name,omitempty"`
}

// PendingInvitationWorkspaceDetails Workspace details
type PendingInvitationWorkspaceDetails struct {
	// Emails List of user emails in the workspace
	Emails *[]interface{} `json:"emails,omitempty"`

	// UserNumber Number of users in the workspace
	UserNumber *float32 `json:"user_number,omitempty"`
}

// PoliciesList defines model for PoliciesList.
type PoliciesList = []string

// Policy Rule that controls how a deployment is made and served (e.g. location restrictions)
type Policy struct {
	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Policy specification
	Spec *PolicySpec `json:"spec,omitempty"`
}

// PolicyLocation Policy location
type PolicyLocation struct {
	// Name Policy location name
	Name *string `json:"name,omitempty"`

	// Type Policy location type
	Type *string `json:"type,omitempty"`
}

// PolicyLocations PolicyLocations is a local type that wraps a slice of Location
type PolicyLocations = []PolicyLocation

// PolicyMaxTokens PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
type PolicyMaxTokens struct {
	// Granularity Granularity
	Granularity *string `json:"granularity,omitempty"`

	// Input Input
	Input *int `json:"input,omitempty"`

	// Output Output
	Output *int `json:"output,omitempty"`

	// RatioInputOverOutput RatioInputOverOutput
	RatioInputOverOutput *int `json:"ratioInputOverOutput,omitempty"`

	// Step Step
	Step *int `json:"step,omitempty"`

	// Total Total
	Total *int `json:"total,omitempty"`
}

// PolicyResourceType PolicyResourceType is a type of resource, e.g. model, function, etc.
type PolicyResourceType = string

// PolicyResourceTypes PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
type PolicyResourceTypes = []PolicyResourceType

// PolicySpec Policy specification
type PolicySpec struct {
	// Flavors Types of hardware available for deployments
	Flavors *Flavors `json:"flavors,omitempty"`

	// Locations PolicyLocations is a local type that wraps a slice of Location
	Locations *PolicyLocations `json:"locations,omitempty"`

	// MaxTokens PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
	MaxTokens *PolicyMaxTokens `json:"maxTokens,omitempty"`

	// ResourceTypes PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
	ResourceTypes *PolicyResourceTypes `json:"resourceTypes,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Type Policy type, can be location or flavor
	Type *string `json:"type,omitempty"`
}

// Port A port for a resource
type Port struct {
	// Name The name of the port
	Name *string `json:"name,omitempty"`

	// Protocol The protocol of the port
	Protocol *string `json:"protocol,omitempty"`

	// Target The target port of the port
	Target *int `json:"target,omitempty"`
}

// Ports Set of ports for a resource
type Ports = []Port

// Preview Preview of a Resource
type Preview struct {
	// Metadata PreviewMetadata
	Metadata *PreviewMetadata `json:"metadata,omitempty"`

	// Spec Preview of a Resource
	Spec *PreviewSpec `json:"spec,omitempty"`
}

// PreviewMetadata defines model for PreviewMetadata.
type PreviewMetadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Model display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Preview name
	Name *string `json:"name,omitempty"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PreviewSpec Preview of a Resource
type PreviewSpec struct {
	// CustomDomain Custom domain bound to this preview
	CustomDomain *string `json:"customDomain,omitempty"`

	// Expires The expiration date for the preview in ISO 8601 format - 2024-12-31T23:59:59Z
	Expires *string `json:"expires,omitempty"`

	// Port Port of the preview
	Port *int `json:"port,omitempty"`

	// PrefixUrl Prefix URL
	PrefixUrl *string `json:"prefixUrl,omitempty"`

	// Public Whether the preview is public
	Public *bool `json:"public,omitempty"`

	// Region Region where the preview is deployed, this is readonly
	Region *string `json:"region,omitempty"`

	// RequestHeaders Those headers will be set in all requests to your preview. This is especially useful to set the Authorization header.
	RequestHeaders *map[string]string `json:"requestHeaders,omitempty"`

	// ResponseHeaders Those headers will be set in all responses of your preview. This is especially useful to set the CORS headers.
	ResponseHeaders *map[string]string `json:"responseHeaders,omitempty"`

	// Ttl Time to live for the preview (e.g., "1h", "24h", "7d"). After this duration, the preview will be automatically deleted.
	Ttl *string `json:"ttl,omitempty"`

	// Url URL of the preview
	Url *string `json:"url,omitempty"`
}

// PreviewToken Token for a Preview
type PreviewToken struct {
	// Metadata PreviewTokenMetadata
	Metadata *PreviewTokenMetadata `json:"metadata,omitempty"`

	// Spec Spec for a Preview Token
	Spec *PreviewTokenSpec `json:"spec,omitempty"`
}

// PreviewTokenMetadata PreviewTokenMetadata
type PreviewTokenMetadata struct {
	// Name Token name
	Name *string `json:"name,omitempty"`

	// PreviewName Preview name
	PreviewName *string `json:"previewName,omitempty"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PreviewTokenSpec Spec for a Preview Token
type PreviewTokenSpec struct {
	// Expired Whether the token is expired
	Expired *bool `json:"expired,omitempty"`

	// ExpiresAt Expiration time of the token
	ExpiresAt *string `json:"expiresAt,omitempty"`

	// Token Token
	Token *string `json:"token,omitempty"`
}

// PrivateLocation Private location available for policies
type PrivateLocation struct {
	// Name Location name
	Name *string `json:"name,omitempty"`
}

// PublicIp defines model for PublicIp.
type PublicIp struct {
	// Description Description of the region/location
	Description *string `json:"description,omitempty"`

	// Ipv4Cidrs List of public ipv4 addresses
	Ipv4Cidrs *[]string `json:"ipv4Cidrs,omitempty"`

	// Ipv6Cidrs List of public ipv6 addresses
	Ipv6Cidrs *[]string `json:"ipv6Cidrs,omitempty"`
}

// PublicIps defines model for PublicIps.
type PublicIps map[string]PublicIp

// Region Region
type Region struct {
	// Allowed Region display name
	Allowed *string `json:"allowed,omitempty"`

	// Continent Region display name
	Continent *string `json:"continent,omitempty"`

	// Country Region display name
	Country *string `json:"country,omitempty"`

	// InfoGeneration Region display name
	InfoGeneration *string `json:"infoGeneration,omitempty"`

	// Location Region display name
	Location *string `json:"location,omitempty"`

	// Name Region name
	Name *string `json:"name,omitempty"`
}

// Repository Repository
type Repository struct {
	// Type Repository type
	Type *string `json:"type,omitempty"`

	// Url Repository URL
	Url *string `json:"url,omitempty"`
}

// RevisionConfiguration Revision configuration
type RevisionConfiguration struct {
	// Active Active revision id
	Active *string `json:"active,omitempty"`

	// Canary Canary revision id
	Canary *string `json:"canary,omitempty"`

	// CanaryPercent Canary revision percent
	CanaryPercent *int `json:"canaryPercent,omitempty"`

	// StickySessionTtl Sticky session TTL in seconds (0 = disabled)
	StickySessionTtl *int `json:"stickySessionTtl,omitempty"`

	// Traffic Traffic percentage
	Traffic *int `json:"traffic,omitempty"`
}

// RevisionMetadata Revision metadata
type RevisionMetadata struct {
	// Active Is the revision active
	Active *bool `json:"active,omitempty"`

	// Canary Is the revision canary
	Canary *bool `json:"canary,omitempty"`

	// CreatedAt Revision created at
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy Revision created by
	CreatedBy *string `json:"createdBy,omitempty"`

	// Id Revision ID
	Id *string `json:"id,omitempty"`

	// PreviousActive Is the revision previous active
	PreviousActive *bool `json:"previousActive,omitempty"`

	// Status Status of the revision
	Status *string `json:"status,omitempty"`

	// TrafficPercent Percent of traffic to the revision
	TrafficPercent *int `json:"trafficPercent,omitempty"`
}

// Runtime Set of configurations for a deployment
type Runtime struct {
	// Args The arguments to pass to the deployment runtime
	Args *[]interface{} `json:"args,omitempty"`

	// Command The command to run the deployment
	Command *[]interface{} `json:"command,omitempty"`

	// Configuration The configuration for the deployment
	Configuration *map[string]interface{} `json:"configuration,omitempty"`

	// Cpu The CPU for the deployment in cores, only available for private cluster
	Cpu *int `json:"cpu,omitempty"`

	// EndpointName Endpoint Name of the model. In case of hf_private_endpoint, it is the endpoint name. In case of hf_public_endpoint, it is not used.
	EndpointName *string `json:"endpointName,omitempty"`

	// Envs The env variables to set in the deployment. Should be a list of Kubernetes EnvVar types
	Envs *[]interface{} `json:"envs,omitempty"`

	// Expires The expiration date for the deployment in ISO 8601 format - 2024-12-31T23:59:59Z
	Expires *string `json:"expires,omitempty"`

	// Generation The generation of the deployment
	Generation *string `json:"generation,omitempty"`

	// Image The Docker image for the deployment
	Image *string `json:"image,omitempty"`

	// MaxConcurrentTasks The maximum number of concurrent task for an execution
	MaxConcurrentTasks *int `json:"maxConcurrentTasks,omitempty"`

	// MaxRetries The maximum number of retries for the deployment
	MaxRetries *int `json:"maxRetries,omitempty"`

	// MaxScale The minimum number of replicas for the deployment. Can be 0 or 1 (in which case the deployment is always running in at least one location).
	MaxScale *int `json:"maxScale,omitempty"`

	// Memory The memory for the deployment in MB
	Memory *int `json:"memory,omitempty"`

	// MetricPort The port to serve the metrics on
	MetricPort *int `json:"metricPort,omitempty"`

	// MinScale The maximum number of replicas for the deployment.
	MinScale *int `json:"minScale,omitempty"`

	// Model The slug name of the origin model at HuggingFace.
	Model *string `json:"model,omitempty"`

	// Organization The organization of the model
	Organization *string `json:"organization,omitempty"`

	// Ports Set of ports for a resource
	Ports *Ports `json:"ports,omitempty"`

	// StartupProbe The readiness probe. Should be a Kubernetes Probe type
	StartupProbe *map[string]interface{} `json:"startupProbe,omitempty"`

	// Timeout The timeout for the deployment in seconds
	Timeout *int `json:"timeout,omitempty"`

	// Transport The transport for the deployment, used by MCPs: "websocket" or "http-stream"
	Transport *string `json:"transport,omitempty"`

	// Ttl The TTL for the deployment in seconds - 30m, 24h, 7d
	Ttl *string `json:"ttl,omitempty"`

	// Type The type of origin for the deployment (hf_private_endpoint, hf_public_endpoint)
	Type *string `json:"type,omitempty"`
}

// Sandbox Micro VM for running agentic tasks
type Sandbox struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// LastUsedAt Last time the sandbox was used (read-only, managed by the system)
	LastUsedAt *string `json:"lastUsedAt,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Sandbox specification
	Spec *SandboxSpec `json:"spec,omitempty"`

	// Status Sandbox status
	Status *string `json:"status,omitempty"`

	// Ttl TTL timestamp for automatic deletion (optional, nil means no auto-deletion)
	Ttl *int `json:"ttl,omitempty"`
}

// SandboxDefinition Sandbox definition for admin store operations
type SandboxDefinition struct {
	// Categories Categories of the defintion
	Categories *[]interface{} `json:"categories,omitempty"`

	// ComingSoon If the definition is coming soon
	ComingSoon *bool `json:"coming_soon,omitempty"`

	// Description Description of the defintion
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the definition
	DisplayName *string `json:"displayName,omitempty"`

	// Enterprise If the definition is enterprise
	Enterprise *bool `json:"enterprise,omitempty"`

	// Hidden If the definition is hidden
	Hidden *bool `json:"hidden,omitempty"`

	// Icon Icon of the definition
	Icon *string `json:"icon,omitempty"`

	// Image Image of the Sandbox definition
	Image *string `json:"image,omitempty"`

	// LongDescription Long description of the defintion
	LongDescription *string `json:"longDescription,omitempty"`

	// Memory Memory of the Sandbox definition in MB
	Memory *int `json:"memory,omitempty"`

	// Name Name of the artifact
	Name *string `json:"name,omitempty"`

	// Ports Set of ports for a resource
	Ports *Ports `json:"ports,omitempty"`

	// Tags Tags of the definition
	Tags *string `json:"tags,omitempty"`

	// Url URL of the definition
	Url *string `json:"url,omitempty"`
}

// SandboxLifecycle Lifecycle configuration for sandbox management
type SandboxLifecycle struct {
	// ExpirationPolicies List of expiration policies
	ExpirationPolicies *[]ExpirationPolicy `json:"expirationPolicies,omitempty"`
}

// SandboxSpec defines model for SandboxSpec.
type SandboxSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`

	// Lifecycle Lifecycle configuration for sandbox management
	Lifecycle *SandboxLifecycle `json:"lifecycle,omitempty"`
	Policies  *PoliciesList     `json:"policies,omitempty"`

	// Region Region where the sandbox should be created (e.g. us-pdx-1, eu-lon-1)
	Region *string `json:"region,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool              `json:"sandbox,omitempty"`
	Volumes *VolumeAttachments `json:"volumes,omitempty"`
}

// SpecConfiguration Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
type SpecConfiguration struct {
	// Secret ACconfiguration secret
	Secret *bool `json:"secret,omitempty"`

	// Value Configuration value
	Value *string `json:"value,omitempty"`
}

// StartSandbox Response when starting a Sandbox
type StartSandbox struct {
	// Message Human readable message about the start operation
	Message *string `json:"message,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Status Status of the Sandbox start operation
	Status *string `json:"status,omitempty"`
}

// StopSandbox Response when stopping a Sandbox
type StopSandbox struct {
	// Message Human readable message about the stop operation
	Message *string `json:"message,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Status Status of the Sandbox stop operation
	Status *string `json:"status,omitempty"`
}

// Template Blaxel template
type Template struct {
	// DefaultBranch Default branch of the template
	DefaultBranch *string `json:"defaultBranch,omitempty"`

	// Description Description of the template
	Description *string `json:"description,omitempty"`

	// DownloadCount Number of downloads/clones of the repository
	DownloadCount *int `json:"downloadCount,omitempty"`

	// ForksCount Number of forks the repository has
	ForksCount *int `json:"forksCount,omitempty"`

	// Icon URL to the template's icon
	Icon *string `json:"icon,omitempty"`

	// IconDark URL to the template's icon in dark mode
	IconDark *string `json:"iconDark,omitempty"`

	// Name Name of the template
	Name *string `json:"name,omitempty"`

	// Sha SHA of the variable
	Sha *string `json:"sha,omitempty"`

	// StarCount Number of stars the repository has
	StarCount *int `json:"starCount,omitempty"`

	// Topics Topic of the template
	Topics *[]string `json:"topics,omitempty"`

	// Url URL of the template
	Url *string `json:"url,omitempty"`

	// Variables Variables of the template
	Variables *[]TemplateVariable `json:"variables,omitempty"`
}

// TemplateVariable Blaxel template variable
type TemplateVariable struct {
	// Description Description of the variable
	Description *string `json:"description,omitempty"`

	// Integration Integration of the variable
	Integration *string `json:"integration,omitempty"`

	// Name Name of the variable
	Name *string `json:"name,omitempty"`

	// Path Path of the variable
	Path *string `json:"path,omitempty"`

	// Secret Whether the variable is secret
	Secret *bool `json:"secret,omitempty"`
}

// TimeFields Time fields for Persistance
type TimeFields struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Trigger Trigger configuration
type Trigger struct {
	// Configuration Trigger configuration
	Configuration *TriggerConfiguration `json:"configuration,omitempty"`

	// Enabled Enable or disable the trigger (default: true)
	Enabled *bool `json:"enabled,omitempty"`

	// Id The id of the trigger
	Id *string `json:"id,omitempty"`

	// Type The type of trigger, can be http or http-async
	Type *string `json:"type,omitempty"`
}

// TriggerConfiguration Trigger configuration
type TriggerConfiguration struct {
	// AuthenticationType The authentication type of the trigger
	AuthenticationType *string `json:"authenticationType,omitempty"`

	// Path The path of the trigger
	Path *string `json:"path,omitempty"`

	// Retry The retry of the trigger
	Retry *int `json:"retry,omitempty"`

	// Schedule The schedule of the trigger, cron expression * * * * *
	Schedule *string `json:"schedule,omitempty"`

	// Tasks The tasks configuration of the cronjob
	Tasks *[]TriggerConfigurationTask `json:"tasks,omitempty"`
}

// TriggerConfigurationTask The tasks configuration of the cronjob
type TriggerConfigurationTask = map[string]interface{}

// Triggers Triggers to use your agent
type Triggers = []Trigger

// Volume Volume resource for persistent storage
type Volume struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Volume specification - immutable configuration
	Spec *VolumeSpec `json:"spec,omitempty"`

	// State Volume state - mutable runtime state
	State *VolumeState `json:"state,omitempty"`

	// Status Volume status computed from events
	Status *string `json:"status,omitempty"`

	// TerminatedAt Timestamp when the volume was marked for termination
	TerminatedAt *string `json:"terminatedAt,omitempty"`
}

// VolumeAttachment Volume attachment configuration for sandbox
type VolumeAttachment struct {
	// MountPath Mount path in the container
	MountPath *string `json:"mountPath,omitempty"`

	// Name Name of the volume to attach
	Name *string `json:"name,omitempty"`

	// ReadOnly Whether the volume is mounted as read-only
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// VolumeAttachments defines model for VolumeAttachments.
type VolumeAttachments = []VolumeAttachment

// VolumeSpec Volume specification - immutable configuration
type VolumeSpec struct {
	// InfrastructureId The internal infrastructure resource identifier for this volume
	InfrastructureId *string `json:"infrastructureId,omitempty"`

	// Region Region where the volume should be created (e.g. us-pdx-1, eu-lon-1)
	Region *string `json:"region,omitempty"`

	// Size Size of the volume in MB
	Size *int `json:"size,omitempty"`

	// Template Volume template with revision (e.g. "mytemplate:1" or "mytemplate:latest")
	Template *string `json:"template,omitempty"`
}

// VolumeState Volume state - mutable runtime state
type VolumeState struct {
	// AttachedTo Resource this volume is attached to (e.g. "sandbox:my-sandbox", "model:my-model")
	AttachedTo *string `json:"attachedTo,omitempty"`
}

// VolumeTemplate Volume template for creating pre-configured volumes
type VolumeTemplate struct {
	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Volume template specification
	Spec *VolumeTemplateSpec `json:"spec,omitempty"`

	// State Volume template state
	State *VolumeTemplateState `json:"state,omitempty"`

	// Versions List of versions for this template
	Versions *[]VolumeTemplateVersion `json:"versions,omitempty"`
}

// VolumeTemplateSpec Volume template specification
type VolumeTemplateSpec struct {
	// DefaultSize Default size of the volume in MB
	DefaultSize *int `json:"defaultSize,omitempty"`

	// Description Description of the volume template
	Description *string `json:"description,omitempty"`
}

// VolumeTemplateState Volume template state
type VolumeTemplateState struct {
	// LastVersionUploadedAt Timestamp of last version upload
	LastVersionUploadedAt *string `json:"lastVersionUploadedAt,omitempty"`

	// LatestVersion Current/latest S3 version ID
	LatestVersion *string `json:"latestVersion,omitempty"`

	// Status Status of the volume template (created, ready, error)
	Status *string `json:"status,omitempty"`

	// VersionCount Total number of versions for this template
	VersionCount *int `json:"versionCount,omitempty"`
}

// VolumeTemplateVersion Volume template version tracking individual versions of template content
type VolumeTemplateVersion struct {
	// Bucket S3 bucket name where this version is stored
	Bucket *string `json:"bucket,omitempty"`

	// ContentSize Size of the template content in bytes
	ContentSize *int `json:"contentSize,omitempty"`

	// Name Name of the template version
	Name *string `json:"name,omitempty"`

	// Region AWS region where this version is stored
	Region *string `json:"region,omitempty"`

	// Status Status of the version (CREATED, READY, FAILED)
	Status *string `json:"status,omitempty"`

	// TemplateName Template name this version belongs to
	TemplateName *string `json:"templateName,omitempty"`

	// VersionId S3 version ID for this template version
	VersionId *string `json:"versionId,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	// AccountId Workspace account id
	AccountId *string `json:"accountId,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Workspace display name
	DisplayName *string `json:"displayName,omitempty"`

	// Id Autogenerated unique workspace id
	Id *string `json:"id,omitempty"`

	// Labels Workspace labels
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// Name Workspace name
	Name *string `json:"name,omitempty"`

	// Region Workspace write region
	Region *string `json:"region,omitempty"`

	// Runtime Workspace runtime
	Runtime *WorkspaceRuntime `json:"runtime,omitempty"`

	// Status Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
	Status *string `json:"status,omitempty"`

	// StatusReason Reason for current status (only set for error status)
	StatusReason *string `json:"statusReason,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// WorkspaceRuntime Workspace runtime
type WorkspaceRuntime struct {
	// Generation Workspace generation
	Generation *string `json:"generation,omitempty"`
}

// WorkspaceUser Workspace user
type WorkspaceUser struct {
	// Accepted Whether the user has accepted the workspace invitation
	Accepted *bool `json:"accepted,omitempty"`

	// Email Workspace user email
	Email *string `json:"email,omitempty"`

	// EmailVerified Whether the user's email has been verified
	EmailVerified *bool `json:"email_verified,omitempty"`

	// FamilyName Workspace user family name
	FamilyName *string `json:"family_name,omitempty"`

	// GivenName Workspace user given name
	GivenName *string `json:"given_name,omitempty"`

	// Role Workspace user role
	Role *string `json:"role,omitempty"`

	// Sub Workspace user identifier
	Sub *string `json:"sub,omitempty"`
}

// GetAgentParams defines parameters for GetAgent.
type GetAgentParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// GetFunctionParams defines parameters for GetFunction.
type GetFunctionParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// GetJobParams defines parameters for GetJob.
type GetJobParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// ListJobExecutionsParams defines parameters for ListJobExecutions.
type ListJobExecutionsParams struct {
	// Limit Number of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Page offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetSandboxParams defines parameters for GetSandbox.
type GetSandboxParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// CreateWorkspaceServiceAccountJSONBody defines parameters for CreateWorkspaceServiceAccount.
type CreateWorkspaceServiceAccountJSONBody struct {
	// Description Service account description
	Description *string `json:"description,omitempty"`

	// Name Service account name
	Name string `json:"name"`
}

// UpdateWorkspaceServiceAccountJSONBody defines parameters for UpdateWorkspaceServiceAccount.
type UpdateWorkspaceServiceAccountJSONBody struct {
	// Description Service account description
	Description *string `json:"description,omitempty"`

	// Name Service account name
	Name *string `json:"name,omitempty"`
}

// CreateApiKeyForServiceAccountJSONBody defines parameters for CreateApiKeyForServiceAccount.
type CreateApiKeyForServiceAccountJSONBody struct {
	// ExpiresIn Expiration period for the API key
	ExpiresIn *string `json:"expires_in,omitempty"`

	// Name Name for the API key
	Name *string `json:"name,omitempty"`
}

// InviteWorkspaceUserJSONBody defines parameters for InviteWorkspaceUser.
type InviteWorkspaceUserJSONBody struct {
	Email *openapi_types.Email `json:"email,omitempty"`
}

// UpdateWorkspaceUserRoleJSONBody defines parameters for UpdateWorkspaceUserRole.
type UpdateWorkspaceUserRoleJSONBody struct {
	// Role The new role to assign to the user
	Role string `json:"role"`
}

// CreateVolumeTemplateParams defines parameters for CreateVolumeTemplate.
type CreateVolumeTemplateParams struct {
	// Upload If true, returns a presigned URL for uploading the template content
	Upload *bool `form:"upload,omitempty" json:"upload,omitempty"`

	// Version Version name for the template version being created
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// UpdateVolumeTemplateParams defines parameters for UpdateVolumeTemplate.
type UpdateVolumeTemplateParams struct {
	// Upload If true, returns a presigned URL for uploading the template content
	Upload *bool `form:"upload,omitempty" json:"upload,omitempty"`

	// Version Version name for the template version being created
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// CheckWorkspaceAvailabilityJSONBody defines parameters for CheckWorkspaceAvailability.
type CheckWorkspaceAvailabilityJSONBody struct {
	Name string `json:"name"`
}

// CreateAgentJSONRequestBody defines body for CreateAgent for application/json ContentType.
type CreateAgentJSONRequestBody = Agent

// UpdateAgentJSONRequestBody defines body for UpdateAgent for application/json ContentType.
type UpdateAgentJSONRequestBody = Agent

// CreateCustomDomainJSONRequestBody defines body for CreateCustomDomain for application/json ContentType.
type CreateCustomDomainJSONRequestBody = CustomDomain

// UpdateCustomDomainJSONRequestBody defines body for UpdateCustomDomain for application/json ContentType.
type UpdateCustomDomainJSONRequestBody = CustomDomain

// CreateFunctionJSONRequestBody defines body for CreateFunction for application/json ContentType.
type CreateFunctionJSONRequestBody = Function

// UpdateFunctionJSONRequestBody defines body for UpdateFunction for application/json ContentType.
type UpdateFunctionJSONRequestBody = Function

// CreateIntegrationConnectionJSONRequestBody defines body for CreateIntegrationConnection for application/json ContentType.
type CreateIntegrationConnectionJSONRequestBody = IntegrationConnection

// UpdateIntegrationConnectionJSONRequestBody defines body for UpdateIntegrationConnection for application/json ContentType.
type UpdateIntegrationConnectionJSONRequestBody = IntegrationConnection

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody = Job

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = Job

// CreateJobExecutionJSONRequestBody defines body for CreateJobExecution for application/json ContentType.
type CreateJobExecutionJSONRequestBody = CreateJobExecutionRequest

// CreateModelJSONRequestBody defines body for CreateModel for application/json ContentType.
type CreateModelJSONRequestBody = Model

// UpdateModelJSONRequestBody defines body for UpdateModel for application/json ContentType.
type UpdateModelJSONRequestBody = Model

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = Policy

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = Policy

// CreateSandboxJSONRequestBody defines body for CreateSandbox for application/json ContentType.
type CreateSandboxJSONRequestBody = Sandbox

// UpdateSandboxJSONRequestBody defines body for UpdateSandbox for application/json ContentType.
type UpdateSandboxJSONRequestBody = Sandbox

// CreateSandboxPreviewJSONRequestBody defines body for CreateSandboxPreview for application/json ContentType.
type CreateSandboxPreviewJSONRequestBody = Preview

// UpdateSandboxPreviewJSONRequestBody defines body for UpdateSandboxPreview for application/json ContentType.
type UpdateSandboxPreviewJSONRequestBody = Preview

// CreateSandboxPreviewTokenJSONRequestBody defines body for CreateSandboxPreviewToken for application/json ContentType.
type CreateSandboxPreviewTokenJSONRequestBody = PreviewToken

// CreateWorkspaceServiceAccountJSONRequestBody defines body for CreateWorkspaceServiceAccount for application/json ContentType.
type CreateWorkspaceServiceAccountJSONRequestBody CreateWorkspaceServiceAccountJSONBody

// UpdateWorkspaceServiceAccountJSONRequestBody defines body for UpdateWorkspaceServiceAccount for application/json ContentType.
type UpdateWorkspaceServiceAccountJSONRequestBody UpdateWorkspaceServiceAccountJSONBody

// CreateApiKeyForServiceAccountJSONRequestBody defines body for CreateApiKeyForServiceAccount for application/json ContentType.
type CreateApiKeyForServiceAccountJSONRequestBody CreateApiKeyForServiceAccountJSONBody

// InviteWorkspaceUserJSONRequestBody defines body for InviteWorkspaceUser for application/json ContentType.
type InviteWorkspaceUserJSONRequestBody InviteWorkspaceUserJSONBody

// UpdateWorkspaceUserRoleJSONRequestBody defines body for UpdateWorkspaceUserRole for application/json ContentType.
type UpdateWorkspaceUserRoleJSONRequestBody UpdateWorkspaceUserRoleJSONBody

// CreateVolumeTemplateJSONRequestBody defines body for CreateVolumeTemplate for application/json ContentType.
type CreateVolumeTemplateJSONRequestBody = VolumeTemplate

// UpdateVolumeTemplateJSONRequestBody defines body for UpdateVolumeTemplate for application/json ContentType.
type UpdateVolumeTemplateJSONRequestBody = VolumeTemplate

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = Volume

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = Workspace

// CheckWorkspaceAvailabilityJSONRequestBody defines body for CheckWorkspaceAvailability for application/json ContentType.
type CheckWorkspaceAvailabilityJSONRequestBody CheckWorkspaceAvailabilityJSONBody

// UpdateWorkspaceJSONRequestBody defines body for UpdateWorkspace for application/json ContentType.
type UpdateWorkspaceJSONRequestBody = Workspace

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	RunServer string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, runServer string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server:    server,
		RunServer: runServer,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	Run(
		ctx context.Context,
		workspaceName string,
		resourceType string,
		resourceName string,
		method string,
		path string,
		headers map[string]string,
		params []string,
		body string,
		debug bool,
		local bool,
		reqEditors ...RequestEditorFn,
	) (*http.Response, error)

	// ListAgents request
	ListAgents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentWithBody request with any body
	CreateAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgent(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAgent request
	DeleteAgent(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgent request
	GetAgent(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAgentWithBody request with any body
	UpdateAgentWithBody(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAgent(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAgentRevisions request
	ListAgentRevisions(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfiguration request
	GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomDomains request
	ListCustomDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomDomainWithBody request with any body
	CreateCustomDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomDomain(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomDomain request
	DeleteCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomDomain request
	GetCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomDomainWithBody request with any body
	UpdateCustomDomainWithBody(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomDomain(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyCustomDomain request
	VerifyCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctions request
	ListFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFunctionWithBody request with any body
	CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFunction request
	DeleteFunction(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunction request
	GetFunction(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFunctionWithBody request with any body
	UpdateFunctionWithBody(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFunction(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctionRevisions request
	ListFunctionRevisions(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CleanupImages request
	CleanupImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListImages request
	ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImage request
	GetImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImageTag request
	DeleteImageTag(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConnections request
	ListIntegrationConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIntegrationConnectionWithBody request with any body
	CreateIntegrationConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIntegrationConnection(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIntegrationConnection request
	DeleteIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnection request
	GetIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIntegrationConnectionWithBody request with any body
	UpdateIntegrationConnectionWithBody(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIntegrationConnection(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnectionModelEndpointConfigurations request
	GetIntegrationConnectionModelEndpointConfigurations(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConnectionModels request
	ListIntegrationConnectionModels(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnectionModel request
	GetIntegrationConnectionModel(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegration request
	GetIntegration(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobWithBody request with any body
	CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJob request
	DeleteJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobWithBody request with any body
	UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJob(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobExecutions request
	ListJobExecutions(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobExecutionWithBody request with any body
	CreateJobExecutionWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJobExecution(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJobExecution request
	DeleteJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobExecution request
	GetJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobRevisions request
	ListJobRevisions(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLocations request
	ListLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMCPHubDefinitions request
	ListMCPHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModels request
	ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModelWithBody request with any body
	CreateModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModel(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModel request
	DeleteModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModel request
	GetModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateModelWithBody request with any body
	UpdateModelWithBody(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateModel(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModelRevisions request
	ListModelRevisions(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllPendingInvitations request
	ListAllPendingInvitations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPublicIps request
	ListPublicIps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxHubDefinitions request
	ListSandboxHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxes request
	ListSandboxes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxWithBody request with any body
	CreateSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandbox(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandbox request
	DeleteSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandbox request
	GetSandbox(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSandboxWithBody request with any body
	UpdateSandboxWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSandbox(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxPreviews request
	ListSandboxPreviews(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxPreviewWithBody request with any body
	CreateSandboxPreviewWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandboxPreview(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxPreview request
	DeleteSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxPreview request
	GetSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSandboxPreviewWithBody request with any body
	UpdateSandboxPreviewWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSandboxPreview(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxPreviewTokens request
	ListSandboxPreviewTokens(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxPreviewTokenWithBody request with any body
	CreateSandboxPreviewTokenWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxPreviewToken request
	DeleteSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartSandbox request
	StartSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopSandbox request
	StopSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceServiceAccounts request
	GetWorkspaceServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceServiceAccountWithBody request with any body
	CreateWorkspaceServiceAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspaceServiceAccount(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspaceServiceAccount request
	DeleteWorkspaceServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceServiceAccountWithBody request with any body
	UpdateWorkspaceServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspaceServiceAccount(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiKeysForServiceAccount request
	ListApiKeysForServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyForServiceAccountWithBody request with any body
	CreateApiKeyForServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKeyForServiceAccount(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKeyForServiceAccount request
	DeleteApiKeyForServiceAccount(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTemplates request
	ListTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplate request
	GetTemplate(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceUsers request
	ListWorkspaceUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteWorkspaceUserWithBody request with any body
	InviteWorkspaceUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteWorkspaceUser(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveWorkspaceUser request
	RemoveWorkspaceUser(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceUserRoleWithBody request with any body
	UpdateWorkspaceUserRoleWithBody(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspaceUserRole(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVolumeTemplates request
	ListVolumeTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeTemplateWithBody request with any body
	CreateVolumeTemplateWithBody(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolumeTemplate(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeTemplate request
	DeleteVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVolumeTemplate request
	GetVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeTemplateWithBody request with any body
	UpdateVolumeTemplateWithBody(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolumeTemplate(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeTemplateVersion request
	DeleteVolumeTemplateVersion(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVolumes request
	ListVolumes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVolume request
	GetVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceWithBody request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckWorkspaceAvailabilityWithBody request with any body
	CheckWorkspaceAvailabilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckWorkspaceAvailability(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspace request
	GetWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceWithBody request with any body
	UpdateWorkspaceWithBody(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspace(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineWorkspaceInvitation request
	DeclineWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptWorkspaceInvitation request
	AcceptWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveWorkspace request
	LeaveWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// RegisterCliCommands registers CLI commands for the client
func (c *ClientWithResponses) RegisterCliCommands(reg register.Register, ctx context.Context) {

	// Register CLI commands for ListAgents
	reg.CliCommand(ctx, "ListAgents", c.ListAgents)

	// Register CLI commands for CreateAgent
	reg.CliCommand(ctx, "CreateAgent", c.CreateAgent)

	// Register CLI commands for DeleteAgent
	reg.CliCommand(ctx, "DeleteAgent", c.DeleteAgent)

	// Register CLI commands for GetAgent
	reg.CliCommand(ctx, "GetAgent", c.GetAgent)

	// Register CLI commands for UpdateAgent
	reg.CliCommand(ctx, "UpdateAgent", c.UpdateAgent)

	// Register CLI commands for ListAgentRevisions
	reg.CliCommand(ctx, "ListAgentRevisions", c.ListAgentRevisions)

	// Register CLI commands for GetConfiguration
	reg.CliCommand(ctx, "GetConfiguration", c.GetConfiguration)

	// Register CLI commands for ListCustomDomains
	reg.CliCommand(ctx, "ListCustomDomains", c.ListCustomDomains)

	// Register CLI commands for CreateCustomDomain
	reg.CliCommand(ctx, "CreateCustomDomain", c.CreateCustomDomain)

	// Register CLI commands for DeleteCustomDomain
	reg.CliCommand(ctx, "DeleteCustomDomain", c.DeleteCustomDomain)

	// Register CLI commands for GetCustomDomain
	reg.CliCommand(ctx, "GetCustomDomain", c.GetCustomDomain)

	// Register CLI commands for UpdateCustomDomain
	reg.CliCommand(ctx, "UpdateCustomDomain", c.UpdateCustomDomain)

	// Register CLI commands for VerifyCustomDomain
	reg.CliCommand(ctx, "VerifyCustomDomain", c.VerifyCustomDomain)

	// Register CLI commands for ListFunctions
	reg.CliCommand(ctx, "ListFunctions", c.ListFunctions)

	// Register CLI commands for CreateFunction
	reg.CliCommand(ctx, "CreateFunction", c.CreateFunction)

	// Register CLI commands for DeleteFunction
	reg.CliCommand(ctx, "DeleteFunction", c.DeleteFunction)

	// Register CLI commands for GetFunction
	reg.CliCommand(ctx, "GetFunction", c.GetFunction)

	// Register CLI commands for UpdateFunction
	reg.CliCommand(ctx, "UpdateFunction", c.UpdateFunction)

	// Register CLI commands for ListFunctionRevisions
	reg.CliCommand(ctx, "ListFunctionRevisions", c.ListFunctionRevisions)

	// Register CLI commands for CleanupImages
	reg.CliCommand(ctx, "CleanupImages", c.CleanupImages)

	// Register CLI commands for ListImages
	reg.CliCommand(ctx, "ListImages", c.ListImages)

	// Register CLI commands for DeleteImage
	reg.CliCommand(ctx, "DeleteImage", c.DeleteImage)

	// Register CLI commands for GetImage
	reg.CliCommand(ctx, "GetImage", c.GetImage)

	// Register CLI commands for DeleteImageTag
	reg.CliCommand(ctx, "DeleteImageTag", c.DeleteImageTag)

	// Register CLI commands for ListIntegrationConnections
	reg.CliCommand(ctx, "ListIntegrationConnections", c.ListIntegrationConnections)

	// Register CLI commands for CreateIntegrationConnection
	reg.CliCommand(ctx, "CreateIntegrationConnection", c.CreateIntegrationConnection)

	// Register CLI commands for DeleteIntegrationConnection
	reg.CliCommand(ctx, "DeleteIntegrationConnection", c.DeleteIntegrationConnection)

	// Register CLI commands for GetIntegrationConnection
	reg.CliCommand(ctx, "GetIntegrationConnection", c.GetIntegrationConnection)

	// Register CLI commands for UpdateIntegrationConnection
	reg.CliCommand(ctx, "UpdateIntegrationConnection", c.UpdateIntegrationConnection)

	// Register CLI commands for GetIntegrationConnectionModelEndpointConfigurations
	reg.CliCommand(ctx, "GetIntegrationConnectionModelEndpointConfigurations", c.GetIntegrationConnectionModelEndpointConfigurations)

	// Register CLI commands for ListIntegrationConnectionModels
	reg.CliCommand(ctx, "ListIntegrationConnectionModels", c.ListIntegrationConnectionModels)

	// Register CLI commands for GetIntegrationConnectionModel
	reg.CliCommand(ctx, "GetIntegrationConnectionModel", c.GetIntegrationConnectionModel)

	// Register CLI commands for GetIntegration
	reg.CliCommand(ctx, "GetIntegration", c.GetIntegration)

	// Register CLI commands for ListJobs
	reg.CliCommand(ctx, "ListJobs", c.ListJobs)

	// Register CLI commands for CreateJob
	reg.CliCommand(ctx, "CreateJob", c.CreateJob)

	// Register CLI commands for DeleteJob
	reg.CliCommand(ctx, "DeleteJob", c.DeleteJob)

	// Register CLI commands for GetJob
	reg.CliCommand(ctx, "GetJob", c.GetJob)

	// Register CLI commands for UpdateJob
	reg.CliCommand(ctx, "UpdateJob", c.UpdateJob)

	// Register CLI commands for ListJobExecutions
	reg.CliCommand(ctx, "ListJobExecutions", c.ListJobExecutions)

	// Register CLI commands for CreateJobExecution
	reg.CliCommand(ctx, "CreateJobExecution", c.CreateJobExecution)

	// Register CLI commands for DeleteJobExecution
	reg.CliCommand(ctx, "DeleteJobExecution", c.DeleteJobExecution)

	// Register CLI commands for GetJobExecution
	reg.CliCommand(ctx, "GetJobExecution", c.GetJobExecution)

	// Register CLI commands for ListJobRevisions
	reg.CliCommand(ctx, "ListJobRevisions", c.ListJobRevisions)

	// Register CLI commands for ListLocations
	reg.CliCommand(ctx, "ListLocations", c.ListLocations)

	// Register CLI commands for ListMCPHubDefinitions
	reg.CliCommand(ctx, "ListMCPHubDefinitions", c.ListMCPHubDefinitions)

	// Register CLI commands for ListModels
	reg.CliCommand(ctx, "ListModels", c.ListModels)

	// Register CLI commands for CreateModel
	reg.CliCommand(ctx, "CreateModel", c.CreateModel)

	// Register CLI commands for DeleteModel
	reg.CliCommand(ctx, "DeleteModel", c.DeleteModel)

	// Register CLI commands for GetModel
	reg.CliCommand(ctx, "GetModel", c.GetModel)

	// Register CLI commands for UpdateModel
	reg.CliCommand(ctx, "UpdateModel", c.UpdateModel)

	// Register CLI commands for ListModelRevisions
	reg.CliCommand(ctx, "ListModelRevisions", c.ListModelRevisions)

	// Register CLI commands for ListPolicies
	reg.CliCommand(ctx, "ListPolicies", c.ListPolicies)

	// Register CLI commands for CreatePolicy
	reg.CliCommand(ctx, "CreatePolicy", c.CreatePolicy)

	// Register CLI commands for DeletePolicy
	reg.CliCommand(ctx, "DeletePolicy", c.DeletePolicy)

	// Register CLI commands for GetPolicy
	reg.CliCommand(ctx, "GetPolicy", c.GetPolicy)

	// Register CLI commands for UpdatePolicy
	reg.CliCommand(ctx, "UpdatePolicy", c.UpdatePolicy)

	// Register CLI commands for ListAllPendingInvitations
	reg.CliCommand(ctx, "ListAllPendingInvitations", c.ListAllPendingInvitations)

	// Register CLI commands for ListPublicIps
	reg.CliCommand(ctx, "ListPublicIps", c.ListPublicIps)

	// Register CLI commands for ListSandboxHubDefinitions
	reg.CliCommand(ctx, "ListSandboxHubDefinitions", c.ListSandboxHubDefinitions)

	// Register CLI commands for ListSandboxes
	reg.CliCommand(ctx, "ListSandboxes", c.ListSandboxes)

	// Register CLI commands for CreateSandbox
	reg.CliCommand(ctx, "CreateSandbox", c.CreateSandbox)

	// Register CLI commands for DeleteSandbox
	reg.CliCommand(ctx, "DeleteSandbox", c.DeleteSandbox)

	// Register CLI commands for GetSandbox
	reg.CliCommand(ctx, "GetSandbox", c.GetSandbox)

	// Register CLI commands for UpdateSandbox
	reg.CliCommand(ctx, "UpdateSandbox", c.UpdateSandbox)

	// Register CLI commands for ListSandboxPreviews
	reg.CliCommand(ctx, "ListSandboxPreviews", c.ListSandboxPreviews)

	// Register CLI commands for CreateSandboxPreview
	reg.CliCommand(ctx, "CreateSandboxPreview", c.CreateSandboxPreview)

	// Register CLI commands for DeleteSandboxPreview
	reg.CliCommand(ctx, "DeleteSandboxPreview", c.DeleteSandboxPreview)

	// Register CLI commands for GetSandboxPreview
	reg.CliCommand(ctx, "GetSandboxPreview", c.GetSandboxPreview)

	// Register CLI commands for UpdateSandboxPreview
	reg.CliCommand(ctx, "UpdateSandboxPreview", c.UpdateSandboxPreview)

	// Register CLI commands for ListSandboxPreviewTokens
	reg.CliCommand(ctx, "ListSandboxPreviewTokens", c.ListSandboxPreviewTokens)

	// Register CLI commands for CreateSandboxPreviewToken
	reg.CliCommand(ctx, "CreateSandboxPreviewToken", c.CreateSandboxPreviewToken)

	// Register CLI commands for DeleteSandboxPreviewToken
	reg.CliCommand(ctx, "DeleteSandboxPreviewToken", c.DeleteSandboxPreviewToken)

	// Register CLI commands for StartSandbox
	reg.CliCommand(ctx, "StartSandbox", c.StartSandbox)

	// Register CLI commands for StopSandbox
	reg.CliCommand(ctx, "StopSandbox", c.StopSandbox)

	// Register CLI commands for GetWorkspaceServiceAccounts
	reg.CliCommand(ctx, "GetWorkspaceServiceAccounts", c.GetWorkspaceServiceAccounts)

	// Register CLI commands for CreateWorkspaceServiceAccount
	reg.CliCommand(ctx, "CreateWorkspaceServiceAccount", c.CreateWorkspaceServiceAccount)

	// Register CLI commands for DeleteWorkspaceServiceAccount
	reg.CliCommand(ctx, "DeleteWorkspaceServiceAccount", c.DeleteWorkspaceServiceAccount)

	// Register CLI commands for UpdateWorkspaceServiceAccount
	reg.CliCommand(ctx, "UpdateWorkspaceServiceAccount", c.UpdateWorkspaceServiceAccount)

	// Register CLI commands for ListApiKeysForServiceAccount
	reg.CliCommand(ctx, "ListApiKeysForServiceAccount", c.ListApiKeysForServiceAccount)

	// Register CLI commands for CreateApiKeyForServiceAccount
	reg.CliCommand(ctx, "CreateApiKeyForServiceAccount", c.CreateApiKeyForServiceAccount)

	// Register CLI commands for DeleteApiKeyForServiceAccount
	reg.CliCommand(ctx, "DeleteApiKeyForServiceAccount", c.DeleteApiKeyForServiceAccount)

	// Register CLI commands for ListTemplates
	reg.CliCommand(ctx, "ListTemplates", c.ListTemplates)

	// Register CLI commands for GetTemplate
	reg.CliCommand(ctx, "GetTemplate", c.GetTemplate)

	// Register CLI commands for ListWorkspaceUsers
	reg.CliCommand(ctx, "ListWorkspaceUsers", c.ListWorkspaceUsers)

	// Register CLI commands for InviteWorkspaceUser
	reg.CliCommand(ctx, "InviteWorkspaceUser", c.InviteWorkspaceUser)

	// Register CLI commands for RemoveWorkspaceUser
	reg.CliCommand(ctx, "RemoveWorkspaceUser", c.RemoveWorkspaceUser)

	// Register CLI commands for UpdateWorkspaceUserRole
	reg.CliCommand(ctx, "UpdateWorkspaceUserRole", c.UpdateWorkspaceUserRole)

	// Register CLI commands for ListVolumeTemplates
	reg.CliCommand(ctx, "ListVolumeTemplates", c.ListVolumeTemplates)

	// Register CLI commands for CreateVolumeTemplate
	reg.CliCommand(ctx, "CreateVolumeTemplate", c.CreateVolumeTemplate)

	// Register CLI commands for DeleteVolumeTemplate
	reg.CliCommand(ctx, "DeleteVolumeTemplate", c.DeleteVolumeTemplate)

	// Register CLI commands for GetVolumeTemplate
	reg.CliCommand(ctx, "GetVolumeTemplate", c.GetVolumeTemplate)

	// Register CLI commands for UpdateVolumeTemplate
	reg.CliCommand(ctx, "UpdateVolumeTemplate", c.UpdateVolumeTemplate)

	// Register CLI commands for DeleteVolumeTemplateVersion
	reg.CliCommand(ctx, "DeleteVolumeTemplateVersion", c.DeleteVolumeTemplateVersion)

	// Register CLI commands for ListVolumes
	reg.CliCommand(ctx, "ListVolumes", c.ListVolumes)

	// Register CLI commands for CreateVolume
	reg.CliCommand(ctx, "CreateVolume", c.CreateVolume)

	// Register CLI commands for DeleteVolume
	reg.CliCommand(ctx, "DeleteVolume", c.DeleteVolume)

	// Register CLI commands for GetVolume
	reg.CliCommand(ctx, "GetVolume", c.GetVolume)

	// Register CLI commands for ListWorkspaces
	reg.CliCommand(ctx, "ListWorkspaces", c.ListWorkspaces)

	// Register CLI commands for CreateWorkspace
	reg.CliCommand(ctx, "CreateWorkspace", c.CreateWorkspace)

	// Register CLI commands for CheckWorkspaceAvailability
	reg.CliCommand(ctx, "CheckWorkspaceAvailability", c.CheckWorkspaceAvailability)

	// Register CLI commands for DeleteWorkspace
	reg.CliCommand(ctx, "DeleteWorkspace", c.DeleteWorkspace)

	// Register CLI commands for GetWorkspace
	reg.CliCommand(ctx, "GetWorkspace", c.GetWorkspace)

	// Register CLI commands for UpdateWorkspace
	reg.CliCommand(ctx, "UpdateWorkspace", c.UpdateWorkspace)

	// Register CLI commands for DeclineWorkspaceInvitation
	reg.CliCommand(ctx, "DeclineWorkspaceInvitation", c.DeclineWorkspaceInvitation)

	// Register CLI commands for AcceptWorkspaceInvitation
	reg.CliCommand(ctx, "AcceptWorkspaceInvitation", c.AcceptWorkspaceInvitation)

	// Register CLI commands for LeaveWorkspace
	reg.CliCommand(ctx, "LeaveWorkspace", c.LeaveWorkspace)

}

func (c *Client) ListAgents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgent(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgent(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentRequest(c.Server, agentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgent(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentRequest(c.Server, agentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentWithBody(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentRequestWithBody(c.Server, agentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgent(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentRequest(c.Server, agentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAgentRevisions(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentRevisionsRequest(c.Server, agentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomDomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomDomain(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomDomainWithBody(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomDomainRequestWithBody(c.Server, domainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomDomain(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomDomainRequest(c.Server, domainName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFunction(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFunctionRequest(c.Server, functionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunction(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionRequest(c.Server, functionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunctionWithBody(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequestWithBody(c.Server, functionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunction(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequest(c.Server, functionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctionRevisions(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionRevisionsRequest(c.Server, functionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CleanupImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCleanupImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, resourceType, imageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageRequest(c.Server, resourceType, imageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImageTag(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageTagRequest(c.Server, resourceType, imageName, tagName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConnectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationConnection(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIntegrationConnectionRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationConnectionWithBody(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationConnectionRequestWithBody(c.Server, connectionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationConnection(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationConnectionRequest(c.Server, connectionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnectionModelEndpointConfigurations(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionModelEndpointConfigurationsRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConnectionModels(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConnectionModelsRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnectionModel(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionModelRequest(c.Server, connectionName, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegration(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationRequest(c.Server, integrationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJob(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobExecutions(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobExecutionsRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobExecutionWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobExecutionRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobExecution(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobExecutionRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobExecutionRequest(c.Server, jobId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobExecutionRequest(c.Server, jobId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobRevisions(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobRevisionsRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLocationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMCPHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMCPHubDefinitionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModel(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModelRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModelWithBody(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelRequestWithBody(c.Server, modelName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModel(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelRequest(c.Server, modelName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModelRevisions(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelRevisionsRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllPendingInvitations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllPendingInvitationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPublicIps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPublicIpsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxHubDefinitionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandbox(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandbox(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxRequest(c.Server, sandboxName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxRequestWithBody(c.Server, sandboxName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandbox(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxRequest(c.Server, sandboxName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxPreviews(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxPreviewsRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewRequestWithBody(c.Server, sandboxName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreview(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewRequest(c.Server, sandboxName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxPreviewRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxPreviewRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxPreviewWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxPreviewRequestWithBody(c.Server, sandboxName, previewName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxPreview(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxPreviewRequest(c.Server, sandboxName, previewName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxPreviewTokens(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxPreviewTokensRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewTokenWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewTokenRequestWithBody(c.Server, sandboxName, previewName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewTokenRequest(c.Server, sandboxName, previewName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxPreviewTokenRequest(c.Server, sandboxName, previewName, tokenName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartSandboxRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopSandboxRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceServiceAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceServiceAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceServiceAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceServiceAccount(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceServiceAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspaceServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceServiceAccountRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceServiceAccountRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceServiceAccount(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceServiceAccountRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiKeysForServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysForServiceAccountRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyForServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyForServiceAccountRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyForServiceAccount(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyForServiceAccountRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKeyForServiceAccount(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeyForServiceAccountRequest(c.Server, clientId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplate(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateRequest(c.Server, templateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteWorkspaceUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteWorkspaceUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteWorkspaceUser(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteWorkspaceUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveWorkspaceUser(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveWorkspaceUserRequest(c.Server, subOrEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceUserRoleWithBody(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceUserRoleRequestWithBody(c.Server, subOrEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceUserRole(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceUserRoleRequest(c.Server, subOrEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVolumeTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVolumeTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeTemplateWithBody(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeTemplateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeTemplate(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeTemplateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeTemplateRequest(c.Server, volumeTemplateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVolumeTemplateRequest(c.Server, volumeTemplateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeTemplateWithBody(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeTemplateRequestWithBody(c.Server, volumeTemplateName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeTemplate(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeTemplateRequest(c.Server, volumeTemplateName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeTemplateVersion(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeTemplateVersionRequest(c.Server, volumeTemplateName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVolumes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVolumesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, volumeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVolumeRequest(c.Server, volumeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckWorkspaceAvailabilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckWorkspaceAvailabilityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckWorkspaceAvailability(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckWorkspaceAvailabilityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceWithBody(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequestWithBody(c.Server, workspaceName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspace(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequest(c.Server, workspaceName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineWorkspaceInvitationRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptWorkspaceInvitationRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAgentsRequest generates requests for ListAgents
func NewListAgentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentRequest calls the generic CreateAgent builder with application/json body
func NewCreateAgentRequest(server string, body CreateAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentRequestWithBody generates requests for CreateAgent with any type of body
func NewCreateAgentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAgentRequest generates requests for DeleteAgent
func NewDeleteAgentRequest(server string, agentName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAgentRequest generates requests for GetAgent
func NewGetAgentRequest(server string, agentName string, params *GetAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAgentRequest calls the generic UpdateAgent builder with application/json body
func NewUpdateAgentRequest(server string, agentName string, body UpdateAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAgentRequestWithBody(server, agentName, "application/json", bodyReader)
}

// NewUpdateAgentRequestWithBody generates requests for UpdateAgent with any type of body
func NewUpdateAgentRequestWithBody(server string, agentName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAgentRevisionsRequest generates requests for ListAgentRevisions
func NewListAgentRevisionsRequest(server string, agentName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationRequest generates requests for GetConfiguration
func NewGetConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomDomainsRequest generates requests for ListCustomDomains
func NewListCustomDomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomDomainRequest calls the generic CreateCustomDomain builder with application/json body
func NewCreateCustomDomainRequest(server string, body CreateCustomDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomDomainRequestWithBody generates requests for CreateCustomDomain with any type of body
func NewCreateCustomDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomDomainRequest generates requests for DeleteCustomDomain
func NewDeleteCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomDomainRequest generates requests for GetCustomDomain
func NewGetCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomDomainRequest calls the generic UpdateCustomDomain builder with application/json body
func NewUpdateCustomDomainRequest(server string, domainName string, body UpdateCustomDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomDomainRequestWithBody(server, domainName, "application/json", bodyReader)
}

// NewUpdateCustomDomainRequestWithBody generates requests for UpdateCustomDomain with any type of body
func NewUpdateCustomDomainRequestWithBody(server string, domainName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyCustomDomainRequest generates requests for VerifyCustomDomain
func NewVerifyCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s/verify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFunctionsRequest generates requests for ListFunctions
func NewListFunctionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFunctionRequest calls the generic CreateFunction builder with application/json body
func NewCreateFunctionRequest(server string, body CreateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFunctionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFunctionRequestWithBody generates requests for CreateFunction with any type of body
func NewCreateFunctionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFunctionRequest generates requests for DeleteFunction
func NewDeleteFunctionRequest(server string, functionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFunctionRequest generates requests for GetFunction
func NewGetFunctionRequest(server string, functionName string, params *GetFunctionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFunctionRequest calls the generic UpdateFunction builder with application/json body
func NewUpdateFunctionRequest(server string, functionName string, body UpdateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFunctionRequestWithBody(server, functionName, "application/json", bodyReader)
}

// NewUpdateFunctionRequestWithBody generates requests for UpdateFunction with any type of body
func NewUpdateFunctionRequestWithBody(server string, functionName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFunctionRevisionsRequest generates requests for ListFunctionRevisions
func NewListFunctionRevisionsRequest(server string, functionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCleanupImagesRequest generates requests for CleanupImages
func NewCleanupImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListImagesRequest generates requests for ListImages
func NewListImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, resourceType string, imageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImageRequest generates requests for GetImage
func NewGetImageRequest(server string, resourceType string, imageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImageTagRequest generates requests for DeleteImageTag
func NewDeleteImageTagRequest(server string, resourceType string, imageName string, tagName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tagName", runtime.ParamLocationPath, tagName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s/tags/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationConnectionsRequest generates requests for ListIntegrationConnections
func NewListIntegrationConnectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIntegrationConnectionRequest calls the generic CreateIntegrationConnection builder with application/json body
func NewCreateIntegrationConnectionRequest(server string, body CreateIntegrationConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIntegrationConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIntegrationConnectionRequestWithBody generates requests for CreateIntegrationConnection with any type of body
func NewCreateIntegrationConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIntegrationConnectionRequest generates requests for DeleteIntegrationConnection
func NewDeleteIntegrationConnectionRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConnectionRequest generates requests for GetIntegrationConnection
func NewGetIntegrationConnectionRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIntegrationConnectionRequest calls the generic UpdateIntegrationConnection builder with application/json body
func NewUpdateIntegrationConnectionRequest(server string, connectionName string, body UpdateIntegrationConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIntegrationConnectionRequestWithBody(server, connectionName, "application/json", bodyReader)
}

// NewUpdateIntegrationConnectionRequestWithBody generates requests for UpdateIntegrationConnection with any type of body
func NewUpdateIntegrationConnectionRequestWithBody(server string, connectionName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIntegrationConnectionModelEndpointConfigurationsRequest generates requests for GetIntegrationConnectionModelEndpointConfigurations
func NewGetIntegrationConnectionModelEndpointConfigurationsRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/endpointConfigurations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationConnectionModelsRequest generates requests for ListIntegrationConnectionModels
func NewListIntegrationConnectionModelsRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConnectionModelRequest generates requests for GetIntegrationConnectionModel
func NewGetIntegrationConnectionModelRequest(server string, connectionName string, modelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationRequest generates requests for GetIntegration
func NewGetIntegrationRequest(server string, integrationName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationName", runtime.ParamLocationPath, integrationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobRequest calls the generic CreateJob builder with application/json body
func NewCreateJobRequest(server string, body CreateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateJobRequestWithBody generates requests for CreateJob with any type of body
func NewCreateJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobRequest generates requests for DeleteJob
func NewDeleteJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, jobId string, params *GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJobRequest calls the generic UpdateJob builder with application/json body
func NewUpdateJobRequest(server string, jobId string, body UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewUpdateJobRequestWithBody generates requests for UpdateJob with any type of body
func NewUpdateJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListJobExecutionsRequest generates requests for ListJobExecutions
func NewListJobExecutionsRequest(server string, jobId string, params *ListJobExecutionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobExecutionRequest calls the generic CreateJobExecution builder with application/json body
func NewCreateJobExecutionRequest(server string, jobId string, body CreateJobExecutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobExecutionRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewCreateJobExecutionRequestWithBody generates requests for CreateJobExecution with any type of body
func NewCreateJobExecutionRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobExecutionRequest generates requests for DeleteJobExecution
func NewDeleteJobExecutionRequest(server string, jobId string, executionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobExecutionRequest generates requests for GetJobExecution
func NewGetJobExecutionRequest(server string, jobId string, executionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobRevisionsRequest generates requests for ListJobRevisions
func NewListJobRevisionsRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLocationsRequest generates requests for ListLocations
func NewListLocationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMCPHubDefinitionsRequest generates requests for ListMCPHubDefinitions
func NewListMCPHubDefinitionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mcp/hub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListModelsRequest generates requests for ListModels
func NewListModelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModelRequest calls the generic CreateModel builder with application/json body
func NewCreateModelRequest(server string, body CreateModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateModelRequestWithBody generates requests for CreateModel with any type of body
func NewCreateModelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModelRequest generates requests for DeleteModel
func NewDeleteModelRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModelRequest generates requests for GetModel
func NewGetModelRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateModelRequest calls the generic UpdateModel builder with application/json body
func NewUpdateModelRequest(server string, modelName string, body UpdateModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateModelRequestWithBody(server, modelName, "application/json", bodyReader)
}

// NewUpdateModelRequestWithBody generates requests for UpdateModel with any type of body
func NewUpdateModelRequestWithBody(server string, modelName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModelRevisionsRequest generates requests for ListModelRevisions
func NewListModelRevisionsRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyName string, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyName, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllPendingInvitationsRequest generates requests for ListAllPendingInvitations
func NewListAllPendingInvitationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/invitations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPublicIpsRequest generates requests for ListPublicIps
func NewListPublicIpsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxHubDefinitionsRequest generates requests for ListSandboxHubDefinitions
func NewListSandboxHubDefinitionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/hub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxesRequest generates requests for ListSandboxes
func NewListSandboxesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxRequest calls the generic CreateSandbox builder with application/json body
func NewCreateSandboxRequest(server string, body CreateSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSandboxRequestWithBody generates requests for CreateSandbox with any type of body
func NewCreateSandboxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxRequest generates requests for DeleteSandbox
func NewDeleteSandboxRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxRequest generates requests for GetSandbox
func NewGetSandboxRequest(server string, sandboxName string, params *GetSandboxParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSandboxRequest calls the generic UpdateSandbox builder with application/json body
func NewUpdateSandboxRequest(server string, sandboxName string, body UpdateSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSandboxRequestWithBody(server, sandboxName, "application/json", bodyReader)
}

// NewUpdateSandboxRequestWithBody generates requests for UpdateSandbox with any type of body
func NewUpdateSandboxRequestWithBody(server string, sandboxName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSandboxPreviewsRequest generates requests for ListSandboxPreviews
func NewListSandboxPreviewsRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxPreviewRequest calls the generic CreateSandboxPreview builder with application/json body
func NewCreateSandboxPreviewRequest(server string, sandboxName string, body CreateSandboxPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxPreviewRequestWithBody(server, sandboxName, "application/json", bodyReader)
}

// NewCreateSandboxPreviewRequestWithBody generates requests for CreateSandboxPreview with any type of body
func NewCreateSandboxPreviewRequestWithBody(server string, sandboxName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxPreviewRequest generates requests for DeleteSandboxPreview
func NewDeleteSandboxPreviewRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxPreviewRequest generates requests for GetSandboxPreview
func NewGetSandboxPreviewRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSandboxPreviewRequest calls the generic UpdateSandboxPreview builder with application/json body
func NewUpdateSandboxPreviewRequest(server string, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSandboxPreviewRequestWithBody(server, sandboxName, previewName, "application/json", bodyReader)
}

// NewUpdateSandboxPreviewRequestWithBody generates requests for UpdateSandboxPreview with any type of body
func NewUpdateSandboxPreviewRequestWithBody(server string, sandboxName string, previewName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSandboxPreviewTokensRequest generates requests for ListSandboxPreviewTokens
func NewListSandboxPreviewTokensRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxPreviewTokenRequest calls the generic CreateSandboxPreviewToken builder with application/json body
func NewCreateSandboxPreviewTokenRequest(server string, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxPreviewTokenRequestWithBody(server, sandboxName, previewName, "application/json", bodyReader)
}

// NewCreateSandboxPreviewTokenRequestWithBody generates requests for CreateSandboxPreviewToken with any type of body
func NewCreateSandboxPreviewTokenRequestWithBody(server string, sandboxName string, previewName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxPreviewTokenRequest generates requests for DeleteSandboxPreviewToken
func NewDeleteSandboxPreviewTokenRequest(server string, sandboxName string, previewName string, tokenName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenName", runtime.ParamLocationPath, tokenName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartSandboxRequest generates requests for StartSandbox
func NewStartSandboxRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopSandboxRequest generates requests for StopSandbox
func NewStopSandboxRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceServiceAccountsRequest generates requests for GetWorkspaceServiceAccounts
func NewGetWorkspaceServiceAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceServiceAccountRequest calls the generic CreateWorkspaceServiceAccount builder with application/json body
func NewCreateWorkspaceServiceAccountRequest(server string, body CreateWorkspaceServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceServiceAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceServiceAccountRequestWithBody generates requests for CreateWorkspaceServiceAccount with any type of body
func NewCreateWorkspaceServiceAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceServiceAccountRequest generates requests for DeleteWorkspaceServiceAccount
func NewDeleteWorkspaceServiceAccountRequest(server string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceServiceAccountRequest calls the generic UpdateWorkspaceServiceAccount builder with application/json body
func NewUpdateWorkspaceServiceAccountRequest(server string, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceServiceAccountRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewUpdateWorkspaceServiceAccountRequestWithBody generates requests for UpdateWorkspaceServiceAccount with any type of body
func NewUpdateWorkspaceServiceAccountRequestWithBody(server string, clientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListApiKeysForServiceAccountRequest generates requests for ListApiKeysForServiceAccount
func NewListApiKeysForServiceAccountRequest(server string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyForServiceAccountRequest calls the generic CreateApiKeyForServiceAccount builder with application/json body
func NewCreateApiKeyForServiceAccountRequest(server string, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyForServiceAccountRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewCreateApiKeyForServiceAccountRequestWithBody generates requests for CreateApiKeyForServiceAccount with any type of body
func NewCreateApiKeyForServiceAccountRequestWithBody(server string, clientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeyForServiceAccountRequest generates requests for DeleteApiKeyForServiceAccount
func NewDeleteApiKeyForServiceAccountRequest(server string, clientId string, apiKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "apiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTemplatesRequest generates requests for ListTemplates
func NewListTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateRequest generates requests for GetTemplate
func NewGetTemplateRequest(server string, templateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateName", runtime.ParamLocationPath, templateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceUsersRequest generates requests for ListWorkspaceUsers
func NewListWorkspaceUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteWorkspaceUserRequest calls the generic InviteWorkspaceUser builder with application/json body
func NewInviteWorkspaceUserRequest(server string, body InviteWorkspaceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteWorkspaceUserRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteWorkspaceUserRequestWithBody generates requests for InviteWorkspaceUser with any type of body
func NewInviteWorkspaceUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveWorkspaceUserRequest generates requests for RemoveWorkspaceUser
func NewRemoveWorkspaceUserRequest(server string, subOrEmail string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subOrEmail", runtime.ParamLocationPath, subOrEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceUserRoleRequest calls the generic UpdateWorkspaceUserRole builder with application/json body
func NewUpdateWorkspaceUserRoleRequest(server string, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceUserRoleRequestWithBody(server, subOrEmail, "application/json", bodyReader)
}

// NewUpdateWorkspaceUserRoleRequestWithBody generates requests for UpdateWorkspaceUserRole with any type of body
func NewUpdateWorkspaceUserRoleRequestWithBody(server string, subOrEmail string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subOrEmail", runtime.ParamLocationPath, subOrEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVolumeTemplatesRequest generates requests for ListVolumeTemplates
func NewListVolumeTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeTemplateRequest calls the generic CreateVolumeTemplate builder with application/json body
func NewCreateVolumeTemplateRequest(server string, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeTemplateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVolumeTemplateRequestWithBody generates requests for CreateVolumeTemplate with any type of body
func NewCreateVolumeTemplateRequestWithBody(server string, params *CreateVolumeTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Upload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upload", runtime.ParamLocationQuery, *params.Upload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeTemplateRequest generates requests for DeleteVolumeTemplate
func NewDeleteVolumeTemplateRequest(server string, volumeTemplateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVolumeTemplateRequest generates requests for GetVolumeTemplate
func NewGetVolumeTemplateRequest(server string, volumeTemplateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeTemplateRequest calls the generic UpdateVolumeTemplate builder with application/json body
func NewUpdateVolumeTemplateRequest(server string, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeTemplateRequestWithBody(server, volumeTemplateName, params, "application/json", bodyReader)
}

// NewUpdateVolumeTemplateRequestWithBody generates requests for UpdateVolumeTemplate with any type of body
func NewUpdateVolumeTemplateRequestWithBody(server string, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Upload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upload", runtime.ParamLocationQuery, *params.Upload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeTemplateVersionRequest generates requests for DeleteVolumeTemplateVersion
func NewDeleteVolumeTemplateVersionRequest(server string, volumeTemplateName string, versionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "versionName", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVolumesRequest generates requests for ListVolumes
func NewListVolumesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, volumeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVolumeRequest generates requests for GetVolume
func NewGetVolumeRequest(server string, volumeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckWorkspaceAvailabilityRequest calls the generic CheckWorkspaceAvailability builder with application/json body
func NewCheckWorkspaceAvailabilityRequest(server string, body CheckWorkspaceAvailabilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckWorkspaceAvailabilityRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckWorkspaceAvailabilityRequestWithBody generates requests for CheckWorkspaceAvailability with any type of body
func NewCheckWorkspaceAvailabilityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/availability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceRequest generates requests for GetWorkspace
func NewGetWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceRequest calls the generic UpdateWorkspace builder with application/json body
func NewUpdateWorkspaceRequest(server string, workspaceName string, body UpdateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceRequestWithBody(server, workspaceName, "application/json", bodyReader)
}

// NewUpdateWorkspaceRequestWithBody generates requests for UpdateWorkspace with any type of body
func NewUpdateWorkspaceRequestWithBody(server string, workspaceName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeclineWorkspaceInvitationRequest generates requests for DeclineWorkspaceInvitation
func NewDeclineWorkspaceInvitationRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/decline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptWorkspaceInvitationRequest generates requests for AcceptWorkspaceInvitation
func NewAcceptWorkspaceInvitationRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/join", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveWorkspaceRequest generates requests for LeaveWorkspace
func NewLeaveWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/leave", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, runServer string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, runServer, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAgentsWithResponse request
	ListAgentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAgentsResponse, error)

	// CreateAgentWithBodyWithResponse request with any body
	CreateAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error)

	CreateAgentWithResponse(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error)

	// DeleteAgentWithResponse request
	DeleteAgentWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*DeleteAgentResponse, error)

	// GetAgentWithResponse request
	GetAgentWithResponse(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*GetAgentResponse, error)

	// UpdateAgentWithBodyWithResponse request with any body
	UpdateAgentWithBodyWithResponse(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error)

	UpdateAgentWithResponse(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error)

	// ListAgentRevisionsWithResponse request
	ListAgentRevisionsWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*ListAgentRevisionsResponse, error)

	// GetConfigurationWithResponse request
	GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error)

	// ListCustomDomainsWithResponse request
	ListCustomDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCustomDomainsResponse, error)

	// CreateCustomDomainWithBodyWithResponse request with any body
	CreateCustomDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error)

	CreateCustomDomainWithResponse(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error)

	// DeleteCustomDomainWithResponse request
	DeleteCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*DeleteCustomDomainResponse, error)

	// GetCustomDomainWithResponse request
	GetCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*GetCustomDomainResponse, error)

	// UpdateCustomDomainWithBodyWithResponse request with any body
	UpdateCustomDomainWithBodyWithResponse(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error)

	UpdateCustomDomainWithResponse(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error)

	// VerifyCustomDomainWithResponse request
	VerifyCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*VerifyCustomDomainResponse, error)

	// ListFunctionsWithResponse request
	ListFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFunctionsResponse, error)

	// CreateFunctionWithBodyWithResponse request with any body
	CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	// DeleteFunctionWithResponse request
	DeleteFunctionWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error)

	// GetFunctionWithResponse request
	GetFunctionWithResponse(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*GetFunctionResponse, error)

	// UpdateFunctionWithBodyWithResponse request with any body
	UpdateFunctionWithBodyWithResponse(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	UpdateFunctionWithResponse(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	// ListFunctionRevisionsWithResponse request
	ListFunctionRevisionsWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*ListFunctionRevisionsResponse, error)

	// CleanupImagesWithResponse request
	CleanupImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CleanupImagesResponse, error)

	// ListImagesWithResponse request
	ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// GetImageWithResponse request
	GetImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*GetImageResponse, error)

	// DeleteImageTagWithResponse request
	DeleteImageTagWithResponse(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*DeleteImageTagResponse, error)

	// ListIntegrationConnectionsWithResponse request
	ListIntegrationConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionsResponse, error)

	// CreateIntegrationConnectionWithBodyWithResponse request with any body
	CreateIntegrationConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error)

	CreateIntegrationConnectionWithResponse(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error)

	// DeleteIntegrationConnectionWithResponse request
	DeleteIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*DeleteIntegrationConnectionResponse, error)

	// GetIntegrationConnectionWithResponse request
	GetIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionResponse, error)

	// UpdateIntegrationConnectionWithBodyWithResponse request with any body
	UpdateIntegrationConnectionWithBodyWithResponse(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error)

	UpdateIntegrationConnectionWithResponse(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error)

	// GetIntegrationConnectionModelEndpointConfigurationsWithResponse request
	GetIntegrationConnectionModelEndpointConfigurationsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error)

	// ListIntegrationConnectionModelsWithResponse request
	ListIntegrationConnectionModelsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionModelsResponse, error)

	// GetIntegrationConnectionModelWithResponse request
	GetIntegrationConnectionModelWithResponse(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelResponse, error)

	// GetIntegrationWithResponse request
	GetIntegrationWithResponse(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error)

	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// CreateJobWithBodyWithResponse request with any body
	CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	// DeleteJobWithResponse request
	DeleteJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// UpdateJobWithBodyWithResponse request with any body
	UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	UpdateJobWithResponse(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	// ListJobExecutionsWithResponse request
	ListJobExecutionsWithResponse(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*ListJobExecutionsResponse, error)

	// CreateJobExecutionWithBodyWithResponse request with any body
	CreateJobExecutionWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error)

	CreateJobExecutionWithResponse(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error)

	// DeleteJobExecutionWithResponse request
	DeleteJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*DeleteJobExecutionResponse, error)

	// GetJobExecutionWithResponse request
	GetJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*GetJobExecutionResponse, error)

	// ListJobRevisionsWithResponse request
	ListJobRevisionsWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*ListJobRevisionsResponse, error)

	// ListLocationsWithResponse request
	ListLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error)

	// ListMCPHubDefinitionsWithResponse request
	ListMCPHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMCPHubDefinitionsResponse, error)

	// ListModelsWithResponse request
	ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResponse, error)

	// CreateModelWithBodyWithResponse request with any body
	CreateModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResponse, error)

	CreateModelWithResponse(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResponse, error)

	// DeleteModelWithResponse request
	DeleteModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*DeleteModelResponse, error)

	// GetModelWithResponse request
	GetModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*GetModelResponse, error)

	// UpdateModelWithBodyWithResponse request with any body
	UpdateModelWithBodyWithResponse(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error)

	UpdateModelWithResponse(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error)

	// ListModelRevisionsWithResponse request
	ListModelRevisionsWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*ListModelRevisionsResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyWithResponse request
	GetPolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListAllPendingInvitationsWithResponse request
	ListAllPendingInvitationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllPendingInvitationsResponse, error)

	// ListPublicIpsWithResponse request
	ListPublicIpsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPublicIpsResponse, error)

	// ListSandboxHubDefinitionsWithResponse request
	ListSandboxHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxHubDefinitionsResponse, error)

	// ListSandboxesWithResponse request
	ListSandboxesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error)

	// CreateSandboxWithBodyWithResponse request with any body
	CreateSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	CreateSandboxWithResponse(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	// DeleteSandboxWithResponse request
	DeleteSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error)

	// GetSandboxWithResponse request
	GetSandboxWithResponse(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error)

	// UpdateSandboxWithBodyWithResponse request with any body
	UpdateSandboxWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error)

	UpdateSandboxWithResponse(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error)

	// ListSandboxPreviewsWithResponse request
	ListSandboxPreviewsWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewsResponse, error)

	// CreateSandboxPreviewWithBodyWithResponse request with any body
	CreateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error)

	CreateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error)

	// DeleteSandboxPreviewWithResponse request
	DeleteSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewResponse, error)

	// GetSandboxPreviewWithResponse request
	GetSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*GetSandboxPreviewResponse, error)

	// UpdateSandboxPreviewWithBodyWithResponse request with any body
	UpdateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error)

	UpdateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error)

	// ListSandboxPreviewTokensWithResponse request
	ListSandboxPreviewTokensWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewTokensResponse, error)

	// CreateSandboxPreviewTokenWithBodyWithResponse request with any body
	CreateSandboxPreviewTokenWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error)

	CreateSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error)

	// DeleteSandboxPreviewTokenWithResponse request
	DeleteSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewTokenResponse, error)

	// StartSandboxWithResponse request
	StartSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*StartSandboxResponse, error)

	// StopSandboxWithResponse request
	StopSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*StopSandboxResponse, error)

	// GetWorkspaceServiceAccountsWithResponse request
	GetWorkspaceServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkspaceServiceAccountsResponse, error)

	// CreateWorkspaceServiceAccountWithBodyWithResponse request with any body
	CreateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error)

	CreateWorkspaceServiceAccountWithResponse(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error)

	// DeleteWorkspaceServiceAccountWithResponse request
	DeleteWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceServiceAccountResponse, error)

	// UpdateWorkspaceServiceAccountWithBodyWithResponse request with any body
	UpdateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error)

	UpdateWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error)

	// ListApiKeysForServiceAccountWithResponse request
	ListApiKeysForServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*ListApiKeysForServiceAccountResponse, error)

	// CreateApiKeyForServiceAccountWithBodyWithResponse request with any body
	CreateApiKeyForServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error)

	CreateApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error)

	// DeleteApiKeyForServiceAccountWithResponse request
	DeleteApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyForServiceAccountResponse, error)

	// ListTemplatesWithResponse request
	ListTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error)

	// GetTemplateWithResponse request
	GetTemplateWithResponse(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error)

	// ListWorkspaceUsersWithResponse request
	ListWorkspaceUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error)

	// InviteWorkspaceUserWithBodyWithResponse request with any body
	InviteWorkspaceUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error)

	InviteWorkspaceUserWithResponse(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error)

	// RemoveWorkspaceUserWithResponse request
	RemoveWorkspaceUserWithResponse(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*RemoveWorkspaceUserResponse, error)

	// UpdateWorkspaceUserRoleWithBodyWithResponse request with any body
	UpdateWorkspaceUserRoleWithBodyWithResponse(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error)

	UpdateWorkspaceUserRoleWithResponse(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error)

	// ListVolumeTemplatesWithResponse request
	ListVolumeTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumeTemplatesResponse, error)

	// CreateVolumeTemplateWithBodyWithResponse request with any body
	CreateVolumeTemplateWithBodyWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error)

	CreateVolumeTemplateWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error)

	// DeleteVolumeTemplateWithResponse request
	DeleteVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateResponse, error)

	// GetVolumeTemplateWithResponse request
	GetVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*GetVolumeTemplateResponse, error)

	// UpdateVolumeTemplateWithBodyWithResponse request with any body
	UpdateVolumeTemplateWithBodyWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error)

	UpdateVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error)

	// DeleteVolumeTemplateVersionWithResponse request
	DeleteVolumeTemplateVersionWithResponse(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateVersionResponse, error)

	// ListVolumesWithResponse request
	ListVolumesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumesResponse, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// GetVolumeWithResponse request
	GetVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*GetVolumeResponse, error)

	// ListWorkspacesWithResponse request
	ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// CreateWorkspaceWithBodyWithResponse request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// CheckWorkspaceAvailabilityWithBodyWithResponse request with any body
	CheckWorkspaceAvailabilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error)

	CheckWorkspaceAvailabilityWithResponse(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error)

	// DeleteWorkspaceWithResponse request
	DeleteWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// GetWorkspaceWithResponse request
	GetWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error)

	// UpdateWorkspaceWithBodyWithResponse request with any body
	UpdateWorkspaceWithBodyWithResponse(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)

	UpdateWorkspaceWithResponse(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)

	// DeclineWorkspaceInvitationWithResponse request
	DeclineWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeclineWorkspaceInvitationResponse, error)

	// AcceptWorkspaceInvitationWithResponse request
	AcceptWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*AcceptWorkspaceInvitationResponse, error)

	// LeaveWorkspaceWithResponse request
	LeaveWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error)
}

type ListAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Agent
}

// Status returns HTTPResponse.Status
func (r ListAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r CreateAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r DeleteAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r GetAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r UpdateAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAgentRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListAgentRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Configuration
}

// Status returns HTTPResponse.Status
func (r GetConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CustomDomain
}

// Status returns HTTPResponse.Status
func (r ListCustomDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r CreateCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r DeleteCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r GetCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r UpdateCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r VerifyCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Function
}

// Status returns HTTPResponse.Status
func (r ListFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r CreateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r DeleteFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r GetFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r UpdateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListFunctionRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CleanupImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Number of images deleted
		Deleted *int `json:"deleted,omitempty"`

		// Message Result message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CleanupImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CleanupImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Image
}

// Status returns HTTPResponse.Status
func (r ListImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r GetImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r DeleteImageTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r CreateIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r DeleteIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r UpdateIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionModelEndpointConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionModelEndpointConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionModelEndpointConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConnectionModelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConnectionModelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConnectionModelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r GetIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r CreateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobExecutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JobExecution
}

// Status returns HTTPResponse.Status
func (r ListJobExecutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobExecutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r CreateJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r DeleteJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r GetJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListJobRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LocationResponse
}

// Status returns HTTPResponse.Status
func (r ListLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMCPHubDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MCPDefinition
}

// Status returns HTTPResponse.Status
func (r ListMCPHubDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMCPHubDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Model
}

// Status returns HTTPResponse.Status
func (r ListModelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r CreateModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r DeleteModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r GetModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r UpdateModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListModelRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Policy
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllPendingInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PendingInvitationRender
}

// Status returns HTTPResponse.Status
func (r ListAllPendingInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllPendingInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPublicIpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicIps
}

// Status returns HTTPResponse.Status
func (r ListPublicIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPublicIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxHubDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SandboxDefinition
}

// Status returns HTTPResponse.Status
func (r ListSandboxHubDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxHubDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Sandbox
}

// Status returns HTTPResponse.Status
func (r ListSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r CreateSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r GetSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r UpdateSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxPreviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Preview
}

// Status returns HTTPResponse.Status
func (r ListSandboxPreviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxPreviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r CreateSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r GetSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r UpdateSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxPreviewTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PreviewToken
}

// Status returns HTTPResponse.Status
func (r ListSandboxPreviewTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxPreviewTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxPreviewTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreviewToken
}

// Status returns HTTPResponse.Status
func (r CreateSandboxPreviewTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxPreviewTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxPreviewTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Message Success message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxPreviewTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxPreviewTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartSandbox
}

// Status returns HTTPResponse.Status
func (r StartSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StopSandbox
}

// Status returns HTTPResponse.Status
func (r StopSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// ClientSecret Service account client secret (only returned on creation)
		ClientSecret *string `json:"client_secret,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiKeysForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApiKey
}

// Status returns HTTPResponse.Status
func (r ListApiKeysForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKey
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeyForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeyForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeyForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
}

// Status returns HTTPResponse.Status
func (r ListTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Template
}

// Status returns HTTPResponse.Status
func (r GetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceUser
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteWorkspaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitation
}

// Status returns HTTPResponse.Status
func (r InviteWorkspaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteWorkspaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveWorkspaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveWorkspaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveWorkspaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceUserRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspaceUser
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceUserRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceUserRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVolumeTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r ListVolumeTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVolumeTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r CreateVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r GetVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeTemplateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`

		// Template Volume template for creating pre-configured volumes
		Template *VolumeTemplate `json:"template,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeTemplateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeTemplateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Volume
}

// Status returns HTTPResponse.Status
func (r ListVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r GetVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckWorkspaceAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r CheckWorkspaceAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckWorkspaceAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineWorkspaceInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitation
}

// Status returns HTTPResponse.Status
func (r DeclineWorkspaceInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineWorkspaceInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptWorkspaceInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitationAccept
}

// Status returns HTTPResponse.Status
func (r AcceptWorkspaceInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptWorkspaceInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r LeaveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAgentsWithResponse request returning *ListAgentsResponse
func (c *ClientWithResponses) ListAgentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAgentsResponse, error) {
	rsp, err := c.ListAgents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentsResponse(rsp)
}

// CreateAgentWithBodyWithResponse request with arbitrary body returning *CreateAgentResponse
func (c *ClientWithResponses) CreateAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error) {
	rsp, err := c.CreateAgentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentWithResponse(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error) {
	rsp, err := c.CreateAgent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentResponse(rsp)
}

// DeleteAgentWithResponse request returning *DeleteAgentResponse
func (c *ClientWithResponses) DeleteAgentWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*DeleteAgentResponse, error) {
	rsp, err := c.DeleteAgent(ctx, agentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentResponse(rsp)
}

// GetAgentWithResponse request returning *GetAgentResponse
func (c *ClientWithResponses) GetAgentWithResponse(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*GetAgentResponse, error) {
	rsp, err := c.GetAgent(ctx, agentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentResponse(rsp)
}

// UpdateAgentWithBodyWithResponse request with arbitrary body returning *UpdateAgentResponse
func (c *ClientWithResponses) UpdateAgentWithBodyWithResponse(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error) {
	rsp, err := c.UpdateAgentWithBody(ctx, agentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentResponse(rsp)
}

func (c *ClientWithResponses) UpdateAgentWithResponse(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error) {
	rsp, err := c.UpdateAgent(ctx, agentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentResponse(rsp)
}

// ListAgentRevisionsWithResponse request returning *ListAgentRevisionsResponse
func (c *ClientWithResponses) ListAgentRevisionsWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*ListAgentRevisionsResponse, error) {
	rsp, err := c.ListAgentRevisions(ctx, agentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentRevisionsResponse(rsp)
}

// GetConfigurationWithResponse request returning *GetConfigurationResponse
func (c *ClientWithResponses) GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error) {
	rsp, err := c.GetConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationResponse(rsp)
}

// ListCustomDomainsWithResponse request returning *ListCustomDomainsResponse
func (c *ClientWithResponses) ListCustomDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCustomDomainsResponse, error) {
	rsp, err := c.ListCustomDomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomDomainsResponse(rsp)
}

// CreateCustomDomainWithBodyWithResponse request with arbitrary body returning *CreateCustomDomainResponse
func (c *ClientWithResponses) CreateCustomDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error) {
	rsp, err := c.CreateCustomDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomDomainWithResponse(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error) {
	rsp, err := c.CreateCustomDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomDomainResponse(rsp)
}

// DeleteCustomDomainWithResponse request returning *DeleteCustomDomainResponse
func (c *ClientWithResponses) DeleteCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*DeleteCustomDomainResponse, error) {
	rsp, err := c.DeleteCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomDomainResponse(rsp)
}

// GetCustomDomainWithResponse request returning *GetCustomDomainResponse
func (c *ClientWithResponses) GetCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*GetCustomDomainResponse, error) {
	rsp, err := c.GetCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomDomainResponse(rsp)
}

// UpdateCustomDomainWithBodyWithResponse request with arbitrary body returning *UpdateCustomDomainResponse
func (c *ClientWithResponses) UpdateCustomDomainWithBodyWithResponse(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error) {
	rsp, err := c.UpdateCustomDomainWithBody(ctx, domainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomDomainResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomDomainWithResponse(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error) {
	rsp, err := c.UpdateCustomDomain(ctx, domainName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomDomainResponse(rsp)
}

// VerifyCustomDomainWithResponse request returning *VerifyCustomDomainResponse
func (c *ClientWithResponses) VerifyCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*VerifyCustomDomainResponse, error) {
	rsp, err := c.VerifyCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyCustomDomainResponse(rsp)
}

// ListFunctionsWithResponse request returning *ListFunctionsResponse
func (c *ClientWithResponses) ListFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFunctionsResponse, error) {
	rsp, err := c.ListFunctions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionsResponse(rsp)
}

// CreateFunctionWithBodyWithResponse request with arbitrary body returning *CreateFunctionResponse
func (c *ClientWithResponses) CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunctionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

func (c *ClientWithResponses) CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

// DeleteFunctionWithResponse request returning *DeleteFunctionResponse
func (c *ClientWithResponses) DeleteFunctionWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error) {
	rsp, err := c.DeleteFunction(ctx, functionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFunctionResponse(rsp)
}

// GetFunctionWithResponse request returning *GetFunctionResponse
func (c *ClientWithResponses) GetFunctionWithResponse(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*GetFunctionResponse, error) {
	rsp, err := c.GetFunction(ctx, functionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionResponse(rsp)
}

// UpdateFunctionWithBodyWithResponse request with arbitrary body returning *UpdateFunctionResponse
func (c *ClientWithResponses) UpdateFunctionWithBodyWithResponse(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunctionWithBody(ctx, functionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

func (c *ClientWithResponses) UpdateFunctionWithResponse(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunction(ctx, functionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

// ListFunctionRevisionsWithResponse request returning *ListFunctionRevisionsResponse
func (c *ClientWithResponses) ListFunctionRevisionsWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*ListFunctionRevisionsResponse, error) {
	rsp, err := c.ListFunctionRevisions(ctx, functionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionRevisionsResponse(rsp)
}

// CleanupImagesWithResponse request returning *CleanupImagesResponse
func (c *ClientWithResponses) CleanupImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CleanupImagesResponse, error) {
	rsp, err := c.CleanupImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCleanupImagesResponse(rsp)
}

// ListImagesWithResponse request returning *ListImagesResponse
func (c *ClientWithResponses) ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error) {
	rsp, err := c.ListImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImagesResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, resourceType, imageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// GetImageWithResponse request returning *GetImageResponse
func (c *ClientWithResponses) GetImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*GetImageResponse, error) {
	rsp, err := c.GetImage(ctx, resourceType, imageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageResponse(rsp)
}

// DeleteImageTagWithResponse request returning *DeleteImageTagResponse
func (c *ClientWithResponses) DeleteImageTagWithResponse(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*DeleteImageTagResponse, error) {
	rsp, err := c.DeleteImageTag(ctx, resourceType, imageName, tagName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageTagResponse(rsp)
}

// ListIntegrationConnectionsWithResponse request returning *ListIntegrationConnectionsResponse
func (c *ClientWithResponses) ListIntegrationConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionsResponse, error) {
	rsp, err := c.ListIntegrationConnections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConnectionsResponse(rsp)
}

// CreateIntegrationConnectionWithBodyWithResponse request with arbitrary body returning *CreateIntegrationConnectionResponse
func (c *ClientWithResponses) CreateIntegrationConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error) {
	rsp, err := c.CreateIntegrationConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateIntegrationConnectionWithResponse(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error) {
	rsp, err := c.CreateIntegrationConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationConnectionResponse(rsp)
}

// DeleteIntegrationConnectionWithResponse request returning *DeleteIntegrationConnectionResponse
func (c *ClientWithResponses) DeleteIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*DeleteIntegrationConnectionResponse, error) {
	rsp, err := c.DeleteIntegrationConnection(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIntegrationConnectionResponse(rsp)
}

// GetIntegrationConnectionWithResponse request returning *GetIntegrationConnectionResponse
func (c *ClientWithResponses) GetIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionResponse, error) {
	rsp, err := c.GetIntegrationConnection(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionResponse(rsp)
}

// UpdateIntegrationConnectionWithBodyWithResponse request with arbitrary body returning *UpdateIntegrationConnectionResponse
func (c *ClientWithResponses) UpdateIntegrationConnectionWithBodyWithResponse(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error) {
	rsp, err := c.UpdateIntegrationConnectionWithBody(ctx, connectionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateIntegrationConnectionWithResponse(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error) {
	rsp, err := c.UpdateIntegrationConnection(ctx, connectionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationConnectionResponse(rsp)
}

// GetIntegrationConnectionModelEndpointConfigurationsWithResponse request returning *GetIntegrationConnectionModelEndpointConfigurationsResponse
func (c *ClientWithResponses) GetIntegrationConnectionModelEndpointConfigurationsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error) {
	rsp, err := c.GetIntegrationConnectionModelEndpointConfigurations(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionModelEndpointConfigurationsResponse(rsp)
}

// ListIntegrationConnectionModelsWithResponse request returning *ListIntegrationConnectionModelsResponse
func (c *ClientWithResponses) ListIntegrationConnectionModelsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionModelsResponse, error) {
	rsp, err := c.ListIntegrationConnectionModels(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConnectionModelsResponse(rsp)
}

// GetIntegrationConnectionModelWithResponse request returning *GetIntegrationConnectionModelResponse
func (c *ClientWithResponses) GetIntegrationConnectionModelWithResponse(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelResponse, error) {
	rsp, err := c.GetIntegrationConnectionModel(ctx, connectionName, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionModelResponse(rsp)
}

// GetIntegrationWithResponse request returning *GetIntegrationResponse
func (c *ClientWithResponses) GetIntegrationWithResponse(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error) {
	rsp, err := c.GetIntegration(ctx, integrationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// CreateJobWithBodyWithResponse request with arbitrary body returning *CreateJobResponse
func (c *ClientWithResponses) CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

func (c *ClientWithResponses) CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

// DeleteJobWithResponse request returning *DeleteJobResponse
func (c *ClientWithResponses) DeleteJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error) {
	rsp, err := c.DeleteJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// UpdateJobWithBodyWithResponse request with arbitrary body returning *UpdateJobResponse
func (c *ClientWithResponses) UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobWithResponse(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

// ListJobExecutionsWithResponse request returning *ListJobExecutionsResponse
func (c *ClientWithResponses) ListJobExecutionsWithResponse(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*ListJobExecutionsResponse, error) {
	rsp, err := c.ListJobExecutions(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobExecutionsResponse(rsp)
}

// CreateJobExecutionWithBodyWithResponse request with arbitrary body returning *CreateJobExecutionResponse
func (c *ClientWithResponses) CreateJobExecutionWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error) {
	rsp, err := c.CreateJobExecutionWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobExecutionResponse(rsp)
}

func (c *ClientWithResponses) CreateJobExecutionWithResponse(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error) {
	rsp, err := c.CreateJobExecution(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobExecutionResponse(rsp)
}

// DeleteJobExecutionWithResponse request returning *DeleteJobExecutionResponse
func (c *ClientWithResponses) DeleteJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*DeleteJobExecutionResponse, error) {
	rsp, err := c.DeleteJobExecution(ctx, jobId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobExecutionResponse(rsp)
}

// GetJobExecutionWithResponse request returning *GetJobExecutionResponse
func (c *ClientWithResponses) GetJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*GetJobExecutionResponse, error) {
	rsp, err := c.GetJobExecution(ctx, jobId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobExecutionResponse(rsp)
}

// ListJobRevisionsWithResponse request returning *ListJobRevisionsResponse
func (c *ClientWithResponses) ListJobRevisionsWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*ListJobRevisionsResponse, error) {
	rsp, err := c.ListJobRevisions(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobRevisionsResponse(rsp)
}

// ListLocationsWithResponse request returning *ListLocationsResponse
func (c *ClientWithResponses) ListLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error) {
	rsp, err := c.ListLocations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLocationsResponse(rsp)
}

// ListMCPHubDefinitionsWithResponse request returning *ListMCPHubDefinitionsResponse
func (c *ClientWithResponses) ListMCPHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMCPHubDefinitionsResponse, error) {
	rsp, err := c.ListMCPHubDefinitions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMCPHubDefinitionsResponse(rsp)
}

// ListModelsWithResponse request returning *ListModelsResponse
func (c *ClientWithResponses) ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResponse, error) {
	rsp, err := c.ListModels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelsResponse(rsp)
}

// CreateModelWithBodyWithResponse request with arbitrary body returning *CreateModelResponse
func (c *ClientWithResponses) CreateModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResponse, error) {
	rsp, err := c.CreateModelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResponse(rsp)
}

func (c *ClientWithResponses) CreateModelWithResponse(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResponse, error) {
	rsp, err := c.CreateModel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResponse(rsp)
}

// DeleteModelWithResponse request returning *DeleteModelResponse
func (c *ClientWithResponses) DeleteModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*DeleteModelResponse, error) {
	rsp, err := c.DeleteModel(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModelResponse(rsp)
}

// GetModelWithResponse request returning *GetModelResponse
func (c *ClientWithResponses) GetModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*GetModelResponse, error) {
	rsp, err := c.GetModel(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelResponse(rsp)
}

// UpdateModelWithBodyWithResponse request with arbitrary body returning *UpdateModelResponse
func (c *ClientWithResponses) UpdateModelWithBodyWithResponse(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error) {
	rsp, err := c.UpdateModelWithBody(ctx, modelName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelResponse(rsp)
}

func (c *ClientWithResponses) UpdateModelWithResponse(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error) {
	rsp, err := c.UpdateModel(ctx, modelName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelResponse(rsp)
}

// ListModelRevisionsWithResponse request returning *ListModelRevisionsResponse
func (c *ClientWithResponses) ListModelRevisionsWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*ListModelRevisionsResponse, error) {
	rsp, err := c.ListModelRevisions(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelRevisionsResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListAllPendingInvitationsWithResponse request returning *ListAllPendingInvitationsResponse
func (c *ClientWithResponses) ListAllPendingInvitationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllPendingInvitationsResponse, error) {
	rsp, err := c.ListAllPendingInvitations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllPendingInvitationsResponse(rsp)
}

// ListPublicIpsWithResponse request returning *ListPublicIpsResponse
func (c *ClientWithResponses) ListPublicIpsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPublicIpsResponse, error) {
	rsp, err := c.ListPublicIps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPublicIpsResponse(rsp)
}

// ListSandboxHubDefinitionsWithResponse request returning *ListSandboxHubDefinitionsResponse
func (c *ClientWithResponses) ListSandboxHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxHubDefinitionsResponse, error) {
	rsp, err := c.ListSandboxHubDefinitions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxHubDefinitionsResponse(rsp)
}

// ListSandboxesWithResponse request returning *ListSandboxesResponse
func (c *ClientWithResponses) ListSandboxesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error) {
	rsp, err := c.ListSandboxes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxesResponse(rsp)
}

// CreateSandboxWithBodyWithResponse request with arbitrary body returning *CreateSandboxResponse
func (c *ClientWithResponses) CreateSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandboxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxWithResponse(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandbox(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

// DeleteSandboxWithResponse request returning *DeleteSandboxResponse
func (c *ClientWithResponses) DeleteSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error) {
	rsp, err := c.DeleteSandbox(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxResponse(rsp)
}

// GetSandboxWithResponse request returning *GetSandboxResponse
func (c *ClientWithResponses) GetSandboxWithResponse(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error) {
	rsp, err := c.GetSandbox(ctx, sandboxName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxResponse(rsp)
}

// UpdateSandboxWithBodyWithResponse request with arbitrary body returning *UpdateSandboxResponse
func (c *ClientWithResponses) UpdateSandboxWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error) {
	rsp, err := c.UpdateSandboxWithBody(ctx, sandboxName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxResponse(rsp)
}

func (c *ClientWithResponses) UpdateSandboxWithResponse(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error) {
	rsp, err := c.UpdateSandbox(ctx, sandboxName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxResponse(rsp)
}

// ListSandboxPreviewsWithResponse request returning *ListSandboxPreviewsResponse
func (c *ClientWithResponses) ListSandboxPreviewsWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewsResponse, error) {
	rsp, err := c.ListSandboxPreviews(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxPreviewsResponse(rsp)
}

// CreateSandboxPreviewWithBodyWithResponse request with arbitrary body returning *CreateSandboxPreviewResponse
func (c *ClientWithResponses) CreateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error) {
	rsp, err := c.CreateSandboxPreviewWithBody(ctx, sandboxName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error) {
	rsp, err := c.CreateSandboxPreview(ctx, sandboxName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewResponse(rsp)
}

// DeleteSandboxPreviewWithResponse request returning *DeleteSandboxPreviewResponse
func (c *ClientWithResponses) DeleteSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewResponse, error) {
	rsp, err := c.DeleteSandboxPreview(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxPreviewResponse(rsp)
}

// GetSandboxPreviewWithResponse request returning *GetSandboxPreviewResponse
func (c *ClientWithResponses) GetSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*GetSandboxPreviewResponse, error) {
	rsp, err := c.GetSandboxPreview(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxPreviewResponse(rsp)
}

// UpdateSandboxPreviewWithBodyWithResponse request with arbitrary body returning *UpdateSandboxPreviewResponse
func (c *ClientWithResponses) UpdateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error) {
	rsp, err := c.UpdateSandboxPreviewWithBody(ctx, sandboxName, previewName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxPreviewResponse(rsp)
}

func (c *ClientWithResponses) UpdateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error) {
	rsp, err := c.UpdateSandboxPreview(ctx, sandboxName, previewName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxPreviewResponse(rsp)
}

// ListSandboxPreviewTokensWithResponse request returning *ListSandboxPreviewTokensResponse
func (c *ClientWithResponses) ListSandboxPreviewTokensWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewTokensResponse, error) {
	rsp, err := c.ListSandboxPreviewTokens(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxPreviewTokensResponse(rsp)
}

// CreateSandboxPreviewTokenWithBodyWithResponse request with arbitrary body returning *CreateSandboxPreviewTokenResponse
func (c *ClientWithResponses) CreateSandboxPreviewTokenWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error) {
	rsp, err := c.CreateSandboxPreviewTokenWithBody(ctx, sandboxName, previewName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error) {
	rsp, err := c.CreateSandboxPreviewToken(ctx, sandboxName, previewName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewTokenResponse(rsp)
}

// DeleteSandboxPreviewTokenWithResponse request returning *DeleteSandboxPreviewTokenResponse
func (c *ClientWithResponses) DeleteSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewTokenResponse, error) {
	rsp, err := c.DeleteSandboxPreviewToken(ctx, sandboxName, previewName, tokenName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxPreviewTokenResponse(rsp)
}

// StartSandboxWithResponse request returning *StartSandboxResponse
func (c *ClientWithResponses) StartSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*StartSandboxResponse, error) {
	rsp, err := c.StartSandbox(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartSandboxResponse(rsp)
}

// StopSandboxWithResponse request returning *StopSandboxResponse
func (c *ClientWithResponses) StopSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*StopSandboxResponse, error) {
	rsp, err := c.StopSandbox(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopSandboxResponse(rsp)
}

// GetWorkspaceServiceAccountsWithResponse request returning *GetWorkspaceServiceAccountsResponse
func (c *ClientWithResponses) GetWorkspaceServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkspaceServiceAccountsResponse, error) {
	rsp, err := c.GetWorkspaceServiceAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceServiceAccountsResponse(rsp)
}

// CreateWorkspaceServiceAccountWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceServiceAccountResponse
func (c *ClientWithResponses) CreateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.CreateWorkspaceServiceAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceServiceAccountWithResponse(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.CreateWorkspaceServiceAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceServiceAccountResponse(rsp)
}

// DeleteWorkspaceServiceAccountWithResponse request returning *DeleteWorkspaceServiceAccountResponse
func (c *ClientWithResponses) DeleteWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceServiceAccountResponse, error) {
	rsp, err := c.DeleteWorkspaceServiceAccount(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceServiceAccountResponse(rsp)
}

// UpdateWorkspaceServiceAccountWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceServiceAccountResponse
func (c *ClientWithResponses) UpdateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.UpdateWorkspaceServiceAccountWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.UpdateWorkspaceServiceAccount(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceServiceAccountResponse(rsp)
}

// ListApiKeysForServiceAccountWithResponse request returning *ListApiKeysForServiceAccountResponse
func (c *ClientWithResponses) ListApiKeysForServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*ListApiKeysForServiceAccountResponse, error) {
	rsp, err := c.ListApiKeysForServiceAccount(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysForServiceAccountResponse(rsp)
}

// CreateApiKeyForServiceAccountWithBodyWithResponse request with arbitrary body returning *CreateApiKeyForServiceAccountResponse
func (c *ClientWithResponses) CreateApiKeyForServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error) {
	rsp, err := c.CreateApiKeyForServiceAccountWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyForServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error) {
	rsp, err := c.CreateApiKeyForServiceAccount(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyForServiceAccountResponse(rsp)
}

// DeleteApiKeyForServiceAccountWithResponse request returning *DeleteApiKeyForServiceAccountResponse
func (c *ClientWithResponses) DeleteApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyForServiceAccountResponse, error) {
	rsp, err := c.DeleteApiKeyForServiceAccount(ctx, clientId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeyForServiceAccountResponse(rsp)
}

// ListTemplatesWithResponse request returning *ListTemplatesResponse
func (c *ClientWithResponses) ListTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error) {
	rsp, err := c.ListTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTemplatesResponse(rsp)
}

// GetTemplateWithResponse request returning *GetTemplateResponse
func (c *ClientWithResponses) GetTemplateWithResponse(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error) {
	rsp, err := c.GetTemplate(ctx, templateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateResponse(rsp)
}

// ListWorkspaceUsersWithResponse request returning *ListWorkspaceUsersResponse
func (c *ClientWithResponses) ListWorkspaceUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error) {
	rsp, err := c.ListWorkspaceUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceUsersResponse(rsp)
}

// InviteWorkspaceUserWithBodyWithResponse request with arbitrary body returning *InviteWorkspaceUserResponse
func (c *ClientWithResponses) InviteWorkspaceUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error) {
	rsp, err := c.InviteWorkspaceUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteWorkspaceUserResponse(rsp)
}

func (c *ClientWithResponses) InviteWorkspaceUserWithResponse(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error) {
	rsp, err := c.InviteWorkspaceUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteWorkspaceUserResponse(rsp)
}

// RemoveWorkspaceUserWithResponse request returning *RemoveWorkspaceUserResponse
func (c *ClientWithResponses) RemoveWorkspaceUserWithResponse(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*RemoveWorkspaceUserResponse, error) {
	rsp, err := c.RemoveWorkspaceUser(ctx, subOrEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveWorkspaceUserResponse(rsp)
}

// UpdateWorkspaceUserRoleWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceUserRoleResponse
func (c *ClientWithResponses) UpdateWorkspaceUserRoleWithBodyWithResponse(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error) {
	rsp, err := c.UpdateWorkspaceUserRoleWithBody(ctx, subOrEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceUserRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceUserRoleWithResponse(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error) {
	rsp, err := c.UpdateWorkspaceUserRole(ctx, subOrEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceUserRoleResponse(rsp)
}

// ListVolumeTemplatesWithResponse request returning *ListVolumeTemplatesResponse
func (c *ClientWithResponses) ListVolumeTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumeTemplatesResponse, error) {
	rsp, err := c.ListVolumeTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVolumeTemplatesResponse(rsp)
}

// CreateVolumeTemplateWithBodyWithResponse request with arbitrary body returning *CreateVolumeTemplateResponse
func (c *ClientWithResponses) CreateVolumeTemplateWithBodyWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error) {
	rsp, err := c.CreateVolumeTemplateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeTemplateWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error) {
	rsp, err := c.CreateVolumeTemplate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeTemplateResponse(rsp)
}

// DeleteVolumeTemplateWithResponse request returning *DeleteVolumeTemplateResponse
func (c *ClientWithResponses) DeleteVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateResponse, error) {
	rsp, err := c.DeleteVolumeTemplate(ctx, volumeTemplateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeTemplateResponse(rsp)
}

// GetVolumeTemplateWithResponse request returning *GetVolumeTemplateResponse
func (c *ClientWithResponses) GetVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*GetVolumeTemplateResponse, error) {
	rsp, err := c.GetVolumeTemplate(ctx, volumeTemplateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVolumeTemplateResponse(rsp)
}

// UpdateVolumeTemplateWithBodyWithResponse request with arbitrary body returning *UpdateVolumeTemplateResponse
func (c *ClientWithResponses) UpdateVolumeTemplateWithBodyWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error) {
	rsp, err := c.UpdateVolumeTemplateWithBody(ctx, volumeTemplateName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error) {
	rsp, err := c.UpdateVolumeTemplate(ctx, volumeTemplateName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeTemplateResponse(rsp)
}

// DeleteVolumeTemplateVersionWithResponse request returning *DeleteVolumeTemplateVersionResponse
func (c *ClientWithResponses) DeleteVolumeTemplateVersionWithResponse(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateVersionResponse, error) {
	rsp, err := c.DeleteVolumeTemplateVersion(ctx, volumeTemplateName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeTemplateVersionResponse(rsp)
}

// ListVolumesWithResponse request returning *ListVolumesResponse
func (c *ClientWithResponses) ListVolumesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumesResponse, error) {
	rsp, err := c.ListVolumes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, volumeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// GetVolumeWithResponse request returning *GetVolumeResponse
func (c *ClientWithResponses) GetVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*GetVolumeResponse, error) {
	rsp, err := c.GetVolume(ctx, volumeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVolumeResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// CheckWorkspaceAvailabilityWithBodyWithResponse request with arbitrary body returning *CheckWorkspaceAvailabilityResponse
func (c *ClientWithResponses) CheckWorkspaceAvailabilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error) {
	rsp, err := c.CheckWorkspaceAvailabilityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckWorkspaceAvailabilityResponse(rsp)
}

func (c *ClientWithResponses) CheckWorkspaceAvailabilityWithResponse(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error) {
	rsp, err := c.CheckWorkspaceAvailability(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckWorkspaceAvailabilityResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// GetWorkspaceWithResponse request returning *GetWorkspaceResponse
func (c *ClientWithResponses) GetWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error) {
	rsp, err := c.GetWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceResponse(rsp)
}

// UpdateWorkspaceWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceResponse
func (c *ClientWithResponses) UpdateWorkspaceWithBodyWithResponse(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspaceWithBody(ctx, workspaceName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceWithResponse(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspace(ctx, workspaceName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

// DeclineWorkspaceInvitationWithResponse request returning *DeclineWorkspaceInvitationResponse
func (c *ClientWithResponses) DeclineWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeclineWorkspaceInvitationResponse, error) {
	rsp, err := c.DeclineWorkspaceInvitation(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineWorkspaceInvitationResponse(rsp)
}

// AcceptWorkspaceInvitationWithResponse request returning *AcceptWorkspaceInvitationResponse
func (c *ClientWithResponses) AcceptWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*AcceptWorkspaceInvitationResponse, error) {
	rsp, err := c.AcceptWorkspaceInvitation(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptWorkspaceInvitationResponse(rsp)
}

// LeaveWorkspaceWithResponse request returning *LeaveWorkspaceResponse
func (c *ClientWithResponses) LeaveWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error) {
	rsp, err := c.LeaveWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveWorkspaceResponse(rsp)
}

// ParseListAgentsResponse parses an HTTP response from a ListAgentsWithResponse call
func ParseListAgentsResponse(rsp *http.Response) (*ListAgentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAgentResponse parses an HTTP response from a CreateAgentWithResponse call
func ParseCreateAgentResponse(rsp *http.Response) (*CreateAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAgentResponse parses an HTTP response from a DeleteAgentWithResponse call
func ParseDeleteAgentResponse(rsp *http.Response) (*DeleteAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAgentResponse parses an HTTP response from a GetAgentWithResponse call
func ParseGetAgentResponse(rsp *http.Response) (*GetAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAgentResponse parses an HTTP response from a UpdateAgentWithResponse call
func ParseUpdateAgentResponse(rsp *http.Response) (*UpdateAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAgentRevisionsResponse parses an HTTP response from a ListAgentRevisionsWithResponse call
func ParseListAgentRevisionsResponse(rsp *http.Response) (*ListAgentRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigurationResponse parses an HTTP response from a GetConfigurationWithResponse call
func ParseGetConfigurationResponse(rsp *http.Response) (*GetConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Configuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomDomainsResponse parses an HTTP response from a ListCustomDomainsWithResponse call
func ParseListCustomDomainsResponse(rsp *http.Response) (*ListCustomDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomDomainResponse parses an HTTP response from a CreateCustomDomainWithResponse call
func ParseCreateCustomDomainResponse(rsp *http.Response) (*CreateCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomDomainResponse parses an HTTP response from a DeleteCustomDomainWithResponse call
func ParseDeleteCustomDomainResponse(rsp *http.Response) (*DeleteCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomDomainResponse parses an HTTP response from a GetCustomDomainWithResponse call
func ParseGetCustomDomainResponse(rsp *http.Response) (*GetCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomDomainResponse parses an HTTP response from a UpdateCustomDomainWithResponse call
func ParseUpdateCustomDomainResponse(rsp *http.Response) (*UpdateCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVerifyCustomDomainResponse parses an HTTP response from a VerifyCustomDomainWithResponse call
func ParseVerifyCustomDomainResponse(rsp *http.Response) (*VerifyCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFunctionsResponse parses an HTTP response from a ListFunctionsWithResponse call
func ParseListFunctionsResponse(rsp *http.Response) (*ListFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFunctionResponse parses an HTTP response from a CreateFunctionWithResponse call
func ParseCreateFunctionResponse(rsp *http.Response) (*CreateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFunctionResponse parses an HTTP response from a DeleteFunctionWithResponse call
func ParseDeleteFunctionResponse(rsp *http.Response) (*DeleteFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFunctionResponse parses an HTTP response from a GetFunctionWithResponse call
func ParseGetFunctionResponse(rsp *http.Response) (*GetFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFunctionResponse parses an HTTP response from a UpdateFunctionWithResponse call
func ParseUpdateFunctionResponse(rsp *http.Response) (*UpdateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFunctionRevisionsResponse parses an HTTP response from a ListFunctionRevisionsWithResponse call
func ParseListFunctionRevisionsResponse(rsp *http.Response) (*ListFunctionRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCleanupImagesResponse parses an HTTP response from a CleanupImagesWithResponse call
func ParseCleanupImagesResponse(rsp *http.Response) (*CleanupImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CleanupImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Number of images deleted
			Deleted *int `json:"deleted,omitempty"`

			// Message Result message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListImagesResponse parses an HTTP response from a ListImagesWithResponse call
func ParseListImagesResponse(rsp *http.Response) (*ListImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetImageResponse parses an HTTP response from a GetImageWithResponse call
func ParseGetImageResponse(rsp *http.Response) (*GetImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageTagResponse parses an HTTP response from a DeleteImageTagWithResponse call
func ParseDeleteImageTagResponse(rsp *http.Response) (*DeleteImageTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIntegrationConnectionsResponse parses an HTTP response from a ListIntegrationConnectionsWithResponse call
func ParseListIntegrationConnectionsResponse(rsp *http.Response) (*ListIntegrationConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIntegrationConnectionResponse parses an HTTP response from a CreateIntegrationConnectionWithResponse call
func ParseCreateIntegrationConnectionResponse(rsp *http.Response) (*CreateIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteIntegrationConnectionResponse parses an HTTP response from a DeleteIntegrationConnectionWithResponse call
func ParseDeleteIntegrationConnectionResponse(rsp *http.Response) (*DeleteIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConnectionResponse parses an HTTP response from a GetIntegrationConnectionWithResponse call
func ParseGetIntegrationConnectionResponse(rsp *http.Response) (*GetIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateIntegrationConnectionResponse parses an HTTP response from a UpdateIntegrationConnectionWithResponse call
func ParseUpdateIntegrationConnectionResponse(rsp *http.Response) (*UpdateIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConnectionModelEndpointConfigurationsResponse parses an HTTP response from a GetIntegrationConnectionModelEndpointConfigurationsWithResponse call
func ParseGetIntegrationConnectionModelEndpointConfigurationsResponse(rsp *http.Response) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionModelEndpointConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListIntegrationConnectionModelsResponse parses an HTTP response from a ListIntegrationConnectionModelsWithResponse call
func ParseListIntegrationConnectionModelsResponse(rsp *http.Response) (*ListIntegrationConnectionModelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConnectionModelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIntegrationConnectionModelResponse parses an HTTP response from a GetIntegrationConnectionModelWithResponse call
func ParseGetIntegrationConnectionModelResponse(rsp *http.Response) (*GetIntegrationConnectionModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIntegrationResponse parses an HTTP response from a GetIntegrationWithResponse call
func ParseGetIntegrationResponse(rsp *http.Response) (*GetIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJobResponse parses an HTTP response from a CreateJobWithResponse call
func ParseCreateJobResponse(rsp *http.Response) (*CreateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobResponse parses an HTTP response from a DeleteJobWithResponse call
func ParseDeleteJobResponse(rsp *http.Response) (*DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateJobResponse parses an HTTP response from a UpdateJobWithResponse call
func ParseUpdateJobResponse(rsp *http.Response) (*UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobExecutionsResponse parses an HTTP response from a ListJobExecutionsWithResponse call
func ParseListJobExecutionsResponse(rsp *http.Response) (*ListJobExecutionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobExecutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJobExecutionResponse parses an HTTP response from a CreateJobExecutionWithResponse call
func ParseCreateJobExecutionResponse(rsp *http.Response) (*CreateJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobExecutionResponse parses an HTTP response from a DeleteJobExecutionWithResponse call
func ParseDeleteJobExecutionResponse(rsp *http.Response) (*DeleteJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobExecutionResponse parses an HTTP response from a GetJobExecutionWithResponse call
func ParseGetJobExecutionResponse(rsp *http.Response) (*GetJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobRevisionsResponse parses an HTTP response from a ListJobRevisionsWithResponse call
func ParseListJobRevisionsResponse(rsp *http.Response) (*ListJobRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLocationsResponse parses an HTTP response from a ListLocationsWithResponse call
func ParseListLocationsResponse(rsp *http.Response) (*ListLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMCPHubDefinitionsResponse parses an HTTP response from a ListMCPHubDefinitionsWithResponse call
func ParseListMCPHubDefinitionsResponse(rsp *http.Response) (*ListMCPHubDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMCPHubDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MCPDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelsResponse parses an HTTP response from a ListModelsWithResponse call
func ParseListModelsResponse(rsp *http.Response) (*ListModelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateModelResponse parses an HTTP response from a CreateModelWithResponse call
func ParseCreateModelResponse(rsp *http.Response) (*CreateModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteModelResponse parses an HTTP response from a DeleteModelWithResponse call
func ParseDeleteModelResponse(rsp *http.Response) (*DeleteModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModelResponse parses an HTTP response from a GetModelWithResponse call
func ParseGetModelResponse(rsp *http.Response) (*GetModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateModelResponse parses an HTTP response from a UpdateModelWithResponse call
func ParseUpdateModelResponse(rsp *http.Response) (*UpdateModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelRevisionsResponse parses an HTTP response from a ListModelRevisionsWithResponse call
func ParseListModelRevisionsResponse(rsp *http.Response) (*ListModelRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllPendingInvitationsResponse parses an HTTP response from a ListAllPendingInvitationsWithResponse call
func ParseListAllPendingInvitationsResponse(rsp *http.Response) (*ListAllPendingInvitationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllPendingInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PendingInvitationRender
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPublicIpsResponse parses an HTTP response from a ListPublicIpsWithResponse call
func ParseListPublicIpsResponse(rsp *http.Response) (*ListPublicIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPublicIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicIps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxHubDefinitionsResponse parses an HTTP response from a ListSandboxHubDefinitionsWithResponse call
func ParseListSandboxHubDefinitionsResponse(rsp *http.Response) (*ListSandboxHubDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxHubDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SandboxDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxesResponse parses an HTTP response from a ListSandboxesWithResponse call
func ParseListSandboxesResponse(rsp *http.Response) (*ListSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxResponse parses an HTTP response from a CreateSandboxWithResponse call
func ParseCreateSandboxResponse(rsp *http.Response) (*CreateSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxResponse parses an HTTP response from a DeleteSandboxWithResponse call
func ParseDeleteSandboxResponse(rsp *http.Response) (*DeleteSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSandboxResponse parses an HTTP response from a GetSandboxWithResponse call
func ParseGetSandboxResponse(rsp *http.Response) (*GetSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSandboxResponse parses an HTTP response from a UpdateSandboxWithResponse call
func ParseUpdateSandboxResponse(rsp *http.Response) (*UpdateSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxPreviewsResponse parses an HTTP response from a ListSandboxPreviewsWithResponse call
func ParseListSandboxPreviewsResponse(rsp *http.Response) (*ListSandboxPreviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxPreviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxPreviewResponse parses an HTTP response from a CreateSandboxPreviewWithResponse call
func ParseCreateSandboxPreviewResponse(rsp *http.Response) (*CreateSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxPreviewResponse parses an HTTP response from a DeleteSandboxPreviewWithResponse call
func ParseDeleteSandboxPreviewResponse(rsp *http.Response) (*DeleteSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSandboxPreviewResponse parses an HTTP response from a GetSandboxPreviewWithResponse call
func ParseGetSandboxPreviewResponse(rsp *http.Response) (*GetSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSandboxPreviewResponse parses an HTTP response from a UpdateSandboxPreviewWithResponse call
func ParseUpdateSandboxPreviewResponse(rsp *http.Response) (*UpdateSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxPreviewTokensResponse parses an HTTP response from a ListSandboxPreviewTokensWithResponse call
func ParseListSandboxPreviewTokensResponse(rsp *http.Response) (*ListSandboxPreviewTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxPreviewTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PreviewToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxPreviewTokenResponse parses an HTTP response from a CreateSandboxPreviewTokenWithResponse call
func ParseCreateSandboxPreviewTokenResponse(rsp *http.Response) (*CreateSandboxPreviewTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxPreviewTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreviewToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxPreviewTokenResponse parses an HTTP response from a DeleteSandboxPreviewTokenWithResponse call
func ParseDeleteSandboxPreviewTokenResponse(rsp *http.Response) (*DeleteSandboxPreviewTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxPreviewTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Message Success message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartSandboxResponse parses an HTTP response from a StartSandboxWithResponse call
func ParseStartSandboxResponse(rsp *http.Response) (*StartSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStopSandboxResponse parses an HTTP response from a StopSandboxWithResponse call
func ParseStopSandboxResponse(rsp *http.Response) (*StopSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StopSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceServiceAccountsResponse parses an HTTP response from a GetWorkspaceServiceAccountsWithResponse call
func ParseGetWorkspaceServiceAccountsResponse(rsp *http.Response) (*GetWorkspaceServiceAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceServiceAccountResponse parses an HTTP response from a CreateWorkspaceServiceAccountWithResponse call
func ParseCreateWorkspaceServiceAccountResponse(rsp *http.Response) (*CreateWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// ClientSecret Service account client secret (only returned on creation)
			ClientSecret *string `json:"client_secret,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceServiceAccountResponse parses an HTTP response from a DeleteWorkspaceServiceAccountWithResponse call
func ParseDeleteWorkspaceServiceAccountResponse(rsp *http.Response) (*DeleteWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWorkspaceServiceAccountResponse parses an HTTP response from a UpdateWorkspaceServiceAccountWithResponse call
func ParseUpdateWorkspaceServiceAccountResponse(rsp *http.Response) (*UpdateWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListApiKeysForServiceAccountResponse parses an HTTP response from a ListApiKeysForServiceAccountWithResponse call
func ParseListApiKeysForServiceAccountResponse(rsp *http.Response) (*ListApiKeysForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApiKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyForServiceAccountResponse parses an HTTP response from a CreateApiKeyForServiceAccountWithResponse call
func ParseCreateApiKeyForServiceAccountResponse(rsp *http.Response) (*CreateApiKeyForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeyForServiceAccountResponse parses an HTTP response from a DeleteApiKeyForServiceAccountWithResponse call
func ParseDeleteApiKeyForServiceAccountResponse(rsp *http.Response) (*DeleteApiKeyForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeyForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTemplatesResponse parses an HTTP response from a ListTemplatesWithResponse call
func ParseListTemplatesResponse(rsp *http.Response) (*ListTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplateResponse parses an HTTP response from a GetTemplateWithResponse call
func ParseGetTemplateResponse(rsp *http.Response) (*GetTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspaceUsersResponse parses an HTTP response from a ListWorkspaceUsersWithResponse call
func ParseListWorkspaceUsersResponse(rsp *http.Response) (*ListWorkspaceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteWorkspaceUserResponse parses an HTTP response from a InviteWorkspaceUserWithResponse call
func ParseInviteWorkspaceUserResponse(rsp *http.Response) (*InviteWorkspaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteWorkspaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveWorkspaceUserResponse parses an HTTP response from a RemoveWorkspaceUserWithResponse call
func ParseRemoveWorkspaceUserResponse(rsp *http.Response) (*RemoveWorkspaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveWorkspaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateWorkspaceUserRoleResponse parses an HTTP response from a UpdateWorkspaceUserRoleWithResponse call
func ParseUpdateWorkspaceUserRoleResponse(rsp *http.Response) (*UpdateWorkspaceUserRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceUserRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspaceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVolumeTemplatesResponse parses an HTTP response from a ListVolumeTemplatesWithResponse call
func ParseListVolumeTemplatesResponse(rsp *http.Response) (*ListVolumeTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVolumeTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeTemplateResponse parses an HTTP response from a CreateVolumeTemplateWithResponse call
func ParseCreateVolumeTemplateResponse(rsp *http.Response) (*CreateVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeTemplateResponse parses an HTTP response from a DeleteVolumeTemplateWithResponse call
func ParseDeleteVolumeTemplateResponse(rsp *http.Response) (*DeleteVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVolumeTemplateResponse parses an HTTP response from a GetVolumeTemplateWithResponse call
func ParseGetVolumeTemplateResponse(rsp *http.Response) (*GetVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeTemplateResponse parses an HTTP response from a UpdateVolumeTemplateWithResponse call
func ParseUpdateVolumeTemplateResponse(rsp *http.Response) (*UpdateVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeTemplateVersionResponse parses an HTTP response from a DeleteVolumeTemplateVersionWithResponse call
func ParseDeleteVolumeTemplateVersionResponse(rsp *http.Response) (*DeleteVolumeTemplateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeTemplateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`

			// Template Volume template for creating pre-configured volumes
			Template *VolumeTemplate `json:"template,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVolumesResponse parses an HTTP response from a ListVolumesWithResponse call
func ParseListVolumesResponse(rsp *http.Response) (*ListVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVolumeResponse parses an HTTP response from a GetVolumeWithResponse call
func ParseGetVolumeResponse(rsp *http.Response) (*GetVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckWorkspaceAvailabilityResponse parses an HTTP response from a CheckWorkspaceAvailabilityWithResponse call
func ParseCheckWorkspaceAvailabilityResponse(rsp *http.Response) (*CheckWorkspaceAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckWorkspaceAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceResponse parses an HTTP response from a GetWorkspaceWithResponse call
func ParseGetWorkspaceResponse(rsp *http.Response) (*GetWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWorkspaceResponse parses an HTTP response from a UpdateWorkspaceWithResponse call
func ParseUpdateWorkspaceResponse(rsp *http.Response) (*UpdateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeclineWorkspaceInvitationResponse parses an HTTP response from a DeclineWorkspaceInvitationWithResponse call
func ParseDeclineWorkspaceInvitationResponse(rsp *http.Response) (*DeclineWorkspaceInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineWorkspaceInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAcceptWorkspaceInvitationResponse parses an HTTP response from a AcceptWorkspaceInvitationWithResponse call
func ParseAcceptWorkspaceInvitationResponse(rsp *http.Response) (*AcceptWorkspaceInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptWorkspaceInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitationAccept
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveWorkspaceResponse parses an HTTP response from a LeaveWorkspaceWithResponse call
func ParseLeaveWorkspaceResponse(rsp *http.Response) (*LeaveWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9/3LbONLgq6B0VzXJlWwlM7O7t676/vA4noxn7Y3PdjLf3WYqBZGQhJgiuCQoR+vK",
	"u1/hFwmSDRCUJdmZcW3VjiMCDaC70d1odDfuRxFbZiwlKS9GR/ejIlqQJZZ/Hs9JysUfMSminGacsnR0",
	"pH8ej7KcZSTnlMjGZGUg/M+czEZHo/8xqQFPNNTJCcvJqWr5dTxaEo5jzHFfrwvT7ut4VGQk6msvZ3gt",
	"GooOHPOycCwD6a/jEV9nZHQ0KnhO0/no69fqFzb9TCIuINVgj+5HOEnezUZH/+pfr57IfQthjdm0J/em",
	"/tcYFUucJMhqgMRIJScxmuVsifiCoCxny4x31zEe5SRjBeUsX/eh7apuKZaf0/mc5L0kvTHtvn79+vsY",
	"RnJGIjqjEZa/QpjN6D/IOhytN3RJfqYkiQuJWF/Td3cpya22TSLgauDWvDOKbskawif5ktGcFJ8oRLYy",
	"l2tEZcppgmRT9cMLmqKCRCyNi5cQVBo7J4FoPEacoZzwnJIVQZTXdD++PIPApXhJugD/iZcEzVhuerqW",
	"WJTTbuf3BclRUUqaIRqTlNMZJbmj/yf1YxvIte4vv3Y3XZeBzlk6P0joisRmwnIBOIpIUdB0jn5K8BeS",
	"QEx1wtIZnWuKdKfS/NwWZxFLOa2EYqen+TYeUU6WAWJP9xjVcgXnOZYbLWJlKigLjmQ+BQ8kOqyhYbKc",
	"rjAn50xtQ2C0S9UCJaYJWuIUz0mM7ihfoKnENBJYwpzloVO6bI4LTS0nc3hGV/pD4FCqeXeErzB3aJK4",
	"6dvhipgWWYLX/wR3V9UN6WZI7sLg3Vn3j1hMwlRSpU8hcDlBUit3mRunOF9fkRUt4K0hv6NcNzh7gxKa",
	"3goZJASHgdlZ1pIUBZ4DK5MzROYzqKNcU7kaOAeXtldTcGn78YjTpXPi8hvUBxRxug8s4HwkLHw0HCAB",
	"DEcAG60yR+CR2nq6IxJrgQlM9p38Ayeo2bBSOHrJbbC3pNcwEVNuimsQkyTF04QAivRUfkAsFztT/inm",
	"k5OClXlkkWnKWEKwFCCzBK9Yv/Hzs24mNHjKyVxN74SlKYkqNPkAnIG9zmkhV5SxhEYaT14Zq9uZfvZ+",
	"8gtM1a6F3PEoFwaM2hHe/rqZ2Hg4jafsC6Dy1Qe0bAi1CtXwllBabKDO7pHOEubGsln1HiCZc4I5+ZVN",
	"T7+QqBRgrsi/S1JwSMbJD0K2RbIXwugzmyJienYPW+bLGcTt5iM6e4NeML0rx+iOJgmaEjQnqdDgJEZ0",
	"hlLGxdlhRWMSBxum71P675IYgY7O3kAdP7MpNLtf2dTRgePiFjqnCeGF2AyJ7yjDOV4STnIlV8Q/k4Qk",
	"DVxVcrJDlLY8vGP5bZHhiEAz/c18BOcL0rwsOFu+YUsMHQ7UVxTLz2r2Yp+SOxSTLGHrpdhaH9ObBUFR",
	"o2lOspwU4ivCaIoLYj68IIfzwzEiX/AyS8hhxJYvEV9gXpG6LEj8MeUMFSRfEWi8Q3SKo0X1xXTU9rUQ",
	"lZgjLOx+NebRx/Rj+erVD5HucUBj+W9yqH84VJ/FNA9UF/XdTBZPo9ff/1C1tufeYfNQ/4CN96G+Aruv",
	"Oqn3UfbCmtWej6teCffGkmyV0m1wErTrEjwlSRHqgTlXrZ1yUmFITUET/OPIovHHEShkqn3o24WwxAbO",
	"jM2NVjFRD1kddlEDVo+BJGZ4RSKWx5At98/ji1PEcT4nvCKPjy4F/0ByccaOjwGlcY4LjlaygZoOwpyT",
	"ZabM1YLjZQZb2nOHnS1+V9KjwzeIFggXBYuoVBviNDjE9j4p87y2vqUoX9QyLCNpTNP5WC+GxGM0wzRx",
	"qCP+hVsYxnFMlXq7bFCi0605oQuciVnc/PcNyiUwyVuFUMArnJRE6RY9QRvHEA/Z30/znOWARhY/V+qS",
	"zpp0U6sN0zCnlUdJmnxrSPtXPidpPSp/ibbOUEJnJFpHCdFH+yV0PMQR7DE5lr/LIxi+JehuQaoxaIG0",
	"vxBaieuodLPOiCAEac8ZAiEp43G5ye9G6Hz3evHdGH33/Y/yP3+Lv3sZhl9lzwNLlwc6MdcFzuM7nBOE",
	"V5gm8jAhmaVWqR18wqJSDWWJSsR/fBmOO91dTkt1j7JyjOZZOWipBUyVInipQYdSjVbAAvu5TB3cVn15",
	"yjcNZpJ9lw2m3aD7hgbwnV85VFOM7buHFcnXiC4zlnOc1noLS7/+zHThDAkVrvyEOEXn5xcgJ2/jSqFG",
	"Zd+twtlSe6M2sypl96EMITu57cgmzM7U1PEP1PfiWBDLs2EaSxWv5K8gBhVA0R0u9PExPoSQ77UdJXTb",
	"ftRKWoF+IayGgufrSWWoTeprpZeHLvvljZQUD1iPAKLlDYnRiyUruNDYgvdwlLOiQDhJEMfzAp5E6lws",
	"uEizIvkVhmicRjewQrPcSpXGqIYAAZZZ/CCSSxRpIIcDbWsxQPW5b6pOdjbiqcnKBf2PY0TxpYl6mqLp",
	"mpPCGlV604hSGXgOSNRzWnDlFZgXLQXFF7SolxGkoORCbvA87O6gar2lDczxvHf7hrEyx3Ow9/aosRm/",
	"mhX2cCuI7NpD2h3S/tgxY6vDwVk6Yw85L1ijoBoEohIs6IiOM0YDjBQL8GnV5+t4tCA4DtCTVvdfdA8n",
	"p9hrcPk+WT7HKf2Py8Fvg2g2Dd1lNYB3Vn/wthLneBDA/1OSfH2petlRD+C9qr2SRsvhC2kFTfTLDsjh",
	"75+h1W5TD9lgMwaapcescTb3Liyq2gZdPT1gBx/Xu7ZxO1UZtLQhSDoLpIFCyHHvt/n1yHhUkCgnfEvS",
	"SwPrrDCYqOqK6ei+3iftwCVzOLRRalPaJXzaEgCQjX7UG6nb4Z4pi9dhXZFsCt2CzFOWkwsWa19pACjV",
	"RdI1sQULsNQl4QsWB8LVjaH79yHTC5lXwXOCl2CAFAhTtXdGFcmvN+yWpBvoRdVPTPJhAHo4vdk6bNlq",
	"Rm2uE+cUuiLxECCo6gThj4TuAA2scMRIcMZxMgiS6jHUXDu1zSCX8BpIRb94qw0v/8x+qe2rLQhVY635",
	"x2xYPMG2VdeqXWGO809lnkABXPIiN29AQKoHen91PtgtAAPsu0KHroxhSPBFcDpgLo5LIT8pbFtxOyzw",
	"bwERaaPVP/hVIx43wC5dd3gAQnAN1oFVWvwEsMxvC8IXJNcBMRWIBS50ZKV2/hWgbQJT6qrpSOk7aXgB",
	"sLsUjjEFN4DVEWR3iC9+ZVMwSuFJ+51/ZdM+l/OvbDrI22yHqsDQ3PEoocu0x9hgyVVfe+3FoI6yQwNr",
	"Q7qWhSdQxXikKjQh1TDwTGmPdYOL27DjJIhRP/XsG/HWMSspC06A668T9cEhWcRiEuJwCp2ojxIdvotp",
	"j+dMhlL1AoiJcw5vSMgMVGA/CMC6VPWCoD3hWI44KZhgLtlZcJw7FnotPvmn6PHfndfOOT+MoHCN0KCp",
	"zr7u4V6/p8AEhNFiCeQ/lMupMCBmddyY2aKQ2/lxdrmKRWYlhxGhP6I6nwS9iHDGy5zECHNrXpG9bV4C",
	"a+ylhpGuXnJwzGnBaVRAYeYRScCI3JoSVSMPKWaYJmVOfGBUEIUHhsqe8U5FN/EBKdNUMLIPiGriAVKU",
	"MrjOB0Q3mZVeBoWPcTfiZ5RWsFwAQqhfBpEfjqjvcHoPJDFPyPGnbHMoTgEXt8hqsOEOPDEQRrBnZrBh",
	"I4A+xLgR/bvG3aDe2lTpI3Fz+QH0qdHtDkm+IriAoNV6MFcthmSQVLP0Z5HAI9ed3SMXZEVyyte+3lUb",
	"R+ybd96qQXB4T90xPJPEyYQhlHUbhU/CunNcf4qZO+2kaEHiMnFYSuajf9jHtrVCyBxiNEkS+y2nJf5y",
	"RRx5iBf4C12WS0ur5MTkJQKKyWW/SHIZAyYu29ctgxYdpJ3Usn0qamuxVT2BtXcLkqu0o8/iXL5gZRKj",
	"KTFX/jqErywO7nBx8HqMSHmQsPTg9cudxVFJ/0BfCJXJ2rwiRcbSAtiCpoWJwaAJ5SrmtEpecubW+nIg",
	"dUiCyUWFz53ONCGVrRMAY+aKgvzFBD/qFlaMCU3bYB8YBFlBgjO2A5bRw30BEFxupOtG0LYbArRpL04u",
	"35AZTSv7YqN0ifahgpO541r/pPpm5otzTmdYZh167rkitqTp/FPBQM98ExKiBVLtkWwPuUVDSzsAsxzm",
	"n38DhOz5gJGUkzzLKbSRgXVazaFlErHJHBezp9U397xqRpmxHDiu/8zyZUjvBY1jEkY53RRajfp0LS/I",
	"IXkgP+sLdB9/9d9s0wjksyiMIegStJBlTFpQ/9BQhgBYCUvnb3zMfs7SeaNySQBQT+2KgN48x2mRsRwy",
	"P8wnWT8Fc2opKwH24uRyjCKcCr38cXRHpgWLbgn/OEIsRx9HC86zA3WJ/XEUfCXx/uq8f9qAeq4Fp+iO",
	"UzG7uuyH+Mcv5RTaDU81PU0GT/TeHW43HU2N6RorSzDAspeJkgcuau4+f+3Ck7HWWvnmt5caADSEQBq0",
	"lec0wolO46+TUoUmxCqc5Elfmcll9V2aKYYZcm1Wg93oFAFQX02hzzK3d2K3FIP4iGbyqxRvlyQvaMFx",
	"KssdgDHLP63hiN6ykHfuMoWYRjI1WJjX6G7BqtMLXE6hcxDeZAjdtWcIiDKXKrHwLF1Rjh9kgW4uEckS",
	"08RRS0l9AzX0ijqwZYowgWcAlgDy5/jkHMkvOxdbGt+IVggXJ6V6jBASHUcRyQDVDcDGqul4GxhvIMJH",
	"7QotgSx3RdIYulDtx9X2+OgYjBqrxo0dfskGF3qLj8CLPqv6P5w3NxjeopQF7A3hmPbbFx2Yv7UBDCH/",
	"mXs/609out4OyWd4SZP1J9gakl1VC6dNNKcrkvr6ywZun6uvctyGYrtNT7esGlYRphZxm9WE6RWRIYv7",
	"DeBM5zR1E5BTPFfVZcUyhfFd2ZLG4xgRPT8pp6/vulI0A0FreBoCjBG7dJE7rlyluwcHj7uy469KWfwJ",
	"iyNgynOWFGjB7hC2kpoRLdASxyqLSdZNMd5Z4/wSdgjPqYqHf7m3nAy1JncShvp+7vQlahRaLryQNPVW",
	"rx4K9PUOv8xqrsbJEVUDWaNCDpSozEtVCCfHmfi9SKjKcDwf6LRtIdXJahf4iwwZd060ahA40TbYNrXm",
	"OU7LBMN3lm+tj6Bqz0rQKBA/Qzc6rORgj3fqdzBUQiBMQny3Ivk7B4ArqBUYNMFJBjmnSTY4NiIwFkIR",
	"4Mqb79tto6hrUn/NgWWMpACRh+RxlTY/RoRHYLpmF24RMvgw3mosbdB2aPR0bgn4XlJLBP9d5PDqe4kt",
	"KMI3tPI42Hu3v2+9J1v54Btgr3hYbphX6IqPlT+zksAs1zdaoWIY8qQeI+lGlZV47VN5iEJppyxLXy3k",
	"ncsZZxFLYAjmax8UVW8JhqFrMcmlgGB65EMO3RNcEwlMxsx3ERS4yXKwWt2lqpkGpUao6m1shjC6cpEj",
	"1C7R0AabJ6qbxz5pwf0m/dOu3BRFAFcvwwH/dORL6IoRfd1hJXRlF5zYg5unRUY3pR0KIIhZowGlFKes",
	"TGNVGZgWppShp3Q7LA2sIlQyKsfcCpnSiDRFZ9fv0P/+66vX4tsSc3SAvn/1/Y8Hr78/+OH1zfc/HP3l",
	"70d/+fv/A4UZKEYvbcnTnrZlzWQ5mdEv7+GUL/HJldyVldOERv6sn2p9BdLNIU0THN5igTOFW8a6IkeB",
	"coJjliZrmMllFdSHp+bdLFhBTFJeVdGyIDJmGicJ0iPJem9rVlZ1OA/RjZ4nkeYJTpK1ONvKMFwmIcjC",
	"+SVfsNwkoKlxDqFtkOugmb0sSQ0lL6Y3WNPJu6trAx9cC+eQIqZLIqAkdNXdL1X5x9eLjyPx3+9/1H/8",
	"Lf44enmIjmec6GItJhZs3IBQFSMtOVtiTiM5eZ3ncbjJDaxTNnj0lSMTWP6sFfxlBfZBGleC3FDtyr69",
	"urc5gks0N1sFWnUSHc6bVgX4n38y5dlDCFg/il+bfIVuwARzna/kl+4qf1tsf90aDORRejEg86mqM6Rn",
	"BOSWu3dLKIaa70X0PlPRqv7kDDuEGffc79gCZyjV5FnWLf80NPBLadWJLy6PZqsfT2ice/y7Sm0j0RLh",
	"OM5JUTRL2fRHJGWrvwYP8teNBvEhcuMCARUlIOhXXpOlm1ifJOyOxE4Tp+9k4IlqDYbgiGcN7E/TGXur",
	"irv7bLXeEBznzgsE4MoKnw/bZr5E+St3cjx3yPkqM9wl6beWUQ6/quB82qRZkQisxrsicDXeFakeaUEU",
	"LBqinnrpfeLF2/uS5BEcrd0CkumGsAOXRrfra1KIljeQNXktW6BCNUE3N+eNJMdX6L/M8x3xS9jpm+PZ",
	"DDru3KgPZn6N9CGvj8eQyG0yVUR05s+46HdWaBWgAeh2kH52EbENQrcDQbgTcGo+1NE8mHtSeH5aB0CY",
	"rkOzo6uucHK0NBxZWRwHItG092EzLNK9ekIFjjEV/OTcF/qDBKVZT79b1IXq57/6GRbQywi8tGNfZXZ5",
	"MZ87vB84n5eypLOYaYaLwszYuhg1j8L0xdIvcRrDo+iP8jW7Mm3B74PrFaYKOlTZrTFAB8NRVsLATi7f",
	"AyCERIpYTooxYmmybpue2jI1dRQgIWVKFMGnGVPmCNnhzvLa6BCdiQ1eqCLks096rE8G3hhReXUtX8cy",
	"UISy7XSUNlOnX8q4fC7kEM4bWLm8ZukKrXBOBQ4K41GgbdIeousq4wmjRJuU/yinJE8JJwU6TVcfsKpm",
	"3lOTbCMfXpOAm7vx5h7rSoxff69eOQC4rzeWX4B6w6JbkuuSrD5etrJn8ZcTlkbqtYUbuHyBAL3sZPNF",
	"VTeVMicFSdoo+NLlZF/CIDyMThr0Lqc5wHWEEweCljTtgM8SGmEI/iE6UfdgrxDL0Wv5HOfdgkYLtTPa",
	"PFIgnNzhdVFl89MUYY4SggXnpvXZ8yVcJHdJlqDZKuctvzlY8+InBzye0wi+i7vR11aoeuZHygzZo0Au",
	"2tHUh1qAcm7UwgPAQeSy4nBSzhs3gCync5oqMSfQ/Es5n9N0/jOO4JLZ/uJRNxKiVSLMlqIu33zQnVxR",
	"ZQSX2WXOps4C4DimKSkKlIlGTdlnyTwJonUasRyuziTaBalyaGEm0iazy0Z2pscIwFWKTBf0WOoHNF2j",
	"i5PL4mijFBnYjbwg0tr3rgYdoB9eLcfo+x8XY/S3IY+MLOpS7JrTgIFegCq1qy4DH9e4dl3pX9AoZ+jD",
	"hZyDkS7yNQVhJOpSHQ9Pokhwwd8XntRz6cwTODAvw9zhQtH3heDfA2HdjKv3X6dr1XZdcLJ8CVdu2E3Q",
	"m0ZkX96GiZTwPPAJct7NeZ19r7SeuWtQ9wzy6eb6Cb2UJmhJcCrMJdn0wLQKra+jJ9pMi4XXEtcZYHJm",
	"8VLsBs5yot/g1VVPHpIfK8doxcNtmCBrTXcHKbL2RB+eI1vPdcMs2eZie/Jke/JTm7A8Gar9eaP+dYVk",
	"jnaZb6t5n14yuqymC2UxOWfoMZwelks6zDKA36m4wfMijDx9l5e+3h5Rc26e/IJ8++Y1sO7R2egFzzth",
	"pPkYGShy6nJpzSe+BhTb77x5FnS3YCuObdT3SGw0BmisGu1DoicM1j0FQrL4S2+BkBVLymX/9ckH2eyY",
	"cxwt1HteUMBPpVv7UhK7zzT7H/Ct40KwfNhfveAmNByeK7eFjGTQCadrVspgRnWI1Mcc1UU+O6VY+F+3",
	"ZP17h1PrGvrtBKQm47fL41vC1/H8XGNBajqBu1OcI5xmoqm3ol5QkWcOlWdrenRDDRyVs34plxJpOJZu",
	"KvMIIZ6K84NkOVnHqLIotmbcBXlZLbvNPwkYhSwLxiDLst1hkGWPj0D/HCD83ZBlloBly3TpZ24adPKq",
	"yAyXCf8px2m0gOw3+RlN5fcqZqCG5g93CjAHvbDYXZowHMsqQL60JdOwmEQJS4nl+rcuF4FqlCy/LXqB",
	"y1ZAWW0QJGzZCd2vvfBmvd8VSLaFrLuIpW9wfjsEjrCcYpzftiLMh9Ti8FGiWAA3Zte/HJu+xnHsqrzW",
	"i2TRKBjJnGU0giw08TuwnPDwiT7LzYejynnehfCh8qt7JucNnNbtDaAwy6nTq0882HR8WDyMjyGG1q3x",
	"wepna1/vDHNA6F1ivghibIctYkdtmf7CNnLaJCDt6lB5OFpzWE2Iga+8VU8fWo/Zbe/NwwZ0DSJQ0ak6",
	"eFBggPzQE4HRuXoMqLnXtIOlU0FGLkBXfpLSLDfRDWqr65m90Kr2CPG8tKs4234Bx20rjSvBoRGwkdNU",
	"d65SiRacZ2K60tmLi3UaDaJCzwkhjCS45AvpM5Wf3Y9xNts1nuT04ATe4PKixdrkHgDijLJ23Q5YlQk7",
	"IOyAGV2h1HGJor+2II1RlLNUnLZzHUbzv8z/4Owo5yWh/NTyC+ixxBCf5QMZYVoIoHv4AwfO3pvP2jVG",
	"4eRGebNdFkQdSKW7fuDqIbNBHb8BvS9/r+WdDC1Qwlo9oy8PyE+62JJagu21J4FdZFPP8UcjR32WhdxK",
	"TmJVGU1jAGJ0ki9p6lQ61RVApWyUB0WqmiXOb8UILEcGTPARq+1hca4HV03cvrjukVXYx5egsLqQBZSk",
	"uNLRGBFLOaaO13QCDCI1T870VB0FuON3abLuMW4UJFogOX8SI6wygw6aqUFeQ6frurJrRwxxerl3Jhyf",
	"bxjQ9oahA0SXy5JL9e3XXDSd5bjgeRnxMidnLtWdcpLrN2at5rVMoLFQazNK8vrJY4XYDcrD1v5HTZsH",
	"uh/h14avrZeGDQ84Hffc6ZvQ+K8OH9L5VwUAqnl+HC3XpsHRa3M7bf0m/q/gH0cvh2zja+6bkBRy6AAZ",
	"NtDRclXh95YBI/mPxDfMl5NSU1V6SXUfsQnNOrVoOFquD/SfKsdKRjuIX+UfAxd6E4x8wXvqnZF0jrKc",
	"HBjmJzEyTuh91Udpzn0D3VN1NTpoJZQuWHzEXGuYFvUmHHpGbw79QcELM42ABfcSzF93QR82rsH9a7x6",
	"xZB9PNgD0JzvJlzr36Y1JsB9meCCayK8zxKG4z6Lgc3Uo+aaE1Ape8GlTYXMMRQGcpplAN5ENUPXP1Qg",
	"4dDoMP9wC5/ohRboY6lx12NE8pzl8CWSGt7hhGs/M+PdCSGREfBG6CWjQRLPcXSrQvViuqJxiZN6TgIZ",
	"poOwg6DbzGkZ3UJ+mesfkPqkIgiMrhSSWQ9NCxWWEbvSgkjq2FK2SmxPsHqHf8OL7TaGhtgFx79d69y0",
	"wesNZEsN6sXJ1enxzembMbo6PX7zf8fo5+Oz89M38KsHekFwmIdhHEWlxnynJGHpXJzhPGwOWWKNPdhl",
	"bB9mt5w22qh+t+eqGboaK4SgeimmZCucR7SlOnyQo+u45EyHXZMYlSn9d2nVoHPMp64y7ZpK4iyPvFkx",
	"QPdeq3ve5ZSbnFAQQp0NElSj1GSPeHZlPbg+UNf6QVP005Smsf3v2sIb13hu/NqrWdRYroei1O/KtNRB",
	"6WZyMueiICo6VcLXn14GlS75zVeLtoM2D7LqTJhWUTZPfkDd22o1bPO/LyAndg24LOTpvrN9Scb78sRl",
	"jcgFLpBp3qzlaBWqhTPI4WKlzam5y5bKD59WJBcn2oCZflcoWHLGU0JSVPWFZuetitqa4wPqo7Yg+Sul",
	"whVxWyBcxXHBMqutvrWHIITL1MVUmVO+vhZyRPHOTwTnJD8ulYdpKv/1s0yaGR2Nfv3tZqTc1EuJb/m1",
	"HmvBeSZ2ocpLlveolIs1m+vDE1WBE10mOBWrNNr0aPTq8NXhaxnpn5EUZ3R0NPrh8NXhDyPlmpdTm0gv",
	"rN510myroh+EppIntOO59gdW5VFEu+9fvTKvEGmPHM5kdoPoO/msZZKSpsFeJTkUcGzrlHKxnnaswzVs",
	"9EvFbiP+XyO11KOEFnz0uxBrRblcyoxQdRDFSYKwWasKQzSdRr/LOMYCwJB8eI0ca2e2LorzE4vXg7AT",
	"gJSvurqPqlbB85J8fSBJAgfdGuaVUmzjXiFQYR5Na5nRJsDXseHWyb38r7CDvqoNnBB1Vm2SRj5YbJHm",
	"G0KVXlILVWpB/agaw5v5LeEGGfKNfcLlbc2/Ogb7gt3pC3MVi1egFypuXlgOwkigopl8rX9kTLlRsWB3",
	"n/TDPkaiYSvwo3ZE//6NEUMgs0WJt4SHkMGL5kb8tLkMEx/kxWmF14rXR+39DyC5Uk2/j0e6VGyTB97L",
	"G/9ncRVAdhUc0aa8QuCm4mpiXOwBKveqavrIjLR7vd+pEPHYJgDKLeSDtO2Es7hE7knrImtne6AVLNPF",
	"2Al4oa/tx0zajz34a1ZK8OOx2dZCY+uDRqesRalKUfr3xolV03I/Vqk94q44s7H+HsTaZTsbiG3gsM9k",
	"baxqN6qgibj9aoTu2NsmktecbRDJQ6MO70/u1R+B1m2LisF6oj0/QF/U89irwnhconoN71Ciuu3vZ3Jt",
	"l1wO0zycUB4j+YnS6llMD2MRrxm/HTE9kX5TSRBY436Q3583/z4oq3A9iLLmKRG/4flz1WofRqcZbVcG",
	"Z7Vmv7E5sxZtUFj/1mdjVovYjeCqcbRfodUcd5u08NqUsxqbECkanDy5N38GGpINUn1zePOabaYZ4K5p",
	"srLLarNw84d1nO6ONg4bLZgqwXrS2h+AirT3wxZdqc8ibiA7eO2xQKbwiTrQxdqOjeBlnha1k0/X/GyP",
	"fjgae+yAjfyzu+PRP46XVgZbe+ySikyQk7bNJrJcT9HUf+342URWkhPmTpnK6l2qU+ctzkP0Lk3WKCdL",
	"thKfVSv5OhzOiSz+qWNtkjWaEprOq2JvOF3ry+X65bpibHJSZCXUHH1m06LLcydC+pfZmVrIAwndjlSW",
	"r4D4ksP1Ik1LuK6io+bDFSnKhJtaD0EBFFthIDVnh1Gg0dkktcVA+gfLHoCFR12BVTCOg2PQPGdlpljA",
	"Sq6X2RZiQFjCbIfUQXtaDrWrjazp4NzIbtzXO3dybz898nVyL38GjFrHpk518VenSFctFR52qFA1okMR",
	"Ox79qAZvNlZrEYyrmvzoaiJk0YyVafygvaIN6AYGN9kqvUR4S/hTo0AQ2hy2bQDCvBZD4z0dYzpQjSDA",
	"bsibj5CG2w1jn63iGbDahMOslKBtPRHYmtxzPA/f5VVGjpCqKo3VMJ13x9/g+dPf9GJJVOqWsiA9+57l",
	"EgM72P5couqZk/tHEwTgTJtM8KiauTfYPXWJlmISsTQlHc9liLli9UQ2yK7JCxsodZcTaw57MVigoXdm",
	"wFio8ZgxNgKjBj6q7WI1aXhNWxEaOhbSgmKqyFsQgCOC7AejZjd+CQcZ9uuk8Exiy7T3+mXtmkpOkvs2",
	"7+S+/scgy9aq12RxzHTd+CJTuXAa2028prCTjZ4uGTsqK4QkAVbrlhEszNxvGbvStg1DbbBHzOoZ2QgB",
	"tGZzl2zoxG3Vl9PhnNuntYL8LJMfwG6aODBltiRqJ+ZNgpNmWOIwe6p6Kwh8S0o9PRQsDeQb6qfwtIaE",
	"Dex0N0EMtAeDqyWB7G2oXj5xUGJb3KJ80wO5Q3UCLDlr+gMM7Qs1hz87K7Rt7w4vbJnok3v537P4awD5",
	"FTN6KS5Uy9mbgWLhiVB93K2UJdYra2wAI2nEfaMyZluC5d76V2Xme/nIngVN1UNr3vvJJu+MNjPDHI6S",
	"5uSfTJyZvd4nfuwXHPGZTYeqD9El0DHzq4C+DzfMr2y6K6eLWK4b65/VCg2G5T/7HCoCoZ/Z1OU3+VXW",
	"s9yFRS6xtF/7uxpyS4Twej50JdAmLQyXT+4/s6nWlv0O/M9s2ndHZ+j0jWDO61MHMdd74+xF0lvCFYb+",
	"sDFqygLaJo0c93cO6gQrU13Xt6tE5Y7YquPCzxOq1bOA87AAHI+mBRzLdY30MFE3qd56HexAqDpqn4GX",
	"rFrVn9ajPQ5zjj1xQ8KKQBnJUWbdvbXESkKXlDfkia6dODr6/pV8upYuy+Xo6PWrV/K1Vf0vqBRe9yEB",
	"+RzbrCDcMXj1ERjdHu4VMNzve7KxKgpvbmw5LpWnOEZaIog2fwGjTUz9XPkirq4V9WDzzeL1TQy5lNzV",
	"EEI2S2XknVoPMT+SKN9J+lZnfVeGrnuXzBa/Pmn+7LNqm492Bwv9yX31d4/he81Z1ngcPISTKzP4sTm5",
	"I23PqkcybMQBY1n4eTIehF3yLRiqUxPditPZOo/3nT98PN5/NTqIcdXR5Jlrn7l2I8tBH8kGCeXNs0BC",
	"LO+Ncj+2bUr8UfI9+i1GKNHDInzCoo1ubat+CK8wTeSDAzI0X5VDhal/Xg22DxqY0cxDnLuiQYUKNyES",
	"a+GGCPVvihLLKJssVFlNZx71xcnlL+W0frt9P4i8OLm0novfVeZSlC3KaYVChZIH3BiHOf2r++A9YFF5",
	"4B4n76tzqat/CDk1OkIwVANzs7qL05nls9zfSWyrjlJNFu+Raakx2KFMvQP09fmAmH5179pzGqpp9w3h",
	"0muaO3E5Dgs68Fnh3yS2HE56D56CTTIDwxWzsPU4wz4aqXbPAimALQId9wNF0wMODj2krVT1RoeHXXDq",
	"nydlXJEGOkY02CFjCY2qVwiCrTXTLdBeuzSj7IMCcrD1rvBuVu7GfFYv1qC8+inEcJON1y7LTa9uN5LS",
	"oG6/otIedYsE8ppvmUEjQCJ7X0zuVcsBRpzq0GfFWXT8ttDqteR8aO015voQ95bwbxZrDovOj69gVVmB",
	"AXRlzb9bNOt8ckq1eJZToazhLQ/UK6dyNqMJmdTv7AxW5SSN1ft3FYRArX6cJJeq85k1+l5UfHvYK5LG",
	"0GPZQy4JgAuAlEHo6Q+mrZp6rAQArh1GW/+qCV1OExqdZYPJK/shmhWqMg9NkXpH59BhqlXj7HInVYNs",
	"q8x9vKQpjOdq/fYmMuMb+ggM68pEvd7ca9XuETy6euTde3U1Kjqe3ap400AmvDb9AiVL1X6faN0xMn1H",
	"Bnu99aMB8on6oCOD7u86M1xX78DvQhlX6NuvNm4Mu00qec8NNSo7dBqPvhzgJf4PSw9wRueYkzu8PrCz",
	"TI7uR8CCenoVZtep97LN1Xe9Fyf3+s8BZxS9jL5Dis043xoZvecUDxn7zym9yHtLeD3AHzY2fWeUc5yV",
	"/DQLPivVYIDDkrWTtusE7+UZ1fJZUg9hFO/JyccuHvk5yXKyouRuiIljiHupuw6zckyv/Zyc1GC7t3WA",
	"TRxm6jz6PvbXKdLs4be0LqtGO/F+GBru2f1hD7tvgwvVKN1sO0/u9V8bWEl67EBrySb+t0aKEKPJS4pg",
	"46kXp7UR9S0j1G/L9KDycWWht+JfPXHI5VzvtC37nIO5p2FOPYvjbVtVWxbHE85uicdz/ZbwAqk2OvKg",
	"NY8QA+tGjfGn3FZ7Mywlkh/FuhRi1WKRQAnb41iTAENZDjIBFT7+pDy3M1mruexRBK419u6lrjaCazbc",
	"qfyd3Mv/DrCQPftjmLX8Z90n3hENUqByyoZQe9UEzbc0nK9gXKudsP9nMAIPMtvbTgXHucQbaLdei69B",
	"HmPZMtBnvA8nyO58gfZCB13P/x3Ar0YrLRBOcoLjNcrLNDUsFuZ8UK+BtzlFznNjH2LBWebhCpYFMgXL",
	"/hw8Ua9ziyyRMr5FdmBZPzeQfEUj8glHEStTPvSSXHdHpnuAF/kt4b+Zr9eq+7EZfFtGf1PmRwklKf9E",
	"gReUrpvzR6qpqpDYYqfxSPn84k/YZX5TliJOl6TgeJlBEBp9+uZifwVgqc3RB8Q8bdLurUw3eC3nuOAm",
	"Lt+znK5C3M0JquIl5xGqfsipzY8W33c4PeQs1YIXwN6qr4PDH+DNaT8J9jQYqXGY+ZcC9TtoKG33zLOj",
	"Da7gqFvqYFj6KvwFU6/OCTFJYsRSZIIfXj4Lkw2EydaFh/e06hQhfgkCqdDJvWKM4KKKrRFdh0+3TPGa",
	"WScWx0PlhfVcH/FM9qyf/1hbSp9YN9xSvfcpvdtFNX1q2+UPpva/VRX/LCOehIzQV3O7UbsTnNFPt2Q9",
	"9DR7fHmGRDftHO4VNDKhJKP/IOviZ5YDpv6uL7DU4Ls6eGEJ3R0B3kDXUBn/CDK457CXmgWFkl/1VDSA",
	"6b8NmU++ZDQnxScKiJtT8U3JrIzklMVy6uKEqpcSLnSkN6639z4EfwjDb5XB73LqPBfYLLETETW5V7MI",
	"PS0M5lLV08elu3i+w4dabR9ujNpHkB6dK6/jjMrJ0xgexRB1+NuhnCyzREikgcqr6gfrqZsK7D4Ukxlt",
	"V6qpWqxbO3FrwYaZ6t/UBq3+Pbk3f4Y9+YIr8N5gwAoNA65CeN0HukO1pvlkLkNqam+buq6YmXrA8WhS",
	"FhKrg3aL7BMY816dJN/LgfaxfxpD7sGx7txFFZ6qxtZ2qgF4nOky4Vke3AUsxFkT5WL/kCWmQNk31bOJ",
	"iq1ZVWJI8Yd6rml0pH/Z6IR0Krqa/WtWKdOhu3t0p9E+7RTzB1ecpekKJzRWFEIaV67M85qmwQ+bWyyo",
	"8dViQsUDFVJ7ubCSB5P7opy+yyVpvJbVFVmyVc2f8lX6Joe+YDnKyYrdmvd8DXoRtUi+wOr6FkcRyTiJ",
	"9XtdVds14S+7PK5Gb/O4P/+unCKWa5JYTOe4PK+wsP133cRsUc1P8vpDLCcW87OWrpAXOxmnWr4sCCaA",
	"bsJAauw2AykEW7S9swdTM7Pm6pFuPq+koEHOEqnENSP165aWn1Jg84ol5OnQfxuCVmCli7ebBZFPREic",
	"cYZwUdB5apSDXo3/rlEC/v2Rz6MtPd2VtnKLyFVqb11jvzjl7pmWu7JnlrMVjXe+f7yOurJaR4gtIKTw",
	"iiXlknza9Dijuvedaj7IVvs92zTH3JVxtmquzG2htRFl0aQFIyjioQXO5fVqIaFHZJ3NkBQ4+nq8UDmJ",
	"YsuTGL2/Opc+gDJLGJb1ZexjEDLEg9PKVSd/Qnnn8P6B5EX1TLjxeVUDrvTXKRFz0RcGjuF129EjhJW3",
	"2XC/gg8aPYDpx6MFwbE+rv33garqc/BeEvHgfZ50OfPSxyctHkEv6Ex//i+BgJdeunwduAO9KZ+tbePd",
	"hJB0nNw32w2IZ28N3RfD3tm5T41HBpLFGzU9hCy9aaDBiH5L+B8Nyw5HzDD8BvvAumABy7a7YbaSuGlU",
	"YVWbOEgrKjPpWSs+a8UnqBVlZOLdgqS7U45lVpCc95b53omanGh+E1/VXwO0Z5GRiM5oVDG4PMH37ndI",
	"l36o2H43CUudm9wKjUPZMsCnaaSBwmDgsfUEp+LkGeuUpQWRJaEMap3n10ryhJ5aH2IDoFo6fTO6yptx",
	"ZxiXM414xxTqrTH8UlLNf7MzfOg1ywc9xv7O8Ls9u/ee2btH9SFHdP/JfLRL9fo4anXb1Ak4z4EEsvaD",
	"UUfDT2tBh7TRN4fTAEHsYPqws1f/kevbw5n3aOUSEcO0k08pbaYQLHfvMJ1Qd+y5bN/zRftjXrLf2Wse",
	"dLleK4XwlLQdqQYLk490B7MDknl1xB3Le29B6h8m+vVKmshR710UXZDoFtGZTVKZLG7evgToK7pUWDi2",
	"h9nWLZ6JGX0i6X8dZ8YAutdUlJiukYybiAsh6X319wALoBH64jMC7B0bLPDtuzlA5jcm/GQCyHa5hb0m",
	"SUBUU49uC6CmnfH+TModpn9vGLwRRMRWsEYfHdO90fFZk28xDWkzuT+JSZTQlLi1+hvVoB0/xpnfctPd",
	"Kryc2XFKf2w5EhTLWH9thqFpesSD1IQiYUdPyJ9bRHsov3xmKpsHZpZjGUE4lFdUr2dWoSxVqBjCMCZo",
	"MyzEyqLKJoFWarA2p6lJb5nREoJXxGeWnosGPedH2ebZgmnxQYN/EjLjAbyzCbcoErbdBuLHAO4If4GK",
	"5CuYnuo2Ep2oIlPoMsGpGK/Mk9HRaMF5VhxNJjijh1P1RBemk9WrUffKQsM5S2ckJ2nUhZGXaQ1j9PX3",
	"r/8/AAD//3gNZpqvewEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
