// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/blaxel-ai/toolkit/cli/register"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
	OAuth2Scopes     = "OAuth2.Scopes"
)

// Defines values for AgentRuntimeGeneration.
const (
	AgentRuntimeGenerationMk2 AgentRuntimeGeneration = "mk2"
	AgentRuntimeGenerationMk3 AgentRuntimeGeneration = "mk3"
)

// Defines values for CustomDomainSpecStatus.
const (
	CustomDomainSpecStatusFailed   CustomDomainSpecStatus = "failed"
	CustomDomainSpecStatusPending  CustomDomainSpecStatus = "pending"
	CustomDomainSpecStatusVerified CustomDomainSpecStatus = "verified"
)

// Defines values for ExpirationPolicyAction.
const (
	Delete ExpirationPolicyAction = "delete"
)

// Defines values for ExpirationPolicyType.
const (
	Date      ExpirationPolicyType = "date"
	TtlIdle   ExpirationPolicyType = "ttl-idle"
	TtlMaxAge ExpirationPolicyType = "ttl-max-age"
)

// Defines values for FlavorType.
const (
	Cpu FlavorType = "cpu"
	Gpu FlavorType = "gpu"
)

// Defines values for FunctionRuntimeGeneration.
const (
	FunctionRuntimeGenerationMk2 FunctionRuntimeGeneration = "mk2"
	FunctionRuntimeGenerationMk3 FunctionRuntimeGeneration = "mk3"
)

// Defines values for FunctionSpecTransport.
const (
	HttpStream FunctionSpecTransport = "http-stream"
	Websocket  FunctionSpecTransport = "websocket"
)

// Defines values for JobExecutionStatus.
const (
	JobExecutionStatusCancelled  JobExecutionStatus = "cancelled"
	JobExecutionStatusCancelling JobExecutionStatus = "cancelling"
	JobExecutionStatusFailed     JobExecutionStatus = "failed"
	JobExecutionStatusPending    JobExecutionStatus = "pending"
	JobExecutionStatusQueued     JobExecutionStatus = "queued"
	JobExecutionStatusRunning    JobExecutionStatus = "running"
	JobExecutionStatusSucceeded  JobExecutionStatus = "succeeded"
	JobExecutionStatusTimeout    JobExecutionStatus = "timeout"
)

// Defines values for JobExecutionTaskStatus.
const (
	Cancelled   JobExecutionTaskStatus = "cancelled"
	Failed      JobExecutionTaskStatus = "failed"
	Pending     JobExecutionTaskStatus = "pending"
	Reconciling JobExecutionTaskStatus = "reconciling"
	Running     JobExecutionTaskStatus = "running"
	Succeeded   JobExecutionTaskStatus = "succeeded"
	Unspecified JobExecutionTaskStatus = "unspecified"
)

// Defines values for JobRuntimeGeneration.
const (
	Mk2 JobRuntimeGeneration = "mk2"
	Mk3 JobRuntimeGeneration = "mk3"
)

// Defines values for ModelRuntimeType.
const (
	Anthropic          ModelRuntimeType = "anthropic"
	AzureAiInference   ModelRuntimeType = "azure-ai-inference"
	AzureMarketplace   ModelRuntimeType = "azure-marketplace"
	AzureOpenaiService ModelRuntimeType = "azure-openai-service"
	Cerebras           ModelRuntimeType = "cerebras"
	Cohere             ModelRuntimeType = "cohere"
	Deepseek           ModelRuntimeType = "deepseek"
	Gemini             ModelRuntimeType = "gemini"
	Groq               ModelRuntimeType = "groq"
	HfPrivateEndpoint  ModelRuntimeType = "hf_private_endpoint"
	HfPublicEndpoint   ModelRuntimeType = "hf_public_endpoint"
	Huggingface        ModelRuntimeType = "huggingface"
	Mcp                ModelRuntimeType = "mcp"
	Mistral            ModelRuntimeType = "mistral"
	Openai             ModelRuntimeType = "openai"
	PublicModel        ModelRuntimeType = "public_model"
	Vertexai           ModelRuntimeType = "vertexai"
	Xai                ModelRuntimeType = "xai"
)

// Defines values for PolicyLocationType.
const (
	PolicyLocationTypeContinent PolicyLocationType = "continent"
	PolicyLocationTypeCountry   PolicyLocationType = "country"
	PolicyLocationTypeLocation  PolicyLocationType = "location"
)

// Defines values for PolicyResourceType.
const (
	PolicyResourceTypeAgent    PolicyResourceType = "agent"
	PolicyResourceTypeFunction PolicyResourceType = "function"
	PolicyResourceTypeModel    PolicyResourceType = "model"
	PolicyResourceTypeSandbox  PolicyResourceType = "sandbox"
)

// Defines values for PolicySpecType.
const (
	PolicySpecTypeFlavor   PolicySpecType = "flavor"
	PolicySpecTypeLocation PolicySpecType = "location"
	PolicySpecTypeMaxToken PolicySpecType = "maxToken"
)

// Defines values for PortProtocol.
const (
	HTTP PortProtocol = "HTTP"
	TCP  PortProtocol = "TCP"
	UDP  PortProtocol = "UDP"
)

// Defines values for Status.
const (
	StatusBUILDING     Status = "BUILDING"
	StatusDEACTIVATED  Status = "DEACTIVATED"
	StatusDEACTIVATING Status = "DEACTIVATING"
	StatusDELETING     Status = "DELETING"
	StatusDEPLOYED     Status = "DEPLOYED"
	StatusDEPLOYING    Status = "DEPLOYING"
	StatusFAILED       Status = "FAILED"
	StatusTERMINATED   Status = "TERMINATED"
	StatusUPLOADING    Status = "UPLOADING"
)

// Defines values for TriggerType.
const (
	Cron      TriggerType = "cron"
	Http      TriggerType = "http"
	HttpAsync TriggerType = "http-async"
)

// Defines values for VolumeTemplateStateStatus.
const (
	VolumeTemplateStateStatusCreated VolumeTemplateStateStatus = "created"
	VolumeTemplateStateStatusError   VolumeTemplateStateStatus = "error"
	VolumeTemplateStateStatusReady   VolumeTemplateStateStatus = "ready"
)

// Defines values for VolumeTemplateVersionStatus.
const (
	VolumeTemplateVersionStatusCREATED VolumeTemplateVersionStatus = "CREATED"
	VolumeTemplateVersionStatusFAILED  VolumeTemplateVersionStatus = "FAILED"
	VolumeTemplateVersionStatusREADY   VolumeTemplateVersionStatus = "READY"
)

// Defines values for WorkspaceStatus.
const (
	WorkspaceStatusAccountBinded       WorkspaceStatus = "account_binded"
	WorkspaceStatusAccountConfigured   WorkspaceStatus = "account_configured"
	WorkspaceStatusCreated             WorkspaceStatus = "created"
	WorkspaceStatusError               WorkspaceStatus = "error"
	WorkspaceStatusReady               WorkspaceStatus = "ready"
	WorkspaceStatusWorkspaceConfigured WorkspaceStatus = "workspace_configured"
)

// Agent Serverless AI agent deployment that runs your custom agent code as an auto-scaling API endpoint. Agents are deployed from your code repository and expose a global inference URL for querying.
type Agent struct {
	// Events Events happening on a resource deployed on Blaxel
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Configuration for an AI agent including runtime settings, repository source, and deployment triggers
	Spec AgentSpec `json:"spec"`

	// Status Deployment status of a resource deployed on Blaxel
	Status *Status `json:"status,omitempty"`
}

// AgentRuntime Runtime configuration defining how the AI agent is deployed and scaled globally
type AgentRuntime struct {
	// Envs Environment variables injected into the agent. Supports Kubernetes EnvVar format with valueFrom references.
	Envs *[]Env `json:"envs,omitempty"`

	// Generation Infrastructure generation: mk2 (containers, 2-10s cold starts, 15+ global regions) or mk3 (microVMs, sub-25ms cold starts)
	Generation *AgentRuntimeGeneration `json:"generation,omitempty"`

	// Image Container image built by Blaxel when deploying with 'bl deploy'. This field is auto-populated during deployment.
	Image *string `json:"image,omitempty"`

	// MaxScale Maximum number of concurrent agent instances for auto-scaling under load
	MaxScale *int `json:"maxScale,omitempty"`

	// Memory Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
	Memory *int `json:"memory,omitempty"`

	// MinScale Minimum instances to keep warm. Set to 1+ to eliminate cold starts, 0 for scale-to-zero.
	MinScale *int `json:"minScale,omitempty"`
}

// AgentRuntimeGeneration Infrastructure generation: mk2 (containers, 2-10s cold starts, 15+ global regions) or mk3 (microVMs, sub-25ms cold starts)
type AgentRuntimeGeneration string

// AgentSpec Configuration for an AI agent including runtime settings, repository source, and deployment triggers
type AgentSpec struct {
	// Enabled When false, the agent is disabled and will not serve inference requests
	Enabled  *bool         `json:"enabled,omitempty"`
	Policies *PoliciesList `json:"policies,omitempty"`

	// Public When true, the agent is publicly accessible without authentication. Only available for mk3 generation.
	Public *bool `json:"public,omitempty"`

	// Repository Repository
	Repository *Repository `json:"repository,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Runtime configuration defining how the AI agent is deployed and scaled globally
	Runtime *AgentRuntime `json:"runtime,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	// ApiKey Api key
	ApiKey *string `json:"apiKey,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// ExpiresIn Duration until expiration. Supports formats like '30d' (30 days), '24h' (24 hours), '1w' (1 week). If not set, the API key never expires.
	ExpiresIn *string `json:"expires_in,omitempty"`

	// Id Api key id, to retrieve it from the API
	Id *string `json:"id,omitempty"`

	// Name Name for the API key
	Name *string `json:"name,omitempty"`

	// Sub User subject identifier
	Sub *string `json:"sub,omitempty"`

	// SubType Subject type (user or service_account)
	SubType *string `json:"sub_type,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Configuration Configuration
type Configuration struct {
	// Continents Continents
	Continents *[]Continent `json:"continents,omitempty"`

	// Countries Countries
	Countries *[]Country `json:"countries,omitempty"`

	// PrivateLocations Private locations managed with blaxel operator
	PrivateLocations *[]PrivateLocation `json:"privateLocations,omitempty"`

	// Regions Regions
	Regions *[]Region `json:"regions,omitempty"`
}

// Continent Continent
type Continent struct {
	// DisplayName Continent display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Continent code
	Name *string `json:"name,omitempty"`
}

// CoreEvent Core event
type CoreEvent struct {
	// CanaryRevision Canary revisionID link to the event
	CanaryRevision *string `json:"canaryRevision,omitempty"`

	// Message Event message
	Message *string `json:"message,omitempty"`

	// Revision RevisionID link to the event
	Revision *string `json:"revision,omitempty"`

	// Status Event status
	Status *string `json:"status,omitempty"`

	// Time Event time
	Time *string `json:"time,omitempty"`

	// Type Event type
	Type *string `json:"type,omitempty"`
}

// CoreEvents Events happening on a resource deployed on Blaxel
type CoreEvents = []CoreEvent

// Country Configuration
type Country struct {
	// DisplayName Country display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Country code
	Name *string `json:"name,omitempty"`
}

// CreateJobExecutionRequest Request to create a job execution
type CreateJobExecutionRequest struct {
	// ExecutionId Execution ID (optional, will be generated if not provided)
	ExecutionId *string `json:"executionId,omitempty"`

	// Id Unique message ID
	Id *string `json:"id,omitempty"`

	// JobId Job ID
	JobId *string `json:"jobId,omitempty"`

	// Tasks Array of task parameters for parallel execution
	Tasks *[]map[string]interface{} `json:"tasks,omitempty"`

	// WorkspaceId Workspace ID
	WorkspaceId *string `json:"workspaceId,omitempty"`
}

// CreateJobExecution Response returned when a job execution is successfully created. Contains identifiers and the tasks that will be executed.
type CreateJobExecution struct {
	// ExecutionId Unique identifier for the created execution. Use this ID to track execution status, retrieve logs, or cancel the execution.
	ExecutionId *string `json:"executionId,omitempty"`

	// Id Unique identifier for this request, used for idempotency and tracking. Auto-generated if not provided in the request.
	Id *string `json:"id,omitempty"`

	// JobId Name of the job that this execution belongs to
	JobId *string `json:"jobId,omitempty"`

	// Tasks Array of task configurations that will be executed in parallel according to the job's concurrency settings. Each task can have custom parameters.
	Tasks *[]map[string]interface{} `json:"tasks,omitempty"`

	// WorkspaceId Name of the workspace where the job execution was created
	WorkspaceId *string `json:"workspaceId,omitempty"`
}

// CustomDomain Custom domain for preview deployments
// The custom domain represents a base domain (e.g., example.com) that will be used
// to serve preview deployments. Each preview will be accessible at a subdomain:
// <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
type CustomDomain struct {
	// Metadata Custom domain metadata
	Metadata CustomDomainMetadata `json:"metadata"`

	// Spec Custom domain specification
	Spec CustomDomainSpec `json:"spec"`
}

// CustomDomainMetadata defines model for CustomDomainMetadata.
type CustomDomainMetadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Display name for the custom domain
	DisplayName *string `json:"displayName,omitempty"`

	// Labels Key-value pairs for organizing and filtering resources. Labels can be used to categorize resources by environment, project, team, or any custom taxonomy.
	Labels *MetadataLabels `json:"labels,omitempty"`

	// Name Domain name (e.g., "example.com")
	Name *string `json:"name,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// CustomDomainSpec Custom domain specification
type CustomDomainSpec struct {
	// CnameRecords CNAME target for the domain
	CnameRecords *string `json:"cnameRecords,omitempty"`

	// LastVerifiedAt Last verification attempt timestamp
	LastVerifiedAt *string `json:"lastVerifiedAt,omitempty"`

	// Region Region that the custom domain is associated with
	Region *string `json:"region,omitempty"`

	// Status Current status of the domain (pending, verified, failed)
	Status *CustomDomainSpecStatus `json:"status,omitempty"`

	// TxtRecords Map of TXT record names to values for domain verification
	TxtRecords *map[string]string `json:"txtRecords,omitempty"`

	// VerificationError Error message if verification failed
	VerificationError *string `json:"verificationError,omitempty"`
}

// CustomDomainSpecStatus Current status of the domain (pending, verified, failed)
type CustomDomainSpecStatus string

// Entrypoint Entrypoint of the artifact
type Entrypoint struct {
	// Args Args of the entrypoint
	Args *[]map[string]interface{} `json:"args,omitempty"`

	// Command Command of the entrypoint
	Command *string `json:"command,omitempty"`

	// Env Env of the entrypoint
	Env *map[string]string `json:"env,omitempty"`

	// SuperGatewayArgs Super Gateway args of the entrypoint
	SuperGatewayArgs *[]map[string]interface{} `json:"superGatewayArgs,omitempty"`
}

// Env Environment variable with name and value
type Env struct {
	// Name Name of the environment variable
	Name *string `json:"name,omitempty"`

	// Secret Whether the value is a secret
	Secret *bool `json:"secret,omitempty"`

	// Value Value of the environment variable
	Value *string `json:"value,omitempty"`
}

// Error Standard error response returned by the API when a request fails
type Error struct {
	// Code HTTP status code of the error
	Code *int `json:"code,omitempty"`

	// Error Error type or code identifying the kind of error
	Error string `json:"error"`

	// Message Human-readable error message describing what went wrong
	Message *string `json:"message,omitempty"`
}

// ExpirationPolicy Expiration policy for automatic sandbox cleanup based on time conditions
type ExpirationPolicy struct {
	// Action Action to take when the expiration condition is met
	Action *ExpirationPolicyAction `json:"action,omitempty"`

	// Type Type of expiration policy: ttl-idle (delete after inactivity), ttl-max-age (delete after total lifetime), or date (delete at specific time)
	Type *ExpirationPolicyType `json:"type,omitempty"`

	// Value Duration value for TTL policies (e.g., '30m', '24h', '7d') or ISO 8601 date for date policies
	Value *string `json:"value,omitempty"`
}

// ExpirationPolicyAction Action to take when the expiration condition is met
type ExpirationPolicyAction string

// ExpirationPolicyType Type of expiration policy: ttl-idle (delete after inactivity), ttl-max-age (delete after total lifetime), or date (delete at specific time)
type ExpirationPolicyType string

// Flavor A type of hardware available for deployments
type Flavor struct {
	// Name Flavor name (e.g. t4)
	Name *string `json:"name,omitempty"`

	// Type Flavor type (e.g. cpu, gpu)
	Type *FlavorType `json:"type,omitempty"`
}

// FlavorType Flavor type (e.g. cpu, gpu)
type FlavorType string

// Flavors Types of hardware available for deployments
type Flavors = []Flavor

// Form Form of the artifact
type Form struct {
	// Config Config of the artifact
	Config *map[string]interface{} `json:"config,omitempty"`

	// Oauth OAuth of the artifact
	Oauth *OAuth `json:"oauth,omitempty"`

	// Secrets Secrets of the artifact
	Secrets *map[string]interface{} `json:"secrets,omitempty"`
}

// Function MCP server deployment that exposes tools for AI agents via the Model Context Protocol (MCP). Deployed as a serverless auto-scaling endpoint using streamable HTTP transport.
type Function struct {
	// Events Events happening on a resource deployed on Blaxel
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Configuration for an MCP server function including runtime settings, transport protocol, and connected integrations
	Spec FunctionSpec `json:"spec"`

	// Status Deployment status of a resource deployed on Blaxel
	Status *Status `json:"status,omitempty"`
}

// FunctionRuntime Runtime configuration defining how the MCP server function is deployed and scaled
type FunctionRuntime struct {
	// Envs Environment variables injected into the function. Supports Kubernetes EnvVar format with valueFrom references.
	Envs *[]Env `json:"envs,omitempty"`

	// Generation Infrastructure generation: mk2 (containers, 2-10s cold starts, 15+ global regions) or mk3 (microVMs, sub-25ms cold starts)
	Generation *FunctionRuntimeGeneration `json:"generation,omitempty"`

	// Image Container image built by Blaxel when deploying with 'bl deploy'. This field is auto-populated during deployment.
	Image *string `json:"image,omitempty"`

	// MaxScale Maximum number of concurrent function instances for auto-scaling
	MaxScale *int `json:"maxScale,omitempty"`

	// Memory Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
	Memory *int `json:"memory,omitempty"`

	// MinScale Minimum instances to keep warm. Set to 1+ to eliminate cold starts, 0 for scale-to-zero.
	MinScale *int `json:"minScale,omitempty"`
}

// FunctionRuntimeGeneration Infrastructure generation: mk2 (containers, 2-10s cold starts, 15+ global regions) or mk3 (microVMs, sub-25ms cold starts)
type FunctionRuntimeGeneration string

// FunctionSpec Configuration for an MCP server function including runtime settings, transport protocol, and connected integrations
type FunctionSpec struct {
	// Enabled When false, the function is disabled and will not serve requests
	Enabled                *bool                       `json:"enabled,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Public When true, the function is publicly accessible without authentication. Only available for mk3 generation.
	Public *bool `json:"public,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Runtime configuration defining how the MCP server function is deployed and scaled
	Runtime *FunctionRuntime `json:"runtime,omitempty"`

	// Transport Transport compatibility for the MCP, can be "websocket" or "http-stream"
	Transport *FunctionSpecTransport `json:"transport,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// FunctionSpecTransport Transport compatibility for the MCP, can be "websocket" or "http-stream"
type FunctionSpecTransport string

// Image defines model for Image.
type Image struct {
	Metadata ImageMetadata `json:"metadata"`
	Spec     ImageSpec     `json:"spec"`
}

// ImageMetadata defines model for ImageMetadata.
type ImageMetadata struct {
	// CreatedAt The date and time when the image was created.
	CreatedAt *string `json:"createdAt,omitempty"`

	// DisplayName The display name of the image (registry/workspace/repository).
	DisplayName *string `json:"displayName,omitempty"`

	// LastDeployedAt The date and time when the image was last deployed (most recent across all tags).
	LastDeployedAt *string `json:"lastDeployedAt,omitempty"`

	// Name The name of the image (repository name).
	Name *string `json:"name,omitempty"`

	// ResourceType The resource type of the image.
	ResourceType *string `json:"resourceType,omitempty"`

	// UpdatedAt The date and time when the image was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Workspace The workspace of the image.
	Workspace *string `json:"workspace,omitempty"`
}

// ImageSpec defines model for ImageSpec.
type ImageSpec struct {
	// Size The size of the image in bytes.
	Size *int `json:"size,omitempty"`

	// Tags List of tags available for this image.
	Tags *[]ImageTag `json:"tags,omitempty"`
}

// ImageTag defines model for ImageTag.
type ImageTag struct {
	// CreatedAt The date and time when the tag was created.
	CreatedAt *string `json:"createdAt,omitempty"`

	// Name The name of the tag.
	Name *string `json:"name,omitempty"`

	// Size The size of the image in bytes.
	Size *int `json:"size,omitempty"`

	// UpdatedAt The date and time when the tag was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Integration Integration
type Integration struct {
	// AdditionalInfos Integration additional infos
	AdditionalInfos *map[string]string `json:"additionalInfos,omitempty"`

	// Endpoints Integration endpoints
	Endpoints *IntegrationEndpoints `json:"endpoints,omitempty"`

	// Headers Integration headers
	Headers *IntegrationHeaders `json:"headers,omitempty"`

	// Name Integration name
	Name *string `json:"name,omitempty"`

	// Organizations Integration organizations
	Organizations *[]IntegrationOrganization `json:"organizations,omitempty"`

	// Params Integration query params
	Params *IntegrationQueryParams `json:"params,omitempty"`

	// Repositories Integration repositories
	Repositories *[]IntegrationRepository `json:"repositories,omitempty"`
}

// IntegrationConnection Configured connection to an external service (LLM provider, API, SaaS, database) storing credentials and settings for use by workspace resources.
type IntegrationConnection struct {
	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Specification defining the integration type, configuration parameters, and encrypted credentials
	Spec IntegrationConnectionSpec `json:"spec"`
}

// IntegrationConnectionSpec Specification defining the integration type, configuration parameters, and encrypted credentials
type IntegrationConnectionSpec struct {
	// Config Non-sensitive configuration parameters for the integration (e.g., organization ID, region)
	Config *map[string]string `json:"config,omitempty"`

	// Integration Integration provider type (e.g., openai, anthropic, github, slack)
	Integration *string `json:"integration,omitempty"`

	// Sandbox Whether this connection uses sandbox/test credentials instead of production
	Sandbox *bool `json:"sandbox,omitempty"`

	// Secret Encrypted credentials and API keys for authenticating with the external service
	Secret *map[string]string `json:"secret,omitempty"`
}

// IntegrationConnectionsList defines model for IntegrationConnectionsList.
type IntegrationConnectionsList = []string

// IntegrationEndpoint Integration endpoint
type IntegrationEndpoint struct {
	// Body Integration endpoint body
	Body *string `json:"body,omitempty"`

	// IgnoreModels Integration endpoint ignore models
	IgnoreModels *[]map[string]interface{} `json:"ignoreModels,omitempty"`

	// Method Integration endpoint method
	Method *string `json:"method,omitempty"`

	// Models Integration endpoint models
	Models *[]map[string]interface{} `json:"models,omitempty"`

	// StreamKey Integration endpoint stream key
	StreamKey *string `json:"streamKey,omitempty"`

	// StreamToken Integration endpoint token
	StreamToken *IntegrationEndpointToken `json:"streamToken,omitempty"`

	// Token Integration endpoint token
	Token *IntegrationEndpointToken `json:"token,omitempty"`
}

// IntegrationEndpointToken Integration endpoint token
type IntegrationEndpointToken struct {
	// Received Integration endpoint token received
	Received *string `json:"received,omitempty"`

	// Sent Integration endpoint token sent
	Sent *string `json:"sent,omitempty"`

	// Total Integration endpoint token total
	Total *string `json:"total,omitempty"`
}

// IntegrationEndpoints Integration endpoints
type IntegrationEndpoints map[string]IntegrationEndpoint

// IntegrationHeaders Integration headers
type IntegrationHeaders map[string]string

// IntegrationOrganization Integration organization
type IntegrationOrganization struct {
	// AvatarUrl Provider organization avatar URL
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// DisplayName Provider organization display name
	DisplayName *string `json:"displayName,omitempty"`

	// Id Provider organization ID
	Id *string `json:"id,omitempty"`

	// Name Provider organization name
	Name *string `json:"name,omitempty"`
}

// IntegrationQueryParams Integration query params
type IntegrationQueryParams map[string]string

// IntegrationRepository Integration repository
type IntegrationRepository struct {
	// Id Repository ID
	Id *string `json:"id,omitempty"`

	// IsBl Whether the repository has Blaxel imports
	IsBl *bool `json:"isBl,omitempty"`

	// Name Repository name
	Name *string `json:"name,omitempty"`

	// Organization Repository owner
	Organization *string `json:"organization,omitempty"`

	// Url Repository URL
	Url *string `json:"url,omitempty"`
}

// Job Batch processing job definition for running parallel AI tasks. Jobs can execute multiple tasks concurrently with configurable parallelism, retries, and timeouts.
type Job struct {
	// Events Events happening on a resource deployed on Blaxel
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Configuration for a batch job including execution parameters, parallelism settings, and deployment region
	Spec JobSpec `json:"spec"`

	// Status Deployment status of a resource deployed on Blaxel
	Status *Status `json:"status,omitempty"`
}

// JobExecution Job execution
type JobExecution struct {
	// Metadata Job execution metadata
	Metadata *JobExecutionMetadata `json:"metadata,omitempty"`

	// Spec Job execution specification
	Spec JobExecutionSpec `json:"spec"`

	// Stats Job execution statistics
	Stats *JobExecutionStats `json:"stats,omitempty"`

	// Status Job execution status
	Status *JobExecutionStatus `json:"status,omitempty"`

	// Tasks List of execution tasks
	Tasks *[]JobExecutionTask `json:"tasks,omitempty"`
}

// JobExecutionMetadata Job execution metadata
type JobExecutionMetadata struct {
	// Cluster Cluster ID
	Cluster *string `json:"cluster,omitempty"`

	// CompletedAt Completion timestamp
	CompletedAt *string `json:"completedAt,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"createdAt,omitempty"`

	// DeletedAt Deletion timestamp
	DeletedAt *string `json:"deletedAt,omitempty"`

	// ExpiredAt Expiration timestamp
	ExpiredAt *string `json:"expiredAt,omitempty"`

	// Id Execution ID
	Id *string `json:"id,omitempty"`

	// Job Job name
	Job *string `json:"job,omitempty"`

	// StartedAt Start timestamp
	StartedAt *string `json:"startedAt,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Workspace Workspace ID
	Workspace *string `json:"workspace,omitempty"`
}

// JobExecutionSpec Job execution specification
type JobExecutionSpec struct {
	// Parallelism Number of parallel tasks
	Parallelism *int `json:"parallelism,omitempty"`

	// Tasks List of execution tasks
	Tasks *[]JobExecutionTask `json:"tasks,omitempty"`

	// Timeout Job timeout in seconds (captured at execution creation time)
	Timeout *int `json:"timeout,omitempty"`
}

// JobExecutionStats Job execution statistics
type JobExecutionStats struct {
	// Cancelled Number of cancelled tasks
	Cancelled *int `json:"cancelled,omitempty"`

	// Failure Number of failed tasks
	Failure *int `json:"failure,omitempty"`

	// Retried Number of retried tasks
	Retried *int `json:"retried,omitempty"`

	// Running Number of running tasks
	Running *int `json:"running,omitempty"`

	// Success Number of successful tasks
	Success *int `json:"success,omitempty"`

	// Total Total number of tasks
	Total *int `json:"total,omitempty"`
}

// JobExecutionStatus Job execution status
type JobExecutionStatus string

// JobExecutionTask Job execution task
type JobExecutionTask struct {
	// Conditions Task conditions
	Conditions *[]JobExecutionTaskCondition `json:"conditions,omitempty"`

	// Metadata Job execution task metadata
	Metadata *JobExecutionTaskMetadata `json:"metadata,omitempty"`

	// Spec Job execution task specification
	Spec *JobExecutionTaskSpec `json:"spec,omitempty"`

	// Status Job execution task status
	Status *JobExecutionTaskStatus `json:"status,omitempty"`
}

// JobExecutionTaskCondition Job execution task condition
type JobExecutionTaskCondition struct {
	// ExecutionReason Execution reason
	ExecutionReason *string `json:"executionReason,omitempty"`

	// Message Condition message
	Message *string `json:"message,omitempty"`

	// Reason Condition reason
	Reason *string `json:"reason,omitempty"`

	// Severity Condition severity
	Severity *string `json:"severity,omitempty"`

	// State Condition state
	State *string `json:"state,omitempty"`

	// Type Condition type
	Type *string `json:"type,omitempty"`
}

// JobExecutionTaskMetadata Job execution task metadata
type JobExecutionTaskMetadata struct {
	// CompletedAt Completion timestamp
	CompletedAt *string `json:"completedAt,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"createdAt,omitempty"`

	// Name Task name
	Name *string `json:"name,omitempty"`

	// ScheduledAt Scheduled timestamp
	ScheduledAt *string `json:"scheduledAt,omitempty"`

	// StartedAt Start timestamp
	StartedAt *string `json:"startedAt,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// JobExecutionTaskSpec Job execution task specification
type JobExecutionTaskSpec struct {
	// MaxRetries Maximum number of retries
	MaxRetries *int `json:"maxRetries,omitempty"`

	// Timeout Task timeout duration
	Timeout *string `json:"timeout,omitempty"`
}

// JobExecutionTaskStatus Job execution task status
type JobExecutionTaskStatus string

// JobRuntime Runtime configuration defining how batch job tasks are executed with parallelism and retry settings
type JobRuntime struct {
	// Envs Environment variables injected into job tasks. Supports Kubernetes EnvVar format with valueFrom references.
	Envs *[]Env `json:"envs,omitempty"`

	// Generation Infrastructure generation: mk2 (containers, 2-10s cold starts) or mk3 (microVMs, sub-25ms cold starts)
	Generation *JobRuntimeGeneration `json:"generation,omitempty"`

	// Image Container image built by Blaxel when deploying with 'bl deploy'. This field is auto-populated during deployment.
	Image *string `json:"image,omitempty"`

	// MaxConcurrentTasks Maximum number of tasks that can run simultaneously within a single execution
	MaxConcurrentTasks *int `json:"maxConcurrentTasks,omitempty"`

	// MaxRetries Number of automatic retry attempts for failed tasks before marking as failed
	MaxRetries *int `json:"maxRetries,omitempty"`

	// Memory Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
	Memory *int `json:"memory,omitempty"`

	// Ports Set of ports for a resource
	Ports *Ports `json:"ports,omitempty"`

	// Timeout Maximum execution time in seconds before a task is terminated
	Timeout *int `json:"timeout,omitempty"`
}

// JobRuntimeGeneration Infrastructure generation: mk2 (containers, 2-10s cold starts) or mk3 (microVMs, sub-25ms cold starts)
type JobRuntimeGeneration string

// JobSpec Configuration for a batch job including execution parameters, parallelism settings, and deployment region
type JobSpec struct {
	// Enabled When false, the job is disabled and new executions cannot be triggered
	Enabled  *bool         `json:"enabled,omitempty"`
	Policies *PoliciesList `json:"policies,omitempty"`

	// Region Region where the job should be created (e.g. us-was-1, eu-lon-1)
	Region *string `json:"region,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Runtime configuration defining how batch job tasks are executed with parallelism and retry settings
	Runtime *JobRuntime `json:"runtime,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// LocationResponse Location availability for policies
type LocationResponse struct {
	// Continent Continent of the location
	Continent *string `json:"continent,omitempty"`

	// Country Country of the location
	Country *string `json:"country,omitempty"`

	// Flavors Hardware flavors available in the location
	Flavors *[]Flavor `json:"flavors,omitempty"`

	// Location Name of the location
	Location *string `json:"location,omitempty"`

	// Region Region of the location
	Region *string `json:"region,omitempty"`

	// Status Status of the location
	Status *string `json:"status,omitempty"`
}

// MCPDefinition defines model for MCPDefinition.
type MCPDefinition struct {
	// Categories Categories of the artifact
	Categories *[]map[string]interface{} `json:"categories,omitempty"`

	// ComingSoon If the artifact is coming soon
	ComingSoon *bool `json:"coming_soon,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// Description Description of the artifact
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the artifact
	DisplayName *string `json:"displayName,omitempty"`

	// Enterprise If the artifact is enterprise
	Enterprise *bool `json:"enterprise,omitempty"`

	// Entrypoint Entrypoint of the artifact
	Entrypoint *Entrypoint `json:"entrypoint,omitempty"`

	// Form Form of the artifact
	Form *Form `json:"form,omitempty"`

	// Hidden If the artifact is hidden
	Hidden *bool `json:"hidden,omitempty"`

	// HiddenSecrets Hidden secrets of the artifact
	HiddenSecrets *[]string `json:"hiddenSecrets,omitempty"`

	// Icon Icon of the artifact
	Icon *string `json:"icon,omitempty"`

	// Image Image of the artifact
	Image *string `json:"image,omitempty"`

	// Integration Integration of the artifact
	Integration *string `json:"integration,omitempty"`

	// LongDescription Long description of the artifact
	LongDescription *string `json:"longDescription,omitempty"`

	// Name Name of the artifact
	Name *string `json:"name,omitempty"`

	// Transport Transport compatibility for the MCP, can be "websocket" or "http-stream"
	Transport *string `json:"transport,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Url URL of the artifact
	Url *string `json:"url,omitempty"`
}

// Metadata defines model for Metadata.
type Metadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Human-readable name for display in the UI. Can contain spaces and special characters, max 63 characters.
	DisplayName *string `json:"displayName,omitempty"`

	// Labels Key-value pairs for organizing and filtering resources. Labels can be used to categorize resources by environment, project, team, or any custom taxonomy.
	Labels *MetadataLabels `json:"labels,omitempty"`

	// Name Unique identifier for the resource within the workspace. Must be lowercase alphanumeric with hyphens, max 49 characters. Immutable after creation.
	Name string `json:"name"`

	// Plan Billing plan tier applied to this resource (inherited from workspace account)
	Plan *string `json:"plan,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Url Auto-generated endpoint URL for accessing this resource (for agents, functions, models, sandboxes)
	Url *string `json:"url,omitempty"`

	// Workspace Name of the workspace this resource belongs to (read-only, set automatically)
	Workspace *string `json:"workspace,omitempty"`
}

// MetadataLabels Key-value pairs for organizing and filtering resources. Labels can be used to categorize resources by environment, project, team, or any custom taxonomy.
type MetadataLabels map[string]string

// Model Gateway endpoint to external LLM provider APIs (OpenAI, Anthropic, etc.) with unified access control, credentials management, and usage tracking.
type Model struct {
	// Events Events happening on a resource deployed on Blaxel
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Configuration for a model gateway endpoint including provider type, credentials, and access policies
	Spec ModelSpec `json:"spec"`

	// Status Deployment status of a resource deployed on Blaxel
	Status *Status `json:"status,omitempty"`
}

// ModelRuntime Configuration identifying which external LLM provider and model this gateway endpoint proxies to
type ModelRuntime struct {
	// EndpointName Provider-specific endpoint name (e.g., HuggingFace Inference Endpoints name)
	EndpointName *string `json:"endpointName,omitempty"`

	// Model Model identifier at the provider (e.g., gpt-4.1, claude-sonnet-4-20250514, mistral-large-latest)
	Model *string `json:"model,omitempty"`

	// Organization Organization or account identifier at the provider (required for some providers like OpenAI)
	Organization *string `json:"organization,omitempty"`

	// Type LLM provider type determining the API protocol and authentication method
	Type *ModelRuntimeType `json:"type,omitempty"`
}

// ModelRuntimeType LLM provider type determining the API protocol and authentication method
type ModelRuntimeType string

// ModelSpec Configuration for a model gateway endpoint including provider type, credentials, and access policies
type ModelSpec struct {
	// Enabled When false, the model endpoint is disabled and will not accept inference requests
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Runtime Configuration identifying which external LLM provider and model this gateway endpoint proxies to
	Runtime *ModelRuntime `json:"runtime,omitempty"`

	// Sandbox When true, uses sandbox/test credentials from the integration connection
	Sandbox *bool `json:"sandbox,omitempty"`
}

// OAuth OAuth of the artifact
type OAuth struct {
	// Scope Scope of the OAuth
	Scope *[]map[string]interface{} `json:"scope,omitempty"`

	// Type Type of the OAuth
	Type *string `json:"type,omitempty"`
}

// OwnerFields Owner fields for Persistance
type OwnerFields struct {
	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// PendingInvitation defines model for PendingInvitation.
type PendingInvitation struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// Email User email
	Email *string `json:"email,omitempty"`

	// InvitedBy User sub
	InvitedBy *string `json:"invitedBy,omitempty"`

	// Role ACL role
	Role *string `json:"role,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PendingInvitationAccept Pending invitation accept
type PendingInvitationAccept struct {
	// Email User email
	Email *string `json:"email,omitempty"`

	// Workspace Tenant container that groups all Blaxel resources (agents, functions, models, etc.) with shared team access control and billing.
	Workspace *Workspace `json:"workspace,omitempty"`
}

// PoliciesList defines model for PoliciesList.
type PoliciesList = []string

// Policy Rule that controls how a deployment is made and served (e.g. location restrictions)
type Policy struct {
	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Policy specification
	Spec PolicySpec `json:"spec"`
}

// PolicyLocation Policy location
type PolicyLocation struct {
	// Name Policy location name
	Name *string `json:"name,omitempty"`

	// Type Policy location type
	Type *PolicyLocationType `json:"type,omitempty"`
}

// PolicyLocationType Policy location type
type PolicyLocationType string

// PolicyLocations PolicyLocations is a local type that wraps a slice of Location
type PolicyLocations = []PolicyLocation

// PolicyMaxTokens PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
type PolicyMaxTokens struct {
	// Granularity Granularity
	Granularity *string `json:"granularity,omitempty"`

	// Input Input
	Input *int `json:"input,omitempty"`

	// Output Output
	Output *int `json:"output,omitempty"`

	// RatioInputOverOutput RatioInputOverOutput
	RatioInputOverOutput *int `json:"ratioInputOverOutput,omitempty"`

	// Step Step
	Step *int `json:"step,omitempty"`

	// Total Total
	Total *int `json:"total,omitempty"`
}

// PolicyResourceType PolicyResourceType is a type of resource, e.g. model, function, etc.
type PolicyResourceType string

// PolicyResourceTypes PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
type PolicyResourceTypes = []PolicyResourceType

// PolicySpec Policy specification
type PolicySpec struct {
	// Flavors Types of hardware available for deployments
	Flavors *Flavors `json:"flavors,omitempty"`

	// Locations PolicyLocations is a local type that wraps a slice of Location
	Locations *PolicyLocations `json:"locations,omitempty"`

	// MaxTokens PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
	MaxTokens *PolicyMaxTokens `json:"maxTokens,omitempty"`

	// ResourceTypes PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
	ResourceTypes *PolicyResourceTypes `json:"resourceTypes,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Type Policy type, can be location or flavor
	Type *PolicySpecType `json:"type,omitempty"`
}

// PolicySpecType Policy type, can be location or flavor
type PolicySpecType string

// Port A port for a resource
type Port struct {
	// Name The name of the port
	Name *string `json:"name,omitempty"`

	// Protocol The protocol of the port
	Protocol *PortProtocol `json:"protocol,omitempty"`

	// Target The target port of the port
	Target int `json:"target"`
}

// PortProtocol The protocol of the port
type PortProtocol string

// Ports Set of ports for a resource
type Ports = []Port

// Preview Preview of a Resource
type Preview struct {
	// Metadata PreviewMetadata
	Metadata PreviewMetadata `json:"metadata"`

	// Spec Preview of a Resource
	Spec PreviewSpec `json:"spec"`
}

// PreviewMetadata defines model for PreviewMetadata.
type PreviewMetadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Model display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Preview name
	Name string `json:"name"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PreviewSpec Preview of a Resource
type PreviewSpec struct {
	// CustomDomain Custom domain bound to this preview
	CustomDomain *string `json:"customDomain,omitempty"`

	// Expires The expiration date for the preview in ISO 8601 format - 2024-12-31T23:59:59Z
	Expires *string `json:"expires,omitempty"`

	// Port Port of the preview
	Port *int `json:"port,omitempty"`

	// PrefixUrl Prefix URL
	PrefixUrl *string `json:"prefixUrl,omitempty"`

	// Public Whether the preview is public
	Public *bool `json:"public,omitempty"`

	// Region Region where the preview is deployed, this is readonly
	Region *string `json:"region,omitempty"`

	// RequestHeaders Those headers will be set in all requests to your preview. This is especially useful to set the Authorization header.
	RequestHeaders *map[string]string `json:"requestHeaders,omitempty"`

	// ResponseHeaders Those headers will be set in all responses of your preview. This is especially useful to set the CORS headers.
	ResponseHeaders *map[string]string `json:"responseHeaders,omitempty"`

	// Ttl Time to live for the preview (e.g., "1h", "24h", "7d"). After this duration, the preview will be automatically deleted.
	Ttl *string `json:"ttl,omitempty"`

	// Url URL of the preview
	Url *string `json:"url,omitempty"`
}

// PreviewToken Token for a Preview
type PreviewToken struct {
	// Metadata PreviewTokenMetadata
	Metadata PreviewTokenMetadata `json:"metadata"`

	// Spec Spec for a Preview Token
	Spec PreviewTokenSpec `json:"spec"`
}

// PreviewTokenMetadata PreviewTokenMetadata
type PreviewTokenMetadata struct {
	// Name Token name
	Name string `json:"name"`

	// PreviewName Preview name
	PreviewName *string `json:"previewName,omitempty"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PreviewTokenSpec Spec for a Preview Token
type PreviewTokenSpec struct {
	// Expired Whether the token is expired
	Expired *bool `json:"expired,omitempty"`

	// ExpiresAt Expiration time of the token
	ExpiresAt *string `json:"expiresAt,omitempty"`

	// Token Token
	Token *string `json:"token,omitempty"`
}

// PrivateLocation Private location available for policies
type PrivateLocation struct {
	// Name Location name
	Name *string `json:"name,omitempty"`
}

// PublicIp defines model for PublicIp.
type PublicIp struct {
	// Description Description of the region/location
	Description *string `json:"description,omitempty"`

	// Ipv4Cidrs List of public ipv4 addresses
	Ipv4Cidrs *[]string `json:"ipv4Cidrs,omitempty"`

	// Ipv6Cidrs List of public ipv6 addresses
	Ipv6Cidrs *[]string `json:"ipv6Cidrs,omitempty"`
}

// PublicIps defines model for PublicIps.
type PublicIps map[string]PublicIp

// Region Region
type Region struct {
	// Allowed Region display name
	Allowed *string `json:"allowed,omitempty"`

	// Continent Region display name
	Continent *string `json:"continent,omitempty"`

	// Country Region display name
	Country *string `json:"country,omitempty"`

	// InfoGeneration Region display name
	InfoGeneration *string `json:"infoGeneration,omitempty"`

	// Location Region display name
	Location *string `json:"location,omitempty"`

	// Name Region name
	Name *string `json:"name,omitempty"`
}

// Repository Repository
type Repository struct {
	// Type Repository type
	Type *string `json:"type,omitempty"`

	// Url Repository URL
	Url *string `json:"url,omitempty"`
}

// RevisionConfiguration Revision configuration
type RevisionConfiguration struct {
	// Active Active revision id
	Active *string `json:"active,omitempty"`

	// Canary Canary revision id
	Canary *string `json:"canary,omitempty"`

	// CanaryPercent Canary revision percent
	CanaryPercent *int `json:"canaryPercent,omitempty"`

	// StickySessionTtl Sticky session TTL in seconds (0 = disabled)
	StickySessionTtl *int `json:"stickySessionTtl,omitempty"`

	// Traffic Traffic percentage
	Traffic *int `json:"traffic,omitempty"`
}

// RevisionMetadata Revision metadata
type RevisionMetadata struct {
	// Active Is the revision active
	Active *bool `json:"active,omitempty"`

	// Canary Is the revision canary
	Canary *bool `json:"canary,omitempty"`

	// CreatedAt Revision created at
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy Revision created by
	CreatedBy *string `json:"createdBy,omitempty"`

	// Id Revision ID
	Id *string `json:"id,omitempty"`

	// PreviousActive Is the revision previous active
	PreviousActive *bool `json:"previousActive,omitempty"`

	// Status Status of the revision
	Status *string `json:"status,omitempty"`

	// TrafficPercent Percent of traffic to the revision
	TrafficPercent *int `json:"trafficPercent,omitempty"`
}

// Sandbox Lightweight virtual machine for secure AI code execution. Sandboxes resume from standby in under 25ms and automatically scale to zero after inactivity, preserving memory state including running processes and filesystem.
type Sandbox struct {
	// Events Events happening on a resource deployed on Blaxel
	Events *CoreEvents `json:"events,omitempty"`

	// LastUsedAt Last time the sandbox was used (read-only, managed by the system)
	LastUsedAt *string `json:"lastUsedAt,omitempty"`

	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Configuration for a sandbox including its image, memory, ports, region, and lifecycle policies
	Spec SandboxSpec `json:"spec"`

	// Status Deployment status of a resource deployed on Blaxel
	Status *Status `json:"status,omitempty"`
}

// SandboxDefinition Pre-configured sandbox template available in the Sandbox Hub for quick deployment with predefined tools and configurations
type SandboxDefinition struct {
	// Categories Categories of the defintion
	Categories *[]map[string]interface{} `json:"categories,omitempty"`

	// ComingSoon If the definition is coming soon
	ComingSoon *bool `json:"coming_soon,omitempty"`

	// Description Description of the defintion
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the definition
	DisplayName *string `json:"displayName,omitempty"`

	// Enterprise If the definition is enterprise
	Enterprise *bool `json:"enterprise,omitempty"`

	// Hidden If the definition is hidden
	Hidden *bool `json:"hidden,omitempty"`

	// Icon Icon of the definition
	Icon *string `json:"icon,omitempty"`

	// Image Image of the Sandbox definition
	Image *string `json:"image,omitempty"`

	// LongDescription Long description of the defintion
	LongDescription *string `json:"longDescription,omitempty"`

	// Memory Memory of the Sandbox definition in MB
	Memory *int `json:"memory,omitempty"`

	// Name Name of the artifact
	Name *string `json:"name,omitempty"`

	// Ports Set of ports for a resource
	Ports *Ports `json:"ports,omitempty"`

	// Tags Tags of the definition
	Tags *string `json:"tags,omitempty"`

	// Url URL of the definition
	Url *string `json:"url,omitempty"`
}

// SandboxError Error response returned by the CreateSandbox endpoint with extended details about the failure
type SandboxError struct {
	// Code Error code identifying the kind of error (e.g., INVALID_IMAGE, QUOTA_EXCEEDED)
	Code string `json:"code"`

	// Details Additional error details. For INVALID_IMAGE errors, includes requested_image and supported_images array.
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message Human-readable error message describing what went wrong
	Message string `json:"message"`

	// SandboxName Name of the sandbox that failed to create
	SandboxName *string `json:"sandbox_name,omitempty"`

	// StatusCode HTTP status code
	StatusCode *int `json:"status_code,omitempty"`

	// Step Processing step where the error occurred
	Step *string `json:"step,omitempty"`

	// Timestamp ISO 8601 timestamp of when the error occurred
	Timestamp *string `json:"timestamp,omitempty"`

	// Workspace Workspace name where the sandbox creation was attempted
	Workspace *string `json:"workspace,omitempty"`
}

// SandboxLifecycle Lifecycle configuration controlling automatic sandbox deletion based on idle time, max age, or specific dates
type SandboxLifecycle struct {
	// ExpirationPolicies List of expiration policies. Multiple policies can be combined; whichever condition is met first triggers the action.
	ExpirationPolicies *[]ExpirationPolicy `json:"expirationPolicies,omitempty"`
}

// SandboxRuntime Runtime configuration defining how the sandbox VM is provisioned and its resource limits
type SandboxRuntime struct {
	// Envs Environment variables injected into the sandbox. Supports Kubernetes EnvVar format with valueFrom references.
	Envs *[]Env `json:"envs,omitempty"`

	// Expires Absolute expiration timestamp in ISO 8601 format when the sandbox will be deleted
	Expires *string `json:"expires,omitempty"`

	// Image Sandbox image to use. Can be a public Blaxel image (e.g., blaxel/base-image:latest) or a custom template image built with 'bl deploy'.
	Image *string `json:"image,omitempty"`

	// Memory Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
	Memory *int `json:"memory,omitempty"`

	// Ports Set of ports for a resource
	Ports *Ports `json:"ports,omitempty"`

	// Ttl Time-to-live duration after which the sandbox is automatically deleted (e.g., '30m', '24h', '7d')
	Ttl *string `json:"ttl,omitempty"`
}

// SandboxSpec Configuration for a sandbox including its image, memory, ports, region, and lifecycle policies
type SandboxSpec struct {
	// Enabled When false, the sandbox is disabled and will not accept connections
	Enabled *bool `json:"enabled,omitempty"`

	// Lifecycle Lifecycle configuration controlling automatic sandbox deletion based on idle time, max age, or specific dates
	Lifecycle *SandboxLifecycle `json:"lifecycle,omitempty"`

	// Region Region where the sandbox should be created (e.g. us-pdx-1, eu-lon-1). If not specified, defaults to the region closest to the user.
	Region *string `json:"region,omitempty"`

	// Runtime Runtime configuration defining how the sandbox VM is provisioned and its resource limits
	Runtime *SandboxRuntime    `json:"runtime,omitempty"`
	Volumes *VolumeAttachments `json:"volumes,omitempty"`
}

// Status Deployment status of a resource deployed on Blaxel
type Status string

// Template Blaxel template
type Template struct {
	// DefaultBranch Default branch of the template
	DefaultBranch *string `json:"defaultBranch,omitempty"`

	// Description Description of the template
	Description *string `json:"description,omitempty"`

	// DownloadCount Number of downloads/clones of the repository
	DownloadCount *int `json:"downloadCount,omitempty"`

	// ForksCount Number of forks the repository has
	ForksCount *int `json:"forksCount,omitempty"`

	// Icon URL to the template's icon
	Icon *string `json:"icon,omitempty"`

	// IconDark URL to the template's icon in dark mode
	IconDark *string `json:"iconDark,omitempty"`

	// Name Name of the template
	Name *string `json:"name,omitempty"`

	// Sha SHA of the variable
	Sha *string `json:"sha,omitempty"`

	// StarCount Number of stars the repository has
	StarCount *int `json:"starCount,omitempty"`

	// Topics Topic of the template
	Topics *[]string `json:"topics,omitempty"`

	// Url URL of the template
	Url *string `json:"url,omitempty"`

	// Variables Variables of the template
	Variables *[]TemplateVariable `json:"variables,omitempty"`
}

// TemplateVariable Blaxel template variable
type TemplateVariable struct {
	// Description Description of the variable
	Description *string `json:"description,omitempty"`

	// Integration Integration of the variable
	Integration *string `json:"integration,omitempty"`

	// Name Name of the variable
	Name *string `json:"name,omitempty"`

	// Path Path of the variable
	Path *string `json:"path,omitempty"`

	// Secret Whether the variable is secret
	Secret *bool `json:"secret,omitempty"`
}

// TimeFields Time fields for Persistance
type TimeFields struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Trigger Trigger configuration
type Trigger struct {
	// Configuration Trigger configuration
	Configuration *TriggerConfiguration `json:"configuration,omitempty"`

	// Enabled Enable or disable the trigger (default: true)
	Enabled *bool `json:"enabled,omitempty"`

	// Id The id of the trigger
	Id *string `json:"id,omitempty"`

	// Type The type of trigger, can be http or http-async
	Type *TriggerType `json:"type,omitempty"`
}

// TriggerType The type of trigger, can be http or http-async
type TriggerType string

// TriggerConfiguration Trigger configuration
type TriggerConfiguration struct {
	// AuthenticationType The authentication type of the trigger
	AuthenticationType *string `json:"authenticationType,omitempty"`

	// CallbackSecret The callback secret for async triggers (auto-generated, encrypted)
	CallbackSecret *string `json:"callbackSecret,omitempty"`

	// CallbackUrl The callback URL for async triggers (optional)
	CallbackUrl *string `json:"callbackUrl,omitempty"`

	// Path The path of the trigger
	Path *string `json:"path,omitempty"`

	// Retry The retry of the trigger
	Retry *int `json:"retry,omitempty"`

	// Schedule The schedule of the trigger, cron expression * * * * *
	Schedule *string `json:"schedule,omitempty"`

	// Tasks The tasks configuration of the cronjob
	Tasks *[]TriggerConfigurationTask `json:"tasks,omitempty"`

	// Timeout The timeout in seconds for async triggers (max 900s, MK3 only)
	Timeout *int `json:"timeout,omitempty"`
}

// TriggerConfigurationTask The tasks configuration of the cronjob
type TriggerConfigurationTask = map[string]interface{}

// Triggers Triggers to use your agent
type Triggers = []Trigger

// Volume Persistent storage volume that can be attached to sandboxes for durable file storage across sessions. Volumes survive sandbox deletion and can be reattached to new sandboxes.
type Volume struct {
	// Events Events happening on a resource deployed on Blaxel
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Immutable volume configuration set at creation time (size and region cannot be changed after creation)
	Spec VolumeSpec `json:"spec"`

	// State Current runtime state of the volume including attachment status
	State *VolumeState `json:"state,omitempty"`

	// Status Volume status computed from events
	Status *string `json:"status,omitempty"`

	// TerminatedAt Timestamp when the volume was marked for termination
	TerminatedAt *string `json:"terminatedAt,omitempty"`
}

// VolumeAttachment Configuration for attaching a volume to a sandbox at a specific filesystem path
type VolumeAttachment struct {
	// MountPath Absolute filesystem path where the volume will be mounted inside the sandbox
	MountPath *string `json:"mountPath,omitempty"`

	// Name Name of the volume resource to attach (must exist in the same workspace and region)
	Name *string `json:"name,omitempty"`

	// ReadOnly If true, the volume is mounted read-only and cannot be modified by the sandbox
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// VolumeAttachments defines model for VolumeAttachments.
type VolumeAttachments = []VolumeAttachment

// VolumeSpec Immutable volume configuration set at creation time (size and region cannot be changed after creation)
type VolumeSpec struct {
	// InfrastructureId The internal infrastructure resource identifier for this volume
	InfrastructureId *string `json:"infrastructureId,omitempty"`

	// Region Deployment region for the volume (e.g., us-pdx-1, eu-lon-1). Must match the region of sandboxes it attaches to.
	Region *string `json:"region,omitempty"`

	// Size Storage capacity in megabytes. Can be increased after creation but not decreased.
	Size *int `json:"size,omitempty"`

	// Template Volume template to initialize from, with optional revision (e.g., "mytemplate:1" or "mytemplate:latest")
	Template *string `json:"template,omitempty"`
}

// VolumeState Current runtime state of the volume including attachment status
type VolumeState struct {
	// AttachedTo Resource currently using this volume in format "type:name" (e.g., "sandbox:my-sandbox"). Empty if not attached.
	AttachedTo *string `json:"attachedTo,omitempty"`
}

// VolumeTemplate Volume template for creating pre-configured volumes
type VolumeTemplate struct {
	// Metadata Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
	Metadata Metadata `json:"metadata"`

	// Spec Volume template specification
	Spec VolumeTemplateSpec `json:"spec"`

	// State Volume template state
	State *VolumeTemplateState `json:"state,omitempty"`

	// Versions List of versions for this template
	Versions *[]VolumeTemplateVersion `json:"versions,omitempty"`
}

// VolumeTemplateSpec Volume template specification
type VolumeTemplateSpec struct {
	// DefaultSize Default size of the volume in MB
	DefaultSize *int `json:"defaultSize,omitempty"`

	// Description Description of the volume template
	Description *string `json:"description,omitempty"`
}

// VolumeTemplateState Volume template state
type VolumeTemplateState struct {
	// LastVersionUploadedAt Timestamp of last version upload
	LastVersionUploadedAt *string `json:"lastVersionUploadedAt,omitempty"`

	// LatestVersion Current/latest S3 version ID
	LatestVersion *string `json:"latestVersion,omitempty"`

	// Status Status of the volume template (created, ready, error)
	Status *VolumeTemplateStateStatus `json:"status,omitempty"`

	// VersionCount Total number of versions for this template
	VersionCount *int `json:"versionCount,omitempty"`
}

// VolumeTemplateStateStatus Status of the volume template (created, ready, error)
type VolumeTemplateStateStatus string

// VolumeTemplateVersion Volume template version tracking individual versions of template content
type VolumeTemplateVersion struct {
	// Bucket S3 bucket name where this version is stored
	Bucket *string `json:"bucket,omitempty"`

	// ContentSize Size of the template content in bytes
	ContentSize *int `json:"contentSize,omitempty"`

	// Name Name of the template version
	Name *string `json:"name,omitempty"`

	// Region AWS region where this version is stored
	Region *string `json:"region,omitempty"`

	// Status Status of the version (CREATED, READY, FAILED)
	Status *VolumeTemplateVersionStatus `json:"status,omitempty"`

	// TemplateName Template name this version belongs to
	TemplateName *string `json:"templateName,omitempty"`

	// VersionId S3 version ID for this template version
	VersionId *string `json:"versionId,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// VolumeTemplateVersionStatus Status of the version (CREATED, READY, FAILED)
type VolumeTemplateVersionStatus string

// Workspace defines model for Workspace.
type Workspace struct {
	// AccountId Workspace account id
	AccountId *string `json:"accountId,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Workspace display name
	DisplayName *string `json:"displayName,omitempty"`

	// Id Autogenerated unique workspace id
	Id *string `json:"id,omitempty"`

	// Labels Key-value pairs for organizing and filtering resources. Labels can be used to categorize resources by environment, project, team, or any custom taxonomy.
	Labels *MetadataLabels `json:"labels,omitempty"`

	// Name Workspace name
	Name *string `json:"name,omitempty"`

	// Region Workspace write region
	Region *string `json:"region,omitempty"`

	// Runtime Runtime configuration for the workspace infrastructure
	Runtime *WorkspaceRuntime `json:"runtime,omitempty"`

	// Status Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
	Status *WorkspaceStatus `json:"status,omitempty"`

	// StatusReason Reason for current status (only set for error status)
	StatusReason *string `json:"statusReason,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// WorkspaceStatus Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
type WorkspaceStatus string

// WorkspaceRuntime Runtime configuration for the workspace infrastructure
type WorkspaceRuntime struct {
	// Generation Infrastructure generation version for the workspace (affects available features and deployment behavior)
	Generation *string `json:"generation,omitempty"`
}

// WorkspaceUser Workspace user
type WorkspaceUser struct {
	// Accepted Whether the user has accepted the workspace invitation
	Accepted *bool `json:"accepted,omitempty"`

	// Email Workspace user email
	Email *string `json:"email,omitempty"`

	// EmailVerified Whether the user's email has been verified
	EmailVerified *bool `json:"email_verified,omitempty"`

	// FamilyName Workspace user family name
	FamilyName *string `json:"family_name,omitempty"`

	// GivenName Workspace user given name
	GivenName *string `json:"given_name,omitempty"`

	// Role Workspace user role
	Role *string `json:"role,omitempty"`

	// Sub Workspace user identifier
	Sub *string `json:"sub,omitempty"`
}

// GetAgentParams defines parameters for GetAgent.
type GetAgentParams struct {
	// ShowSecrets Show secret values (requires workspace admin role)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// GetFunctionParams defines parameters for GetFunction.
type GetFunctionParams struct {
	// ShowSecrets Show secret values (requires workspace admin role)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// GetJobParams defines parameters for GetJob.
type GetJobParams struct {
	// ShowSecrets Show secret values (requires workspace admin role)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// ListJobExecutionsParams defines parameters for ListJobExecutions.
type ListJobExecutionsParams struct {
	// Limit Number of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Page offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPublicIpsParams defines parameters for ListPublicIps.
type ListPublicIpsParams struct {
	// Region Filter by region name (only returns mk3 region data)
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// CreateSandboxParams defines parameters for CreateSandbox.
type CreateSandboxParams struct {
	// CreateIfNotExist If true, return existing sandbox instead of 409 error when sandbox exists and is not in FAILED/TERMINATED/TERMINATING state
	CreateIfNotExist *bool `form:"createIfNotExist,omitempty" json:"createIfNotExist,omitempty"`
}

// GetSandboxParams defines parameters for GetSandbox.
type GetSandboxParams struct {
	// ShowSecrets Show secret values (requires workspace admin role)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// CreateWorkspaceServiceAccountJSONBody defines parameters for CreateWorkspaceServiceAccount.
type CreateWorkspaceServiceAccountJSONBody struct {
	// Description Service account description
	Description *string `json:"description,omitempty"`

	// Name Service account name
	Name string `json:"name"`
}

// UpdateWorkspaceServiceAccountJSONBody defines parameters for UpdateWorkspaceServiceAccount.
type UpdateWorkspaceServiceAccountJSONBody struct {
	// Description Service account description
	Description *string `json:"description,omitempty"`

	// Name Service account name
	Name *string `json:"name,omitempty"`
}

// CreateApiKeyForServiceAccountJSONBody defines parameters for CreateApiKeyForServiceAccount.
type CreateApiKeyForServiceAccountJSONBody struct {
	// ExpiresIn Expiration period for the API key. Supports formats like '30d' (30 days), '24h' (24 hours), '1w' (1 week). If not set, the API key never expires.
	ExpiresIn *string `json:"expires_in,omitempty"`

	// Name Name for the API key
	Name *string `json:"name,omitempty"`
}

// InviteWorkspaceUserJSONBody defines parameters for InviteWorkspaceUser.
type InviteWorkspaceUserJSONBody struct {
	Email *openapi_types.Email `json:"email,omitempty"`
}

// UpdateWorkspaceUserRoleJSONBody defines parameters for UpdateWorkspaceUserRole.
type UpdateWorkspaceUserRoleJSONBody struct {
	// Role The new role to assign to the user
	Role string `json:"role"`
}

// CreateVolumeTemplateParams defines parameters for CreateVolumeTemplate.
type CreateVolumeTemplateParams struct {
	// Upload If true, returns a presigned URL for uploading the template content
	Upload *bool `form:"upload,omitempty" json:"upload,omitempty"`

	// Version Version name for the template version being created
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// UpdateVolumeTemplateParams defines parameters for UpdateVolumeTemplate.
type UpdateVolumeTemplateParams struct {
	// Upload If true, returns a presigned URL for uploading the template content
	Upload *bool `form:"upload,omitempty" json:"upload,omitempty"`

	// Version Version name for the template version being created
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// CheckWorkspaceAvailabilityJSONBody defines parameters for CheckWorkspaceAvailability.
type CheckWorkspaceAvailabilityJSONBody struct {
	Name string `json:"name"`
}

// CreateAgentJSONRequestBody defines body for CreateAgent for application/json ContentType.
type CreateAgentJSONRequestBody = Agent

// UpdateAgentJSONRequestBody defines body for UpdateAgent for application/json ContentType.
type UpdateAgentJSONRequestBody = Agent

// CreateCustomDomainJSONRequestBody defines body for CreateCustomDomain for application/json ContentType.
type CreateCustomDomainJSONRequestBody = CustomDomain

// UpdateCustomDomainJSONRequestBody defines body for UpdateCustomDomain for application/json ContentType.
type UpdateCustomDomainJSONRequestBody = CustomDomain

// CreateFunctionJSONRequestBody defines body for CreateFunction for application/json ContentType.
type CreateFunctionJSONRequestBody = Function

// UpdateFunctionJSONRequestBody defines body for UpdateFunction for application/json ContentType.
type UpdateFunctionJSONRequestBody = Function

// CreateIntegrationConnectionJSONRequestBody defines body for CreateIntegrationConnection for application/json ContentType.
type CreateIntegrationConnectionJSONRequestBody = IntegrationConnection

// UpdateIntegrationConnectionJSONRequestBody defines body for UpdateIntegrationConnection for application/json ContentType.
type UpdateIntegrationConnectionJSONRequestBody = IntegrationConnection

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody = Job

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = Job

// CreateJobExecutionJSONRequestBody defines body for CreateJobExecution for application/json ContentType.
type CreateJobExecutionJSONRequestBody = CreateJobExecutionRequest

// CreateModelJSONRequestBody defines body for CreateModel for application/json ContentType.
type CreateModelJSONRequestBody = Model

// UpdateModelJSONRequestBody defines body for UpdateModel for application/json ContentType.
type UpdateModelJSONRequestBody = Model

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = Policy

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = Policy

// CreateSandboxJSONRequestBody defines body for CreateSandbox for application/json ContentType.
type CreateSandboxJSONRequestBody = Sandbox

// UpdateSandboxJSONRequestBody defines body for UpdateSandbox for application/json ContentType.
type UpdateSandboxJSONRequestBody = Sandbox

// CreateSandboxPreviewJSONRequestBody defines body for CreateSandboxPreview for application/json ContentType.
type CreateSandboxPreviewJSONRequestBody = Preview

// UpdateSandboxPreviewJSONRequestBody defines body for UpdateSandboxPreview for application/json ContentType.
type UpdateSandboxPreviewJSONRequestBody = Preview

// CreateSandboxPreviewTokenJSONRequestBody defines body for CreateSandboxPreviewToken for application/json ContentType.
type CreateSandboxPreviewTokenJSONRequestBody = PreviewToken

// CreateWorkspaceServiceAccountJSONRequestBody defines body for CreateWorkspaceServiceAccount for application/json ContentType.
type CreateWorkspaceServiceAccountJSONRequestBody CreateWorkspaceServiceAccountJSONBody

// UpdateWorkspaceServiceAccountJSONRequestBody defines body for UpdateWorkspaceServiceAccount for application/json ContentType.
type UpdateWorkspaceServiceAccountJSONRequestBody UpdateWorkspaceServiceAccountJSONBody

// CreateApiKeyForServiceAccountJSONRequestBody defines body for CreateApiKeyForServiceAccount for application/json ContentType.
type CreateApiKeyForServiceAccountJSONRequestBody CreateApiKeyForServiceAccountJSONBody

// InviteWorkspaceUserJSONRequestBody defines body for InviteWorkspaceUser for application/json ContentType.
type InviteWorkspaceUserJSONRequestBody InviteWorkspaceUserJSONBody

// UpdateWorkspaceUserRoleJSONRequestBody defines body for UpdateWorkspaceUserRole for application/json ContentType.
type UpdateWorkspaceUserRoleJSONRequestBody UpdateWorkspaceUserRoleJSONBody

// CreateVolumeTemplateJSONRequestBody defines body for CreateVolumeTemplate for application/json ContentType.
type CreateVolumeTemplateJSONRequestBody = VolumeTemplate

// UpdateVolumeTemplateJSONRequestBody defines body for UpdateVolumeTemplate for application/json ContentType.
type UpdateVolumeTemplateJSONRequestBody = VolumeTemplate

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = Volume

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody = Volume

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = Workspace

// CheckWorkspaceAvailabilityJSONRequestBody defines body for CheckWorkspaceAvailability for application/json ContentType.
type CheckWorkspaceAvailabilityJSONRequestBody CheckWorkspaceAvailabilityJSONBody

// UpdateWorkspaceJSONRequestBody defines body for UpdateWorkspace for application/json ContentType.
type UpdateWorkspaceJSONRequestBody = Workspace

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	RunServer string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, runServer string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server:    server,
		RunServer: runServer,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	Run(
		ctx context.Context,
		workspaceName string,
		resourceType string,
		resourceName string,
		method string,
		path string,
		headers map[string]string,
		params []string,
		body string,
		debug bool,
		local bool,
		reqEditors ...RequestEditorFn,
	) (*http.Response, error)

	// ListAgents request
	ListAgents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentWithBody request with any body
	CreateAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgent(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAgent request
	DeleteAgent(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgent request
	GetAgent(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAgentWithBody request with any body
	UpdateAgentWithBody(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAgent(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAgentRevisions request
	ListAgentRevisions(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfiguration request
	GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomDomains request
	ListCustomDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomDomainWithBody request with any body
	CreateCustomDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomDomain(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomDomain request
	DeleteCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomDomain request
	GetCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomDomainWithBody request with any body
	UpdateCustomDomainWithBody(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomDomain(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyCustomDomain request
	VerifyCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctions request
	ListFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFunctionWithBody request with any body
	CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFunction request
	DeleteFunction(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunction request
	GetFunction(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFunctionWithBody request with any body
	UpdateFunctionWithBody(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFunction(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctionRevisions request
	ListFunctionRevisions(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CleanupImages request
	CleanupImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListImages request
	ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImage request
	GetImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImageTag request
	DeleteImageTag(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConnections request
	ListIntegrationConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIntegrationConnectionWithBody request with any body
	CreateIntegrationConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIntegrationConnection(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIntegrationConnection request
	DeleteIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnection request
	GetIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIntegrationConnectionWithBody request with any body
	UpdateIntegrationConnectionWithBody(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIntegrationConnection(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnectionModelEndpointConfigurations request
	GetIntegrationConnectionModelEndpointConfigurations(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConnectionModels request
	ListIntegrationConnectionModels(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnectionModel request
	GetIntegrationConnectionModel(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegration request
	GetIntegration(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobWithBody request with any body
	CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJob request
	DeleteJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobWithBody request with any body
	UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJob(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobExecutions request
	ListJobExecutions(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobExecutionWithBody request with any body
	CreateJobExecutionWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJobExecution(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJobExecution request
	DeleteJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobExecution request
	GetJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobRevisions request
	ListJobRevisions(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLocations request
	ListLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMCPHubDefinitions request
	ListMCPHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModels request
	ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModelWithBody request with any body
	CreateModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModel(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModel request
	DeleteModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModel request
	GetModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateModelWithBody request with any body
	UpdateModelWithBody(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateModel(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModelRevisions request
	ListModelRevisions(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPublicIps request
	ListPublicIps(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxHubDefinitions request
	ListSandboxHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxes request
	ListSandboxes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxWithBody request with any body
	CreateSandboxWithBody(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandbox(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandbox request
	DeleteSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandbox request
	GetSandbox(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSandboxWithBody request with any body
	UpdateSandboxWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSandbox(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxPreviews request
	ListSandboxPreviews(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxPreviewWithBody request with any body
	CreateSandboxPreviewWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandboxPreview(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxPreview request
	DeleteSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxPreview request
	GetSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSandboxPreviewWithBody request with any body
	UpdateSandboxPreviewWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSandboxPreview(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxPreviewTokens request
	ListSandboxPreviewTokens(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxPreviewTokenWithBody request with any body
	CreateSandboxPreviewTokenWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxPreviewToken request
	DeleteSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceServiceAccounts request
	GetWorkspaceServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceServiceAccountWithBody request with any body
	CreateWorkspaceServiceAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspaceServiceAccount(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspaceServiceAccount request
	DeleteWorkspaceServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceServiceAccountWithBody request with any body
	UpdateWorkspaceServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspaceServiceAccount(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiKeysForServiceAccount request
	ListApiKeysForServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyForServiceAccountWithBody request with any body
	CreateApiKeyForServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKeyForServiceAccount(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKeyForServiceAccount request
	DeleteApiKeyForServiceAccount(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTemplates request
	ListTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplate request
	GetTemplate(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceUsers request
	ListWorkspaceUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteWorkspaceUserWithBody request with any body
	InviteWorkspaceUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteWorkspaceUser(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveWorkspaceUser request
	RemoveWorkspaceUser(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceUserRoleWithBody request with any body
	UpdateWorkspaceUserRoleWithBody(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspaceUserRole(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVolumeTemplates request
	ListVolumeTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeTemplateWithBody request with any body
	CreateVolumeTemplateWithBody(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolumeTemplate(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeTemplate request
	DeleteVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVolumeTemplate request
	GetVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeTemplateWithBody request with any body
	UpdateVolumeTemplateWithBody(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolumeTemplate(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeTemplateVersion request
	DeleteVolumeTemplateVersion(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVolumes request
	ListVolumes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVolume request
	GetVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeWithBody request with any body
	UpdateVolumeWithBody(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceWithBody request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckWorkspaceAvailabilityWithBody request with any body
	CheckWorkspaceAvailabilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckWorkspaceAvailability(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspace request
	GetWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceWithBody request with any body
	UpdateWorkspaceWithBody(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspace(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineWorkspaceInvitation request
	DeclineWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptWorkspaceInvitation request
	AcceptWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveWorkspace request
	LeaveWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// RegisterCliCommands registers CLI commands for the client
func (c *ClientWithResponses) RegisterCliCommands(reg register.Register, ctx context.Context) {

	// Register CLI commands for ListAgents
	reg.CliCommand(ctx, "ListAgents", c.ListAgents)

	// Register CLI commands for CreateAgent
	reg.CliCommand(ctx, "CreateAgent", c.CreateAgent)

	// Register CLI commands for DeleteAgent
	reg.CliCommand(ctx, "DeleteAgent", c.DeleteAgent)

	// Register CLI commands for GetAgent
	reg.CliCommand(ctx, "GetAgent", c.GetAgent)

	// Register CLI commands for UpdateAgent
	reg.CliCommand(ctx, "UpdateAgent", c.UpdateAgent)

	// Register CLI commands for ListAgentRevisions
	reg.CliCommand(ctx, "ListAgentRevisions", c.ListAgentRevisions)

	// Register CLI commands for GetConfiguration
	reg.CliCommand(ctx, "GetConfiguration", c.GetConfiguration)

	// Register CLI commands for ListCustomDomains
	reg.CliCommand(ctx, "ListCustomDomains", c.ListCustomDomains)

	// Register CLI commands for CreateCustomDomain
	reg.CliCommand(ctx, "CreateCustomDomain", c.CreateCustomDomain)

	// Register CLI commands for DeleteCustomDomain
	reg.CliCommand(ctx, "DeleteCustomDomain", c.DeleteCustomDomain)

	// Register CLI commands for GetCustomDomain
	reg.CliCommand(ctx, "GetCustomDomain", c.GetCustomDomain)

	// Register CLI commands for UpdateCustomDomain
	reg.CliCommand(ctx, "UpdateCustomDomain", c.UpdateCustomDomain)

	// Register CLI commands for VerifyCustomDomain
	reg.CliCommand(ctx, "VerifyCustomDomain", c.VerifyCustomDomain)

	// Register CLI commands for ListFunctions
	reg.CliCommand(ctx, "ListFunctions", c.ListFunctions)

	// Register CLI commands for CreateFunction
	reg.CliCommand(ctx, "CreateFunction", c.CreateFunction)

	// Register CLI commands for DeleteFunction
	reg.CliCommand(ctx, "DeleteFunction", c.DeleteFunction)

	// Register CLI commands for GetFunction
	reg.CliCommand(ctx, "GetFunction", c.GetFunction)

	// Register CLI commands for UpdateFunction
	reg.CliCommand(ctx, "UpdateFunction", c.UpdateFunction)

	// Register CLI commands for ListFunctionRevisions
	reg.CliCommand(ctx, "ListFunctionRevisions", c.ListFunctionRevisions)

	// Register CLI commands for CleanupImages
	reg.CliCommand(ctx, "CleanupImages", c.CleanupImages)

	// Register CLI commands for ListImages
	reg.CliCommand(ctx, "ListImages", c.ListImages)

	// Register CLI commands for DeleteImage
	reg.CliCommand(ctx, "DeleteImage", c.DeleteImage)

	// Register CLI commands for GetImage
	reg.CliCommand(ctx, "GetImage", c.GetImage)

	// Register CLI commands for DeleteImageTag
	reg.CliCommand(ctx, "DeleteImageTag", c.DeleteImageTag)

	// Register CLI commands for ListIntegrationConnections
	reg.CliCommand(ctx, "ListIntegrationConnections", c.ListIntegrationConnections)

	// Register CLI commands for CreateIntegrationConnection
	reg.CliCommand(ctx, "CreateIntegrationConnection", c.CreateIntegrationConnection)

	// Register CLI commands for DeleteIntegrationConnection
	reg.CliCommand(ctx, "DeleteIntegrationConnection", c.DeleteIntegrationConnection)

	// Register CLI commands for GetIntegrationConnection
	reg.CliCommand(ctx, "GetIntegrationConnection", c.GetIntegrationConnection)

	// Register CLI commands for UpdateIntegrationConnection
	reg.CliCommand(ctx, "UpdateIntegrationConnection", c.UpdateIntegrationConnection)

	// Register CLI commands for GetIntegrationConnectionModelEndpointConfigurations
	reg.CliCommand(ctx, "GetIntegrationConnectionModelEndpointConfigurations", c.GetIntegrationConnectionModelEndpointConfigurations)

	// Register CLI commands for ListIntegrationConnectionModels
	reg.CliCommand(ctx, "ListIntegrationConnectionModels", c.ListIntegrationConnectionModels)

	// Register CLI commands for GetIntegrationConnectionModel
	reg.CliCommand(ctx, "GetIntegrationConnectionModel", c.GetIntegrationConnectionModel)

	// Register CLI commands for GetIntegration
	reg.CliCommand(ctx, "GetIntegration", c.GetIntegration)

	// Register CLI commands for ListJobs
	reg.CliCommand(ctx, "ListJobs", c.ListJobs)

	// Register CLI commands for CreateJob
	reg.CliCommand(ctx, "CreateJob", c.CreateJob)

	// Register CLI commands for DeleteJob
	reg.CliCommand(ctx, "DeleteJob", c.DeleteJob)

	// Register CLI commands for GetJob
	reg.CliCommand(ctx, "GetJob", c.GetJob)

	// Register CLI commands for UpdateJob
	reg.CliCommand(ctx, "UpdateJob", c.UpdateJob)

	// Register CLI commands for ListJobExecutions
	reg.CliCommand(ctx, "ListJobExecutions", c.ListJobExecutions)

	// Register CLI commands for CreateJobExecution
	reg.CliCommand(ctx, "CreateJobExecution", c.CreateJobExecution)

	// Register CLI commands for DeleteJobExecution
	reg.CliCommand(ctx, "DeleteJobExecution", c.DeleteJobExecution)

	// Register CLI commands for GetJobExecution
	reg.CliCommand(ctx, "GetJobExecution", c.GetJobExecution)

	// Register CLI commands for ListJobRevisions
	reg.CliCommand(ctx, "ListJobRevisions", c.ListJobRevisions)

	// Register CLI commands for ListLocations
	reg.CliCommand(ctx, "ListLocations", c.ListLocations)

	// Register CLI commands for ListMCPHubDefinitions
	reg.CliCommand(ctx, "ListMCPHubDefinitions", c.ListMCPHubDefinitions)

	// Register CLI commands for ListModels
	reg.CliCommand(ctx, "ListModels", c.ListModels)

	// Register CLI commands for CreateModel
	reg.CliCommand(ctx, "CreateModel", c.CreateModel)

	// Register CLI commands for DeleteModel
	reg.CliCommand(ctx, "DeleteModel", c.DeleteModel)

	// Register CLI commands for GetModel
	reg.CliCommand(ctx, "GetModel", c.GetModel)

	// Register CLI commands for UpdateModel
	reg.CliCommand(ctx, "UpdateModel", c.UpdateModel)

	// Register CLI commands for ListModelRevisions
	reg.CliCommand(ctx, "ListModelRevisions", c.ListModelRevisions)

	// Register CLI commands for ListPolicies
	reg.CliCommand(ctx, "ListPolicies", c.ListPolicies)

	// Register CLI commands for CreatePolicy
	reg.CliCommand(ctx, "CreatePolicy", c.CreatePolicy)

	// Register CLI commands for DeletePolicy
	reg.CliCommand(ctx, "DeletePolicy", c.DeletePolicy)

	// Register CLI commands for GetPolicy
	reg.CliCommand(ctx, "GetPolicy", c.GetPolicy)

	// Register CLI commands for UpdatePolicy
	reg.CliCommand(ctx, "UpdatePolicy", c.UpdatePolicy)

	// Register CLI commands for ListPublicIps
	reg.CliCommand(ctx, "ListPublicIps", c.ListPublicIps)

	// Register CLI commands for ListSandboxHubDefinitions
	reg.CliCommand(ctx, "ListSandboxHubDefinitions", c.ListSandboxHubDefinitions)

	// Register CLI commands for ListSandboxes
	reg.CliCommand(ctx, "ListSandboxes", c.ListSandboxes)

	// Register CLI commands for CreateSandbox
	reg.CliCommand(ctx, "CreateSandbox", c.CreateSandbox)

	// Register CLI commands for DeleteSandbox
	reg.CliCommand(ctx, "DeleteSandbox", c.DeleteSandbox)

	// Register CLI commands for GetSandbox
	reg.CliCommand(ctx, "GetSandbox", c.GetSandbox)

	// Register CLI commands for UpdateSandbox
	reg.CliCommand(ctx, "UpdateSandbox", c.UpdateSandbox)

	// Register CLI commands for ListSandboxPreviews
	reg.CliCommand(ctx, "ListSandboxPreviews", c.ListSandboxPreviews)

	// Register CLI commands for CreateSandboxPreview
	reg.CliCommand(ctx, "CreateSandboxPreview", c.CreateSandboxPreview)

	// Register CLI commands for DeleteSandboxPreview
	reg.CliCommand(ctx, "DeleteSandboxPreview", c.DeleteSandboxPreview)

	// Register CLI commands for GetSandboxPreview
	reg.CliCommand(ctx, "GetSandboxPreview", c.GetSandboxPreview)

	// Register CLI commands for UpdateSandboxPreview
	reg.CliCommand(ctx, "UpdateSandboxPreview", c.UpdateSandboxPreview)

	// Register CLI commands for ListSandboxPreviewTokens
	reg.CliCommand(ctx, "ListSandboxPreviewTokens", c.ListSandboxPreviewTokens)

	// Register CLI commands for CreateSandboxPreviewToken
	reg.CliCommand(ctx, "CreateSandboxPreviewToken", c.CreateSandboxPreviewToken)

	// Register CLI commands for DeleteSandboxPreviewToken
	reg.CliCommand(ctx, "DeleteSandboxPreviewToken", c.DeleteSandboxPreviewToken)

	// Register CLI commands for GetWorkspaceServiceAccounts
	reg.CliCommand(ctx, "GetWorkspaceServiceAccounts", c.GetWorkspaceServiceAccounts)

	// Register CLI commands for CreateWorkspaceServiceAccount
	reg.CliCommand(ctx, "CreateWorkspaceServiceAccount", c.CreateWorkspaceServiceAccount)

	// Register CLI commands for DeleteWorkspaceServiceAccount
	reg.CliCommand(ctx, "DeleteWorkspaceServiceAccount", c.DeleteWorkspaceServiceAccount)

	// Register CLI commands for UpdateWorkspaceServiceAccount
	reg.CliCommand(ctx, "UpdateWorkspaceServiceAccount", c.UpdateWorkspaceServiceAccount)

	// Register CLI commands for ListApiKeysForServiceAccount
	reg.CliCommand(ctx, "ListApiKeysForServiceAccount", c.ListApiKeysForServiceAccount)

	// Register CLI commands for CreateApiKeyForServiceAccount
	reg.CliCommand(ctx, "CreateApiKeyForServiceAccount", c.CreateApiKeyForServiceAccount)

	// Register CLI commands for DeleteApiKeyForServiceAccount
	reg.CliCommand(ctx, "DeleteApiKeyForServiceAccount", c.DeleteApiKeyForServiceAccount)

	// Register CLI commands for ListTemplates
	reg.CliCommand(ctx, "ListTemplates", c.ListTemplates)

	// Register CLI commands for GetTemplate
	reg.CliCommand(ctx, "GetTemplate", c.GetTemplate)

	// Register CLI commands for ListWorkspaceUsers
	reg.CliCommand(ctx, "ListWorkspaceUsers", c.ListWorkspaceUsers)

	// Register CLI commands for InviteWorkspaceUser
	reg.CliCommand(ctx, "InviteWorkspaceUser", c.InviteWorkspaceUser)

	// Register CLI commands for RemoveWorkspaceUser
	reg.CliCommand(ctx, "RemoveWorkspaceUser", c.RemoveWorkspaceUser)

	// Register CLI commands for UpdateWorkspaceUserRole
	reg.CliCommand(ctx, "UpdateWorkspaceUserRole", c.UpdateWorkspaceUserRole)

	// Register CLI commands for ListVolumeTemplates
	reg.CliCommand(ctx, "ListVolumeTemplates", c.ListVolumeTemplates)

	// Register CLI commands for CreateVolumeTemplate
	reg.CliCommand(ctx, "CreateVolumeTemplate", c.CreateVolumeTemplate)

	// Register CLI commands for DeleteVolumeTemplate
	reg.CliCommand(ctx, "DeleteVolumeTemplate", c.DeleteVolumeTemplate)

	// Register CLI commands for GetVolumeTemplate
	reg.CliCommand(ctx, "GetVolumeTemplate", c.GetVolumeTemplate)

	// Register CLI commands for UpdateVolumeTemplate
	reg.CliCommand(ctx, "UpdateVolumeTemplate", c.UpdateVolumeTemplate)

	// Register CLI commands for DeleteVolumeTemplateVersion
	reg.CliCommand(ctx, "DeleteVolumeTemplateVersion", c.DeleteVolumeTemplateVersion)

	// Register CLI commands for ListVolumes
	reg.CliCommand(ctx, "ListVolumes", c.ListVolumes)

	// Register CLI commands for CreateVolume
	reg.CliCommand(ctx, "CreateVolume", c.CreateVolume)

	// Register CLI commands for DeleteVolume
	reg.CliCommand(ctx, "DeleteVolume", c.DeleteVolume)

	// Register CLI commands for GetVolume
	reg.CliCommand(ctx, "GetVolume", c.GetVolume)

	// Register CLI commands for UpdateVolume
	reg.CliCommand(ctx, "UpdateVolume", c.UpdateVolume)

	// Register CLI commands for ListWorkspaces
	reg.CliCommand(ctx, "ListWorkspaces", c.ListWorkspaces)

	// Register CLI commands for CreateWorkspace
	reg.CliCommand(ctx, "CreateWorkspace", c.CreateWorkspace)

	// Register CLI commands for CheckWorkspaceAvailability
	reg.CliCommand(ctx, "CheckWorkspaceAvailability", c.CheckWorkspaceAvailability)

	// Register CLI commands for DeleteWorkspace
	reg.CliCommand(ctx, "DeleteWorkspace", c.DeleteWorkspace)

	// Register CLI commands for GetWorkspace
	reg.CliCommand(ctx, "GetWorkspace", c.GetWorkspace)

	// Register CLI commands for UpdateWorkspace
	reg.CliCommand(ctx, "UpdateWorkspace", c.UpdateWorkspace)

	// Register CLI commands for DeclineWorkspaceInvitation
	reg.CliCommand(ctx, "DeclineWorkspaceInvitation", c.DeclineWorkspaceInvitation)

	// Register CLI commands for AcceptWorkspaceInvitation
	reg.CliCommand(ctx, "AcceptWorkspaceInvitation", c.AcceptWorkspaceInvitation)

	// Register CLI commands for LeaveWorkspace
	reg.CliCommand(ctx, "LeaveWorkspace", c.LeaveWorkspace)

}

func (c *Client) ListAgents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgent(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgent(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentRequest(c.Server, agentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgent(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentRequest(c.Server, agentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentWithBody(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentRequestWithBody(c.Server, agentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgent(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentRequest(c.Server, agentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAgentRevisions(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentRevisionsRequest(c.Server, agentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomDomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomDomain(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomDomainWithBody(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomDomainRequestWithBody(c.Server, domainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomDomain(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomDomainRequest(c.Server, domainName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFunction(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFunctionRequest(c.Server, functionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunction(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionRequest(c.Server, functionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunctionWithBody(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequestWithBody(c.Server, functionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunction(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequest(c.Server, functionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctionRevisions(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionRevisionsRequest(c.Server, functionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CleanupImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCleanupImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, resourceType, imageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageRequest(c.Server, resourceType, imageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImageTag(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageTagRequest(c.Server, resourceType, imageName, tagName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConnectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationConnection(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIntegrationConnectionRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationConnectionWithBody(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationConnectionRequestWithBody(c.Server, connectionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationConnection(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationConnectionRequest(c.Server, connectionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnectionModelEndpointConfigurations(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionModelEndpointConfigurationsRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConnectionModels(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConnectionModelsRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnectionModel(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionModelRequest(c.Server, connectionName, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegration(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationRequest(c.Server, integrationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJob(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobExecutions(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobExecutionsRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobExecutionWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobExecutionRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobExecution(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobExecutionRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobExecutionRequest(c.Server, jobId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobExecutionRequest(c.Server, jobId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobRevisions(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobRevisionsRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLocationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMCPHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMCPHubDefinitionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModel(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModelRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModelWithBody(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelRequestWithBody(c.Server, modelName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModel(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelRequest(c.Server, modelName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModelRevisions(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelRevisionsRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPublicIps(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPublicIpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxHubDefinitionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxWithBody(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandbox(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandbox(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxRequest(c.Server, sandboxName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxRequestWithBody(c.Server, sandboxName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandbox(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxRequest(c.Server, sandboxName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxPreviews(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxPreviewsRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewRequestWithBody(c.Server, sandboxName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreview(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewRequest(c.Server, sandboxName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxPreviewRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxPreviewRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxPreviewWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxPreviewRequestWithBody(c.Server, sandboxName, previewName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxPreview(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxPreviewRequest(c.Server, sandboxName, previewName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxPreviewTokens(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxPreviewTokensRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewTokenWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewTokenRequestWithBody(c.Server, sandboxName, previewName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewTokenRequest(c.Server, sandboxName, previewName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxPreviewTokenRequest(c.Server, sandboxName, previewName, tokenName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceServiceAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceServiceAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceServiceAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceServiceAccount(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceServiceAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspaceServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceServiceAccountRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceServiceAccountRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceServiceAccount(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceServiceAccountRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiKeysForServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysForServiceAccountRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyForServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyForServiceAccountRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyForServiceAccount(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyForServiceAccountRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKeyForServiceAccount(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeyForServiceAccountRequest(c.Server, clientId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplate(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateRequest(c.Server, templateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteWorkspaceUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteWorkspaceUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteWorkspaceUser(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteWorkspaceUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveWorkspaceUser(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveWorkspaceUserRequest(c.Server, subOrEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceUserRoleWithBody(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceUserRoleRequestWithBody(c.Server, subOrEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceUserRole(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceUserRoleRequest(c.Server, subOrEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVolumeTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVolumeTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeTemplateWithBody(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeTemplateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeTemplate(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeTemplateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeTemplateRequest(c.Server, volumeTemplateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVolumeTemplateRequest(c.Server, volumeTemplateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeTemplateWithBody(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeTemplateRequestWithBody(c.Server, volumeTemplateName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeTemplate(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeTemplateRequest(c.Server, volumeTemplateName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeTemplateVersion(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeTemplateVersionRequest(c.Server, volumeTemplateName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVolumes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVolumesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, volumeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVolumeRequest(c.Server, volumeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, volumeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, volumeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckWorkspaceAvailabilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckWorkspaceAvailabilityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckWorkspaceAvailability(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckWorkspaceAvailabilityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceWithBody(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequestWithBody(c.Server, workspaceName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspace(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequest(c.Server, workspaceName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineWorkspaceInvitationRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptWorkspaceInvitationRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAgentsRequest generates requests for ListAgents
func NewListAgentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentRequest calls the generic CreateAgent builder with application/json body
func NewCreateAgentRequest(server string, body CreateAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentRequestWithBody generates requests for CreateAgent with any type of body
func NewCreateAgentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAgentRequest generates requests for DeleteAgent
func NewDeleteAgentRequest(server string, agentName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAgentRequest generates requests for GetAgent
func NewGetAgentRequest(server string, agentName string, params *GetAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAgentRequest calls the generic UpdateAgent builder with application/json body
func NewUpdateAgentRequest(server string, agentName string, body UpdateAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAgentRequestWithBody(server, agentName, "application/json", bodyReader)
}

// NewUpdateAgentRequestWithBody generates requests for UpdateAgent with any type of body
func NewUpdateAgentRequestWithBody(server string, agentName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAgentRevisionsRequest generates requests for ListAgentRevisions
func NewListAgentRevisionsRequest(server string, agentName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationRequest generates requests for GetConfiguration
func NewGetConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomDomainsRequest generates requests for ListCustomDomains
func NewListCustomDomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomDomainRequest calls the generic CreateCustomDomain builder with application/json body
func NewCreateCustomDomainRequest(server string, body CreateCustomDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomDomainRequestWithBody generates requests for CreateCustomDomain with any type of body
func NewCreateCustomDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomDomainRequest generates requests for DeleteCustomDomain
func NewDeleteCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomDomainRequest generates requests for GetCustomDomain
func NewGetCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomDomainRequest calls the generic UpdateCustomDomain builder with application/json body
func NewUpdateCustomDomainRequest(server string, domainName string, body UpdateCustomDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomDomainRequestWithBody(server, domainName, "application/json", bodyReader)
}

// NewUpdateCustomDomainRequestWithBody generates requests for UpdateCustomDomain with any type of body
func NewUpdateCustomDomainRequestWithBody(server string, domainName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyCustomDomainRequest generates requests for VerifyCustomDomain
func NewVerifyCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s/verify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFunctionsRequest generates requests for ListFunctions
func NewListFunctionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFunctionRequest calls the generic CreateFunction builder with application/json body
func NewCreateFunctionRequest(server string, body CreateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFunctionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFunctionRequestWithBody generates requests for CreateFunction with any type of body
func NewCreateFunctionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFunctionRequest generates requests for DeleteFunction
func NewDeleteFunctionRequest(server string, functionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFunctionRequest generates requests for GetFunction
func NewGetFunctionRequest(server string, functionName string, params *GetFunctionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFunctionRequest calls the generic UpdateFunction builder with application/json body
func NewUpdateFunctionRequest(server string, functionName string, body UpdateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFunctionRequestWithBody(server, functionName, "application/json", bodyReader)
}

// NewUpdateFunctionRequestWithBody generates requests for UpdateFunction with any type of body
func NewUpdateFunctionRequestWithBody(server string, functionName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFunctionRevisionsRequest generates requests for ListFunctionRevisions
func NewListFunctionRevisionsRequest(server string, functionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCleanupImagesRequest generates requests for CleanupImages
func NewCleanupImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListImagesRequest generates requests for ListImages
func NewListImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, resourceType string, imageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImageRequest generates requests for GetImage
func NewGetImageRequest(server string, resourceType string, imageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImageTagRequest generates requests for DeleteImageTag
func NewDeleteImageTagRequest(server string, resourceType string, imageName string, tagName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tagName", runtime.ParamLocationPath, tagName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s/tags/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationConnectionsRequest generates requests for ListIntegrationConnections
func NewListIntegrationConnectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIntegrationConnectionRequest calls the generic CreateIntegrationConnection builder with application/json body
func NewCreateIntegrationConnectionRequest(server string, body CreateIntegrationConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIntegrationConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIntegrationConnectionRequestWithBody generates requests for CreateIntegrationConnection with any type of body
func NewCreateIntegrationConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIntegrationConnectionRequest generates requests for DeleteIntegrationConnection
func NewDeleteIntegrationConnectionRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConnectionRequest generates requests for GetIntegrationConnection
func NewGetIntegrationConnectionRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIntegrationConnectionRequest calls the generic UpdateIntegrationConnection builder with application/json body
func NewUpdateIntegrationConnectionRequest(server string, connectionName string, body UpdateIntegrationConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIntegrationConnectionRequestWithBody(server, connectionName, "application/json", bodyReader)
}

// NewUpdateIntegrationConnectionRequestWithBody generates requests for UpdateIntegrationConnection with any type of body
func NewUpdateIntegrationConnectionRequestWithBody(server string, connectionName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIntegrationConnectionModelEndpointConfigurationsRequest generates requests for GetIntegrationConnectionModelEndpointConfigurations
func NewGetIntegrationConnectionModelEndpointConfigurationsRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/endpointConfigurations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationConnectionModelsRequest generates requests for ListIntegrationConnectionModels
func NewListIntegrationConnectionModelsRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConnectionModelRequest generates requests for GetIntegrationConnectionModel
func NewGetIntegrationConnectionModelRequest(server string, connectionName string, modelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationRequest generates requests for GetIntegration
func NewGetIntegrationRequest(server string, integrationName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationName", runtime.ParamLocationPath, integrationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobRequest calls the generic CreateJob builder with application/json body
func NewCreateJobRequest(server string, body CreateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateJobRequestWithBody generates requests for CreateJob with any type of body
func NewCreateJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobRequest generates requests for DeleteJob
func NewDeleteJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, jobId string, params *GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJobRequest calls the generic UpdateJob builder with application/json body
func NewUpdateJobRequest(server string, jobId string, body UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewUpdateJobRequestWithBody generates requests for UpdateJob with any type of body
func NewUpdateJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListJobExecutionsRequest generates requests for ListJobExecutions
func NewListJobExecutionsRequest(server string, jobId string, params *ListJobExecutionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobExecutionRequest calls the generic CreateJobExecution builder with application/json body
func NewCreateJobExecutionRequest(server string, jobId string, body CreateJobExecutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobExecutionRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewCreateJobExecutionRequestWithBody generates requests for CreateJobExecution with any type of body
func NewCreateJobExecutionRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobExecutionRequest generates requests for DeleteJobExecution
func NewDeleteJobExecutionRequest(server string, jobId string, executionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobExecutionRequest generates requests for GetJobExecution
func NewGetJobExecutionRequest(server string, jobId string, executionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobRevisionsRequest generates requests for ListJobRevisions
func NewListJobRevisionsRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLocationsRequest generates requests for ListLocations
func NewListLocationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMCPHubDefinitionsRequest generates requests for ListMCPHubDefinitions
func NewListMCPHubDefinitionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mcp/hub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListModelsRequest generates requests for ListModels
func NewListModelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModelRequest calls the generic CreateModel builder with application/json body
func NewCreateModelRequest(server string, body CreateModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateModelRequestWithBody generates requests for CreateModel with any type of body
func NewCreateModelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModelRequest generates requests for DeleteModel
func NewDeleteModelRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModelRequest generates requests for GetModel
func NewGetModelRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateModelRequest calls the generic UpdateModel builder with application/json body
func NewUpdateModelRequest(server string, modelName string, body UpdateModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateModelRequestWithBody(server, modelName, "application/json", bodyReader)
}

// NewUpdateModelRequestWithBody generates requests for UpdateModel with any type of body
func NewUpdateModelRequestWithBody(server string, modelName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModelRevisionsRequest generates requests for ListModelRevisions
func NewListModelRevisionsRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyName string, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyName, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPublicIpsRequest generates requests for ListPublicIps
func NewListPublicIpsRequest(server string, params *ListPublicIpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxHubDefinitionsRequest generates requests for ListSandboxHubDefinitions
func NewListSandboxHubDefinitionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/hub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxesRequest generates requests for ListSandboxes
func NewListSandboxesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxRequest calls the generic CreateSandbox builder with application/json body
func NewCreateSandboxRequest(server string, params *CreateSandboxParams, body CreateSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSandboxRequestWithBody generates requests for CreateSandbox with any type of body
func NewCreateSandboxRequestWithBody(server string, params *CreateSandboxParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreateIfNotExist != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createIfNotExist", runtime.ParamLocationQuery, *params.CreateIfNotExist); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxRequest generates requests for DeleteSandbox
func NewDeleteSandboxRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxRequest generates requests for GetSandbox
func NewGetSandboxRequest(server string, sandboxName string, params *GetSandboxParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSandboxRequest calls the generic UpdateSandbox builder with application/json body
func NewUpdateSandboxRequest(server string, sandboxName string, body UpdateSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSandboxRequestWithBody(server, sandboxName, "application/json", bodyReader)
}

// NewUpdateSandboxRequestWithBody generates requests for UpdateSandbox with any type of body
func NewUpdateSandboxRequestWithBody(server string, sandboxName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSandboxPreviewsRequest generates requests for ListSandboxPreviews
func NewListSandboxPreviewsRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxPreviewRequest calls the generic CreateSandboxPreview builder with application/json body
func NewCreateSandboxPreviewRequest(server string, sandboxName string, body CreateSandboxPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxPreviewRequestWithBody(server, sandboxName, "application/json", bodyReader)
}

// NewCreateSandboxPreviewRequestWithBody generates requests for CreateSandboxPreview with any type of body
func NewCreateSandboxPreviewRequestWithBody(server string, sandboxName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxPreviewRequest generates requests for DeleteSandboxPreview
func NewDeleteSandboxPreviewRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxPreviewRequest generates requests for GetSandboxPreview
func NewGetSandboxPreviewRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSandboxPreviewRequest calls the generic UpdateSandboxPreview builder with application/json body
func NewUpdateSandboxPreviewRequest(server string, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSandboxPreviewRequestWithBody(server, sandboxName, previewName, "application/json", bodyReader)
}

// NewUpdateSandboxPreviewRequestWithBody generates requests for UpdateSandboxPreview with any type of body
func NewUpdateSandboxPreviewRequestWithBody(server string, sandboxName string, previewName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSandboxPreviewTokensRequest generates requests for ListSandboxPreviewTokens
func NewListSandboxPreviewTokensRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxPreviewTokenRequest calls the generic CreateSandboxPreviewToken builder with application/json body
func NewCreateSandboxPreviewTokenRequest(server string, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxPreviewTokenRequestWithBody(server, sandboxName, previewName, "application/json", bodyReader)
}

// NewCreateSandboxPreviewTokenRequestWithBody generates requests for CreateSandboxPreviewToken with any type of body
func NewCreateSandboxPreviewTokenRequestWithBody(server string, sandboxName string, previewName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxPreviewTokenRequest generates requests for DeleteSandboxPreviewToken
func NewDeleteSandboxPreviewTokenRequest(server string, sandboxName string, previewName string, tokenName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenName", runtime.ParamLocationPath, tokenName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceServiceAccountsRequest generates requests for GetWorkspaceServiceAccounts
func NewGetWorkspaceServiceAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceServiceAccountRequest calls the generic CreateWorkspaceServiceAccount builder with application/json body
func NewCreateWorkspaceServiceAccountRequest(server string, body CreateWorkspaceServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceServiceAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceServiceAccountRequestWithBody generates requests for CreateWorkspaceServiceAccount with any type of body
func NewCreateWorkspaceServiceAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceServiceAccountRequest generates requests for DeleteWorkspaceServiceAccount
func NewDeleteWorkspaceServiceAccountRequest(server string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceServiceAccountRequest calls the generic UpdateWorkspaceServiceAccount builder with application/json body
func NewUpdateWorkspaceServiceAccountRequest(server string, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceServiceAccountRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewUpdateWorkspaceServiceAccountRequestWithBody generates requests for UpdateWorkspaceServiceAccount with any type of body
func NewUpdateWorkspaceServiceAccountRequestWithBody(server string, clientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListApiKeysForServiceAccountRequest generates requests for ListApiKeysForServiceAccount
func NewListApiKeysForServiceAccountRequest(server string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyForServiceAccountRequest calls the generic CreateApiKeyForServiceAccount builder with application/json body
func NewCreateApiKeyForServiceAccountRequest(server string, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyForServiceAccountRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewCreateApiKeyForServiceAccountRequestWithBody generates requests for CreateApiKeyForServiceAccount with any type of body
func NewCreateApiKeyForServiceAccountRequestWithBody(server string, clientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeyForServiceAccountRequest generates requests for DeleteApiKeyForServiceAccount
func NewDeleteApiKeyForServiceAccountRequest(server string, clientId string, apiKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "apiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTemplatesRequest generates requests for ListTemplates
func NewListTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateRequest generates requests for GetTemplate
func NewGetTemplateRequest(server string, templateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateName", runtime.ParamLocationPath, templateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceUsersRequest generates requests for ListWorkspaceUsers
func NewListWorkspaceUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteWorkspaceUserRequest calls the generic InviteWorkspaceUser builder with application/json body
func NewInviteWorkspaceUserRequest(server string, body InviteWorkspaceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteWorkspaceUserRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteWorkspaceUserRequestWithBody generates requests for InviteWorkspaceUser with any type of body
func NewInviteWorkspaceUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveWorkspaceUserRequest generates requests for RemoveWorkspaceUser
func NewRemoveWorkspaceUserRequest(server string, subOrEmail string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subOrEmail", runtime.ParamLocationPath, subOrEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceUserRoleRequest calls the generic UpdateWorkspaceUserRole builder with application/json body
func NewUpdateWorkspaceUserRoleRequest(server string, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceUserRoleRequestWithBody(server, subOrEmail, "application/json", bodyReader)
}

// NewUpdateWorkspaceUserRoleRequestWithBody generates requests for UpdateWorkspaceUserRole with any type of body
func NewUpdateWorkspaceUserRoleRequestWithBody(server string, subOrEmail string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subOrEmail", runtime.ParamLocationPath, subOrEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVolumeTemplatesRequest generates requests for ListVolumeTemplates
func NewListVolumeTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeTemplateRequest calls the generic CreateVolumeTemplate builder with application/json body
func NewCreateVolumeTemplateRequest(server string, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeTemplateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVolumeTemplateRequestWithBody generates requests for CreateVolumeTemplate with any type of body
func NewCreateVolumeTemplateRequestWithBody(server string, params *CreateVolumeTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Upload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upload", runtime.ParamLocationQuery, *params.Upload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeTemplateRequest generates requests for DeleteVolumeTemplate
func NewDeleteVolumeTemplateRequest(server string, volumeTemplateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVolumeTemplateRequest generates requests for GetVolumeTemplate
func NewGetVolumeTemplateRequest(server string, volumeTemplateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeTemplateRequest calls the generic UpdateVolumeTemplate builder with application/json body
func NewUpdateVolumeTemplateRequest(server string, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeTemplateRequestWithBody(server, volumeTemplateName, params, "application/json", bodyReader)
}

// NewUpdateVolumeTemplateRequestWithBody generates requests for UpdateVolumeTemplate with any type of body
func NewUpdateVolumeTemplateRequestWithBody(server string, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Upload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upload", runtime.ParamLocationQuery, *params.Upload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeTemplateVersionRequest generates requests for DeleteVolumeTemplateVersion
func NewDeleteVolumeTemplateVersionRequest(server string, volumeTemplateName string, versionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "versionName", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVolumesRequest generates requests for ListVolumes
func NewListVolumesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, volumeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVolumeRequest generates requests for GetVolume
func NewGetVolumeRequest(server string, volumeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, volumeName string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, volumeName, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, volumeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckWorkspaceAvailabilityRequest calls the generic CheckWorkspaceAvailability builder with application/json body
func NewCheckWorkspaceAvailabilityRequest(server string, body CheckWorkspaceAvailabilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckWorkspaceAvailabilityRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckWorkspaceAvailabilityRequestWithBody generates requests for CheckWorkspaceAvailability with any type of body
func NewCheckWorkspaceAvailabilityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/availability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceRequest generates requests for GetWorkspace
func NewGetWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceRequest calls the generic UpdateWorkspace builder with application/json body
func NewUpdateWorkspaceRequest(server string, workspaceName string, body UpdateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceRequestWithBody(server, workspaceName, "application/json", bodyReader)
}

// NewUpdateWorkspaceRequestWithBody generates requests for UpdateWorkspace with any type of body
func NewUpdateWorkspaceRequestWithBody(server string, workspaceName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeclineWorkspaceInvitationRequest generates requests for DeclineWorkspaceInvitation
func NewDeclineWorkspaceInvitationRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/decline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptWorkspaceInvitationRequest generates requests for AcceptWorkspaceInvitation
func NewAcceptWorkspaceInvitationRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/join", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveWorkspaceRequest generates requests for LeaveWorkspace
func NewLeaveWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/leave", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, runServer string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, runServer, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAgentsWithResponse request
	ListAgentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAgentsResponse, error)

	// CreateAgentWithBodyWithResponse request with any body
	CreateAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error)

	CreateAgentWithResponse(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error)

	// DeleteAgentWithResponse request
	DeleteAgentWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*DeleteAgentResponse, error)

	// GetAgentWithResponse request
	GetAgentWithResponse(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*GetAgentResponse, error)

	// UpdateAgentWithBodyWithResponse request with any body
	UpdateAgentWithBodyWithResponse(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error)

	UpdateAgentWithResponse(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error)

	// ListAgentRevisionsWithResponse request
	ListAgentRevisionsWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*ListAgentRevisionsResponse, error)

	// GetConfigurationWithResponse request
	GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error)

	// ListCustomDomainsWithResponse request
	ListCustomDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCustomDomainsResponse, error)

	// CreateCustomDomainWithBodyWithResponse request with any body
	CreateCustomDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error)

	CreateCustomDomainWithResponse(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error)

	// DeleteCustomDomainWithResponse request
	DeleteCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*DeleteCustomDomainResponse, error)

	// GetCustomDomainWithResponse request
	GetCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*GetCustomDomainResponse, error)

	// UpdateCustomDomainWithBodyWithResponse request with any body
	UpdateCustomDomainWithBodyWithResponse(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error)

	UpdateCustomDomainWithResponse(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error)

	// VerifyCustomDomainWithResponse request
	VerifyCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*VerifyCustomDomainResponse, error)

	// ListFunctionsWithResponse request
	ListFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFunctionsResponse, error)

	// CreateFunctionWithBodyWithResponse request with any body
	CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	// DeleteFunctionWithResponse request
	DeleteFunctionWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error)

	// GetFunctionWithResponse request
	GetFunctionWithResponse(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*GetFunctionResponse, error)

	// UpdateFunctionWithBodyWithResponse request with any body
	UpdateFunctionWithBodyWithResponse(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	UpdateFunctionWithResponse(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	// ListFunctionRevisionsWithResponse request
	ListFunctionRevisionsWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*ListFunctionRevisionsResponse, error)

	// CleanupImagesWithResponse request
	CleanupImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CleanupImagesResponse, error)

	// ListImagesWithResponse request
	ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// GetImageWithResponse request
	GetImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*GetImageResponse, error)

	// DeleteImageTagWithResponse request
	DeleteImageTagWithResponse(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*DeleteImageTagResponse, error)

	// ListIntegrationConnectionsWithResponse request
	ListIntegrationConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionsResponse, error)

	// CreateIntegrationConnectionWithBodyWithResponse request with any body
	CreateIntegrationConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error)

	CreateIntegrationConnectionWithResponse(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error)

	// DeleteIntegrationConnectionWithResponse request
	DeleteIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*DeleteIntegrationConnectionResponse, error)

	// GetIntegrationConnectionWithResponse request
	GetIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionResponse, error)

	// UpdateIntegrationConnectionWithBodyWithResponse request with any body
	UpdateIntegrationConnectionWithBodyWithResponse(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error)

	UpdateIntegrationConnectionWithResponse(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error)

	// GetIntegrationConnectionModelEndpointConfigurationsWithResponse request
	GetIntegrationConnectionModelEndpointConfigurationsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error)

	// ListIntegrationConnectionModelsWithResponse request
	ListIntegrationConnectionModelsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionModelsResponse, error)

	// GetIntegrationConnectionModelWithResponse request
	GetIntegrationConnectionModelWithResponse(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelResponse, error)

	// GetIntegrationWithResponse request
	GetIntegrationWithResponse(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error)

	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// CreateJobWithBodyWithResponse request with any body
	CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	// DeleteJobWithResponse request
	DeleteJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// UpdateJobWithBodyWithResponse request with any body
	UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	UpdateJobWithResponse(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	// ListJobExecutionsWithResponse request
	ListJobExecutionsWithResponse(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*ListJobExecutionsResponse, error)

	// CreateJobExecutionWithBodyWithResponse request with any body
	CreateJobExecutionWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobExecution, error)

	CreateJobExecutionWithResponse(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobExecution, error)

	// DeleteJobExecutionWithResponse request
	DeleteJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*DeleteJobExecutionResponse, error)

	// GetJobExecutionWithResponse request
	GetJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*GetJobExecutionResponse, error)

	// ListJobRevisionsWithResponse request
	ListJobRevisionsWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*ListJobRevisionsResponse, error)

	// ListLocationsWithResponse request
	ListLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error)

	// ListMCPHubDefinitionsWithResponse request
	ListMCPHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMCPHubDefinitionsResponse, error)

	// ListModelsWithResponse request
	ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResponse, error)

	// CreateModelWithBodyWithResponse request with any body
	CreateModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResponse, error)

	CreateModelWithResponse(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResponse, error)

	// DeleteModelWithResponse request
	DeleteModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*DeleteModelResponse, error)

	// GetModelWithResponse request
	GetModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*GetModelResponse, error)

	// UpdateModelWithBodyWithResponse request with any body
	UpdateModelWithBodyWithResponse(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error)

	UpdateModelWithResponse(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error)

	// ListModelRevisionsWithResponse request
	ListModelRevisionsWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*ListModelRevisionsResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyWithResponse request
	GetPolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListPublicIpsWithResponse request
	ListPublicIpsWithResponse(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*ListPublicIpsResponse, error)

	// ListSandboxHubDefinitionsWithResponse request
	ListSandboxHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxHubDefinitionsResponse, error)

	// ListSandboxesWithResponse request
	ListSandboxesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error)

	// CreateSandboxWithBodyWithResponse request with any body
	CreateSandboxWithBodyWithResponse(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	CreateSandboxWithResponse(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	// DeleteSandboxWithResponse request
	DeleteSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error)

	// GetSandboxWithResponse request
	GetSandboxWithResponse(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error)

	// UpdateSandboxWithBodyWithResponse request with any body
	UpdateSandboxWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error)

	UpdateSandboxWithResponse(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error)

	// ListSandboxPreviewsWithResponse request
	ListSandboxPreviewsWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewsResponse, error)

	// CreateSandboxPreviewWithBodyWithResponse request with any body
	CreateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error)

	CreateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error)

	// DeleteSandboxPreviewWithResponse request
	DeleteSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewResponse, error)

	// GetSandboxPreviewWithResponse request
	GetSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*GetSandboxPreviewResponse, error)

	// UpdateSandboxPreviewWithBodyWithResponse request with any body
	UpdateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error)

	UpdateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error)

	// ListSandboxPreviewTokensWithResponse request
	ListSandboxPreviewTokensWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewTokensResponse, error)

	// CreateSandboxPreviewTokenWithBodyWithResponse request with any body
	CreateSandboxPreviewTokenWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error)

	CreateSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error)

	// DeleteSandboxPreviewTokenWithResponse request
	DeleteSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewTokenResponse, error)

	// GetWorkspaceServiceAccountsWithResponse request
	GetWorkspaceServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkspaceServiceAccountsResponse, error)

	// CreateWorkspaceServiceAccountWithBodyWithResponse request with any body
	CreateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error)

	CreateWorkspaceServiceAccountWithResponse(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error)

	// DeleteWorkspaceServiceAccountWithResponse request
	DeleteWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceServiceAccountResponse, error)

	// UpdateWorkspaceServiceAccountWithBodyWithResponse request with any body
	UpdateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error)

	UpdateWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error)

	// ListApiKeysForServiceAccountWithResponse request
	ListApiKeysForServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*ListApiKeysForServiceAccountResponse, error)

	// CreateApiKeyForServiceAccountWithBodyWithResponse request with any body
	CreateApiKeyForServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error)

	CreateApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error)

	// DeleteApiKeyForServiceAccountWithResponse request
	DeleteApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyForServiceAccountResponse, error)

	// ListTemplatesWithResponse request
	ListTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error)

	// GetTemplateWithResponse request
	GetTemplateWithResponse(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error)

	// ListWorkspaceUsersWithResponse request
	ListWorkspaceUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error)

	// InviteWorkspaceUserWithBodyWithResponse request with any body
	InviteWorkspaceUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error)

	InviteWorkspaceUserWithResponse(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error)

	// RemoveWorkspaceUserWithResponse request
	RemoveWorkspaceUserWithResponse(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*RemoveWorkspaceUserResponse, error)

	// UpdateWorkspaceUserRoleWithBodyWithResponse request with any body
	UpdateWorkspaceUserRoleWithBodyWithResponse(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error)

	UpdateWorkspaceUserRoleWithResponse(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error)

	// ListVolumeTemplatesWithResponse request
	ListVolumeTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumeTemplatesResponse, error)

	// CreateVolumeTemplateWithBodyWithResponse request with any body
	CreateVolumeTemplateWithBodyWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error)

	CreateVolumeTemplateWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error)

	// DeleteVolumeTemplateWithResponse request
	DeleteVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateResponse, error)

	// GetVolumeTemplateWithResponse request
	GetVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*GetVolumeTemplateResponse, error)

	// UpdateVolumeTemplateWithBodyWithResponse request with any body
	UpdateVolumeTemplateWithBodyWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error)

	UpdateVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error)

	// DeleteVolumeTemplateVersionWithResponse request
	DeleteVolumeTemplateVersionWithResponse(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateVersionResponse, error)

	// ListVolumesWithResponse request
	ListVolumesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumesResponse, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// GetVolumeWithResponse request
	GetVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*GetVolumeResponse, error)

	// UpdateVolumeWithBodyWithResponse request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	UpdateVolumeWithResponse(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	// ListWorkspacesWithResponse request
	ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// CreateWorkspaceWithBodyWithResponse request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// CheckWorkspaceAvailabilityWithBodyWithResponse request with any body
	CheckWorkspaceAvailabilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error)

	CheckWorkspaceAvailabilityWithResponse(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error)

	// DeleteWorkspaceWithResponse request
	DeleteWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// GetWorkspaceWithResponse request
	GetWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error)

	// UpdateWorkspaceWithBodyWithResponse request with any body
	UpdateWorkspaceWithBodyWithResponse(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)

	UpdateWorkspaceWithResponse(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)

	// DeclineWorkspaceInvitationWithResponse request
	DeclineWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeclineWorkspaceInvitationResponse, error)

	// AcceptWorkspaceInvitationWithResponse request
	AcceptWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*AcceptWorkspaceInvitationResponse, error)

	// LeaveWorkspaceWithResponse request
	LeaveWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error)
}

type ListAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Agent
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAgentRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListAgentRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Configuration
}

// Status returns HTTPResponse.Status
func (r GetConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CustomDomain
}

// Status returns HTTPResponse.Status
func (r ListCustomDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r CreateCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r DeleteCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r GetCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r UpdateCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r VerifyCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Function
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListFunctionRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CleanupImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Number of images deleted
		Deleted *int `json:"deleted,omitempty"`

		// Message Result message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CleanupImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CleanupImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Image
}

// Status returns HTTPResponse.Status
func (r ListImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r GetImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r DeleteImageTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IntegrationConnection
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionModelEndpointConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionModelEndpointConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionModelEndpointConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConnectionModelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConnectionModelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConnectionModelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r GetIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r CreateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobExecutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JobExecution
}

// Status returns HTTPResponse.Status
func (r ListJobExecutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobExecutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateJobExecution
}

// Status returns HTTPResponse.Status
func (r CreateJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r DeleteJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r GetJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListJobRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LocationResponse
}

// Status returns HTTPResponse.Status
func (r ListLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMCPHubDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MCPDefinition
}

// Status returns HTTPResponse.Status
func (r ListMCPHubDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMCPHubDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Model
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListModelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListModelRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Policy
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPublicIpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicIps
}

// Status returns HTTPResponse.Status
func (r ListPublicIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPublicIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxHubDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SandboxDefinition
}

// Status returns HTTPResponse.Status
func (r ListSandboxHubDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxHubDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Sandbox
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
	JSON400      *SandboxError
	JSON401      *SandboxError
	JSON403      *SandboxError
	JSON409      *SandboxError
	JSON500      *SandboxError
}

// Status returns HTTPResponse.Status
func (r CreateSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxPreviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Preview
}

// Status returns HTTPResponse.Status
func (r ListSandboxPreviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxPreviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r CreateSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r GetSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r UpdateSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxPreviewTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PreviewToken
}

// Status returns HTTPResponse.Status
func (r ListSandboxPreviewTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxPreviewTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxPreviewTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreviewToken
}

// Status returns HTTPResponse.Status
func (r CreateSandboxPreviewTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxPreviewTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxPreviewTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Message Success message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxPreviewTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxPreviewTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// ClientSecret Service account client secret (only returned on creation)
		ClientSecret *string `json:"client_secret,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiKeysForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApiKey
}

// Status returns HTTPResponse.Status
func (r ListApiKeysForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKey
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeyForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeyForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeyForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
}

// Status returns HTTPResponse.Status
func (r ListTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Template
}

// Status returns HTTPResponse.Status
func (r GetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceUser
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteWorkspaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitation
}

// Status returns HTTPResponse.Status
func (r InviteWorkspaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteWorkspaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveWorkspaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveWorkspaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveWorkspaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceUserRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspaceUser
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceUserRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceUserRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVolumeTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r ListVolumeTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVolumeTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r CreateVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r GetVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeTemplateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`

		// Template Volume template for creating pre-configured volumes
		Template *VolumeTemplate `json:"template,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeTemplateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeTemplateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Volume
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckWorkspaceAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r CheckWorkspaceAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckWorkspaceAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineWorkspaceInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitation
}

// Status returns HTTPResponse.Status
func (r DeclineWorkspaceInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineWorkspaceInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptWorkspaceInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitationAccept
}

// Status returns HTTPResponse.Status
func (r AcceptWorkspaceInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptWorkspaceInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r LeaveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAgentsWithResponse request returning *ListAgentsResponse
func (c *ClientWithResponses) ListAgentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAgentsResponse, error) {
	rsp, err := c.ListAgents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentsResponse(rsp)
}

// CreateAgentWithBodyWithResponse request with arbitrary body returning *CreateAgentResponse
func (c *ClientWithResponses) CreateAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error) {
	rsp, err := c.CreateAgentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentWithResponse(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error) {
	rsp, err := c.CreateAgent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentResponse(rsp)
}

// DeleteAgentWithResponse request returning *DeleteAgentResponse
func (c *ClientWithResponses) DeleteAgentWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*DeleteAgentResponse, error) {
	rsp, err := c.DeleteAgent(ctx, agentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentResponse(rsp)
}

// GetAgentWithResponse request returning *GetAgentResponse
func (c *ClientWithResponses) GetAgentWithResponse(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*GetAgentResponse, error) {
	rsp, err := c.GetAgent(ctx, agentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentResponse(rsp)
}

// UpdateAgentWithBodyWithResponse request with arbitrary body returning *UpdateAgentResponse
func (c *ClientWithResponses) UpdateAgentWithBodyWithResponse(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error) {
	rsp, err := c.UpdateAgentWithBody(ctx, agentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentResponse(rsp)
}

func (c *ClientWithResponses) UpdateAgentWithResponse(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error) {
	rsp, err := c.UpdateAgent(ctx, agentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentResponse(rsp)
}

// ListAgentRevisionsWithResponse request returning *ListAgentRevisionsResponse
func (c *ClientWithResponses) ListAgentRevisionsWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*ListAgentRevisionsResponse, error) {
	rsp, err := c.ListAgentRevisions(ctx, agentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentRevisionsResponse(rsp)
}

// GetConfigurationWithResponse request returning *GetConfigurationResponse
func (c *ClientWithResponses) GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error) {
	rsp, err := c.GetConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationResponse(rsp)
}

// ListCustomDomainsWithResponse request returning *ListCustomDomainsResponse
func (c *ClientWithResponses) ListCustomDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCustomDomainsResponse, error) {
	rsp, err := c.ListCustomDomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomDomainsResponse(rsp)
}

// CreateCustomDomainWithBodyWithResponse request with arbitrary body returning *CreateCustomDomainResponse
func (c *ClientWithResponses) CreateCustomDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error) {
	rsp, err := c.CreateCustomDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomDomainWithResponse(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error) {
	rsp, err := c.CreateCustomDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomDomainResponse(rsp)
}

// DeleteCustomDomainWithResponse request returning *DeleteCustomDomainResponse
func (c *ClientWithResponses) DeleteCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*DeleteCustomDomainResponse, error) {
	rsp, err := c.DeleteCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomDomainResponse(rsp)
}

// GetCustomDomainWithResponse request returning *GetCustomDomainResponse
func (c *ClientWithResponses) GetCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*GetCustomDomainResponse, error) {
	rsp, err := c.GetCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomDomainResponse(rsp)
}

// UpdateCustomDomainWithBodyWithResponse request with arbitrary body returning *UpdateCustomDomainResponse
func (c *ClientWithResponses) UpdateCustomDomainWithBodyWithResponse(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error) {
	rsp, err := c.UpdateCustomDomainWithBody(ctx, domainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomDomainResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomDomainWithResponse(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error) {
	rsp, err := c.UpdateCustomDomain(ctx, domainName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomDomainResponse(rsp)
}

// VerifyCustomDomainWithResponse request returning *VerifyCustomDomainResponse
func (c *ClientWithResponses) VerifyCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*VerifyCustomDomainResponse, error) {
	rsp, err := c.VerifyCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyCustomDomainResponse(rsp)
}

// ListFunctionsWithResponse request returning *ListFunctionsResponse
func (c *ClientWithResponses) ListFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFunctionsResponse, error) {
	rsp, err := c.ListFunctions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionsResponse(rsp)
}

// CreateFunctionWithBodyWithResponse request with arbitrary body returning *CreateFunctionResponse
func (c *ClientWithResponses) CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunctionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

func (c *ClientWithResponses) CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

// DeleteFunctionWithResponse request returning *DeleteFunctionResponse
func (c *ClientWithResponses) DeleteFunctionWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error) {
	rsp, err := c.DeleteFunction(ctx, functionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFunctionResponse(rsp)
}

// GetFunctionWithResponse request returning *GetFunctionResponse
func (c *ClientWithResponses) GetFunctionWithResponse(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*GetFunctionResponse, error) {
	rsp, err := c.GetFunction(ctx, functionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionResponse(rsp)
}

// UpdateFunctionWithBodyWithResponse request with arbitrary body returning *UpdateFunctionResponse
func (c *ClientWithResponses) UpdateFunctionWithBodyWithResponse(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunctionWithBody(ctx, functionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

func (c *ClientWithResponses) UpdateFunctionWithResponse(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunction(ctx, functionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

// ListFunctionRevisionsWithResponse request returning *ListFunctionRevisionsResponse
func (c *ClientWithResponses) ListFunctionRevisionsWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*ListFunctionRevisionsResponse, error) {
	rsp, err := c.ListFunctionRevisions(ctx, functionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionRevisionsResponse(rsp)
}

// CleanupImagesWithResponse request returning *CleanupImagesResponse
func (c *ClientWithResponses) CleanupImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CleanupImagesResponse, error) {
	rsp, err := c.CleanupImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCleanupImagesResponse(rsp)
}

// ListImagesWithResponse request returning *ListImagesResponse
func (c *ClientWithResponses) ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error) {
	rsp, err := c.ListImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImagesResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, resourceType, imageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// GetImageWithResponse request returning *GetImageResponse
func (c *ClientWithResponses) GetImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*GetImageResponse, error) {
	rsp, err := c.GetImage(ctx, resourceType, imageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageResponse(rsp)
}

// DeleteImageTagWithResponse request returning *DeleteImageTagResponse
func (c *ClientWithResponses) DeleteImageTagWithResponse(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*DeleteImageTagResponse, error) {
	rsp, err := c.DeleteImageTag(ctx, resourceType, imageName, tagName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageTagResponse(rsp)
}

// ListIntegrationConnectionsWithResponse request returning *ListIntegrationConnectionsResponse
func (c *ClientWithResponses) ListIntegrationConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionsResponse, error) {
	rsp, err := c.ListIntegrationConnections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConnectionsResponse(rsp)
}

// CreateIntegrationConnectionWithBodyWithResponse request with arbitrary body returning *CreateIntegrationConnectionResponse
func (c *ClientWithResponses) CreateIntegrationConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error) {
	rsp, err := c.CreateIntegrationConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateIntegrationConnectionWithResponse(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error) {
	rsp, err := c.CreateIntegrationConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationConnectionResponse(rsp)
}

// DeleteIntegrationConnectionWithResponse request returning *DeleteIntegrationConnectionResponse
func (c *ClientWithResponses) DeleteIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*DeleteIntegrationConnectionResponse, error) {
	rsp, err := c.DeleteIntegrationConnection(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIntegrationConnectionResponse(rsp)
}

// GetIntegrationConnectionWithResponse request returning *GetIntegrationConnectionResponse
func (c *ClientWithResponses) GetIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionResponse, error) {
	rsp, err := c.GetIntegrationConnection(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionResponse(rsp)
}

// UpdateIntegrationConnectionWithBodyWithResponse request with arbitrary body returning *UpdateIntegrationConnectionResponse
func (c *ClientWithResponses) UpdateIntegrationConnectionWithBodyWithResponse(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error) {
	rsp, err := c.UpdateIntegrationConnectionWithBody(ctx, connectionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateIntegrationConnectionWithResponse(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error) {
	rsp, err := c.UpdateIntegrationConnection(ctx, connectionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationConnectionResponse(rsp)
}

// GetIntegrationConnectionModelEndpointConfigurationsWithResponse request returning *GetIntegrationConnectionModelEndpointConfigurationsResponse
func (c *ClientWithResponses) GetIntegrationConnectionModelEndpointConfigurationsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error) {
	rsp, err := c.GetIntegrationConnectionModelEndpointConfigurations(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionModelEndpointConfigurationsResponse(rsp)
}

// ListIntegrationConnectionModelsWithResponse request returning *ListIntegrationConnectionModelsResponse
func (c *ClientWithResponses) ListIntegrationConnectionModelsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionModelsResponse, error) {
	rsp, err := c.ListIntegrationConnectionModels(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConnectionModelsResponse(rsp)
}

// GetIntegrationConnectionModelWithResponse request returning *GetIntegrationConnectionModelResponse
func (c *ClientWithResponses) GetIntegrationConnectionModelWithResponse(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelResponse, error) {
	rsp, err := c.GetIntegrationConnectionModel(ctx, connectionName, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionModelResponse(rsp)
}

// GetIntegrationWithResponse request returning *GetIntegrationResponse
func (c *ClientWithResponses) GetIntegrationWithResponse(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error) {
	rsp, err := c.GetIntegration(ctx, integrationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// CreateJobWithBodyWithResponse request with arbitrary body returning *CreateJobResponse
func (c *ClientWithResponses) CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

func (c *ClientWithResponses) CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

// DeleteJobWithResponse request returning *DeleteJobResponse
func (c *ClientWithResponses) DeleteJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error) {
	rsp, err := c.DeleteJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// UpdateJobWithBodyWithResponse request with arbitrary body returning *UpdateJobResponse
func (c *ClientWithResponses) UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobWithResponse(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

// ListJobExecutionsWithResponse request returning *ListJobExecutionsResponse
func (c *ClientWithResponses) ListJobExecutionsWithResponse(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*ListJobExecutionsResponse, error) {
	rsp, err := c.ListJobExecutions(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobExecutionsResponse(rsp)
}

// CreateJobExecutionWithBodyWithResponse request with arbitrary body returning *CreateJobExecutionResponse
func (c *ClientWithResponses) CreateJobExecutionWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error) {
	rsp, err := c.CreateJobExecutionWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobExecutionResponse(rsp)
}

func (c *ClientWithResponses) CreateJobExecutionWithResponse(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error) {
	rsp, err := c.CreateJobExecution(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobExecutionResponse(rsp)
}

// DeleteJobExecutionWithResponse request returning *DeleteJobExecutionResponse
func (c *ClientWithResponses) DeleteJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*DeleteJobExecutionResponse, error) {
	rsp, err := c.DeleteJobExecution(ctx, jobId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobExecutionResponse(rsp)
}

// GetJobExecutionWithResponse request returning *GetJobExecutionResponse
func (c *ClientWithResponses) GetJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*GetJobExecutionResponse, error) {
	rsp, err := c.GetJobExecution(ctx, jobId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobExecutionResponse(rsp)
}

// ListJobRevisionsWithResponse request returning *ListJobRevisionsResponse
func (c *ClientWithResponses) ListJobRevisionsWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*ListJobRevisionsResponse, error) {
	rsp, err := c.ListJobRevisions(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobRevisionsResponse(rsp)
}

// ListLocationsWithResponse request returning *ListLocationsResponse
func (c *ClientWithResponses) ListLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error) {
	rsp, err := c.ListLocations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLocationsResponse(rsp)
}

// ListMCPHubDefinitionsWithResponse request returning *ListMCPHubDefinitionsResponse
func (c *ClientWithResponses) ListMCPHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMCPHubDefinitionsResponse, error) {
	rsp, err := c.ListMCPHubDefinitions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMCPHubDefinitionsResponse(rsp)
}

// ListModelsWithResponse request returning *ListModelsResponse
func (c *ClientWithResponses) ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResponse, error) {
	rsp, err := c.ListModels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelsResponse(rsp)
}

// CreateModelWithBodyWithResponse request with arbitrary body returning *CreateModelResponse
func (c *ClientWithResponses) CreateModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResponse, error) {
	rsp, err := c.CreateModelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResponse(rsp)
}

func (c *ClientWithResponses) CreateModelWithResponse(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResponse, error) {
	rsp, err := c.CreateModel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResponse(rsp)
}

// DeleteModelWithResponse request returning *DeleteModelResponse
func (c *ClientWithResponses) DeleteModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*DeleteModelResponse, error) {
	rsp, err := c.DeleteModel(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModelResponse(rsp)
}

// GetModelWithResponse request returning *GetModelResponse
func (c *ClientWithResponses) GetModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*GetModelResponse, error) {
	rsp, err := c.GetModel(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelResponse(rsp)
}

// UpdateModelWithBodyWithResponse request with arbitrary body returning *UpdateModelResponse
func (c *ClientWithResponses) UpdateModelWithBodyWithResponse(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error) {
	rsp, err := c.UpdateModelWithBody(ctx, modelName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelResponse(rsp)
}

func (c *ClientWithResponses) UpdateModelWithResponse(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error) {
	rsp, err := c.UpdateModel(ctx, modelName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelResponse(rsp)
}

// ListModelRevisionsWithResponse request returning *ListModelRevisionsResponse
func (c *ClientWithResponses) ListModelRevisionsWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*ListModelRevisionsResponse, error) {
	rsp, err := c.ListModelRevisions(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelRevisionsResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListPublicIpsWithResponse request returning *ListPublicIpsResponse
func (c *ClientWithResponses) ListPublicIpsWithResponse(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*ListPublicIpsResponse, error) {
	rsp, err := c.ListPublicIps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPublicIpsResponse(rsp)
}

// ListSandboxHubDefinitionsWithResponse request returning *ListSandboxHubDefinitionsResponse
func (c *ClientWithResponses) ListSandboxHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxHubDefinitionsResponse, error) {
	rsp, err := c.ListSandboxHubDefinitions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxHubDefinitionsResponse(rsp)
}

// ListSandboxesWithResponse request returning *ListSandboxesResponse
func (c *ClientWithResponses) ListSandboxesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error) {
	rsp, err := c.ListSandboxes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxesResponse(rsp)
}

// CreateSandboxWithBodyWithResponse request with arbitrary body returning *CreateSandboxResponse
func (c *ClientWithResponses) CreateSandboxWithBodyWithResponse(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandboxWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxWithResponse(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandbox(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

// DeleteSandboxWithResponse request returning *DeleteSandboxResponse
func (c *ClientWithResponses) DeleteSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error) {
	rsp, err := c.DeleteSandbox(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxResponse(rsp)
}

// GetSandboxWithResponse request returning *GetSandboxResponse
func (c *ClientWithResponses) GetSandboxWithResponse(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error) {
	rsp, err := c.GetSandbox(ctx, sandboxName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxResponse(rsp)
}

// UpdateSandboxWithBodyWithResponse request with arbitrary body returning *UpdateSandboxResponse
func (c *ClientWithResponses) UpdateSandboxWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error) {
	rsp, err := c.UpdateSandboxWithBody(ctx, sandboxName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxResponse(rsp)
}

func (c *ClientWithResponses) UpdateSandboxWithResponse(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error) {
	rsp, err := c.UpdateSandbox(ctx, sandboxName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxResponse(rsp)
}

// ListSandboxPreviewsWithResponse request returning *ListSandboxPreviewsResponse
func (c *ClientWithResponses) ListSandboxPreviewsWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewsResponse, error) {
	rsp, err := c.ListSandboxPreviews(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxPreviewsResponse(rsp)
}

// CreateSandboxPreviewWithBodyWithResponse request with arbitrary body returning *CreateSandboxPreviewResponse
func (c *ClientWithResponses) CreateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error) {
	rsp, err := c.CreateSandboxPreviewWithBody(ctx, sandboxName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error) {
	rsp, err := c.CreateSandboxPreview(ctx, sandboxName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewResponse(rsp)
}

// DeleteSandboxPreviewWithResponse request returning *DeleteSandboxPreviewResponse
func (c *ClientWithResponses) DeleteSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewResponse, error) {
	rsp, err := c.DeleteSandboxPreview(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxPreviewResponse(rsp)
}

// GetSandboxPreviewWithResponse request returning *GetSandboxPreviewResponse
func (c *ClientWithResponses) GetSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*GetSandboxPreviewResponse, error) {
	rsp, err := c.GetSandboxPreview(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxPreviewResponse(rsp)
}

// UpdateSandboxPreviewWithBodyWithResponse request with arbitrary body returning *UpdateSandboxPreviewResponse
func (c *ClientWithResponses) UpdateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error) {
	rsp, err := c.UpdateSandboxPreviewWithBody(ctx, sandboxName, previewName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxPreviewResponse(rsp)
}

func (c *ClientWithResponses) UpdateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error) {
	rsp, err := c.UpdateSandboxPreview(ctx, sandboxName, previewName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxPreviewResponse(rsp)
}

// ListSandboxPreviewTokensWithResponse request returning *ListSandboxPreviewTokensResponse
func (c *ClientWithResponses) ListSandboxPreviewTokensWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewTokensResponse, error) {
	rsp, err := c.ListSandboxPreviewTokens(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxPreviewTokensResponse(rsp)
}

// CreateSandboxPreviewTokenWithBodyWithResponse request with arbitrary body returning *CreateSandboxPreviewTokenResponse
func (c *ClientWithResponses) CreateSandboxPreviewTokenWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error) {
	rsp, err := c.CreateSandboxPreviewTokenWithBody(ctx, sandboxName, previewName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error) {
	rsp, err := c.CreateSandboxPreviewToken(ctx, sandboxName, previewName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewTokenResponse(rsp)
}

// DeleteSandboxPreviewTokenWithResponse request returning *DeleteSandboxPreviewTokenResponse
func (c *ClientWithResponses) DeleteSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewTokenResponse, error) {
	rsp, err := c.DeleteSandboxPreviewToken(ctx, sandboxName, previewName, tokenName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxPreviewTokenResponse(rsp)
}

// GetWorkspaceServiceAccountsWithResponse request returning *GetWorkspaceServiceAccountsResponse
func (c *ClientWithResponses) GetWorkspaceServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkspaceServiceAccountsResponse, error) {
	rsp, err := c.GetWorkspaceServiceAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceServiceAccountsResponse(rsp)
}

// CreateWorkspaceServiceAccountWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceServiceAccountResponse
func (c *ClientWithResponses) CreateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.CreateWorkspaceServiceAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceServiceAccountWithResponse(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.CreateWorkspaceServiceAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceServiceAccountResponse(rsp)
}

// DeleteWorkspaceServiceAccountWithResponse request returning *DeleteWorkspaceServiceAccountResponse
func (c *ClientWithResponses) DeleteWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceServiceAccountResponse, error) {
	rsp, err := c.DeleteWorkspaceServiceAccount(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceServiceAccountResponse(rsp)
}

// UpdateWorkspaceServiceAccountWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceServiceAccountResponse
func (c *ClientWithResponses) UpdateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.UpdateWorkspaceServiceAccountWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.UpdateWorkspaceServiceAccount(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceServiceAccountResponse(rsp)
}

// ListApiKeysForServiceAccountWithResponse request returning *ListApiKeysForServiceAccountResponse
func (c *ClientWithResponses) ListApiKeysForServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*ListApiKeysForServiceAccountResponse, error) {
	rsp, err := c.ListApiKeysForServiceAccount(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysForServiceAccountResponse(rsp)
}

// CreateApiKeyForServiceAccountWithBodyWithResponse request with arbitrary body returning *CreateApiKeyForServiceAccountResponse
func (c *ClientWithResponses) CreateApiKeyForServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error) {
	rsp, err := c.CreateApiKeyForServiceAccountWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyForServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error) {
	rsp, err := c.CreateApiKeyForServiceAccount(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyForServiceAccountResponse(rsp)
}

// DeleteApiKeyForServiceAccountWithResponse request returning *DeleteApiKeyForServiceAccountResponse
func (c *ClientWithResponses) DeleteApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyForServiceAccountResponse, error) {
	rsp, err := c.DeleteApiKeyForServiceAccount(ctx, clientId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeyForServiceAccountResponse(rsp)
}

// ListTemplatesWithResponse request returning *ListTemplatesResponse
func (c *ClientWithResponses) ListTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error) {
	rsp, err := c.ListTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTemplatesResponse(rsp)
}

// GetTemplateWithResponse request returning *GetTemplateResponse
func (c *ClientWithResponses) GetTemplateWithResponse(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error) {
	rsp, err := c.GetTemplate(ctx, templateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateResponse(rsp)
}

// ListWorkspaceUsersWithResponse request returning *ListWorkspaceUsersResponse
func (c *ClientWithResponses) ListWorkspaceUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error) {
	rsp, err := c.ListWorkspaceUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceUsersResponse(rsp)
}

// InviteWorkspaceUserWithBodyWithResponse request with arbitrary body returning *InviteWorkspaceUserResponse
func (c *ClientWithResponses) InviteWorkspaceUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error) {
	rsp, err := c.InviteWorkspaceUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteWorkspaceUserResponse(rsp)
}

func (c *ClientWithResponses) InviteWorkspaceUserWithResponse(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error) {
	rsp, err := c.InviteWorkspaceUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteWorkspaceUserResponse(rsp)
}

// RemoveWorkspaceUserWithResponse request returning *RemoveWorkspaceUserResponse
func (c *ClientWithResponses) RemoveWorkspaceUserWithResponse(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*RemoveWorkspaceUserResponse, error) {
	rsp, err := c.RemoveWorkspaceUser(ctx, subOrEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveWorkspaceUserResponse(rsp)
}

// UpdateWorkspaceUserRoleWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceUserRoleResponse
func (c *ClientWithResponses) UpdateWorkspaceUserRoleWithBodyWithResponse(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error) {
	rsp, err := c.UpdateWorkspaceUserRoleWithBody(ctx, subOrEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceUserRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceUserRoleWithResponse(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error) {
	rsp, err := c.UpdateWorkspaceUserRole(ctx, subOrEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceUserRoleResponse(rsp)
}

// ListVolumeTemplatesWithResponse request returning *ListVolumeTemplatesResponse
func (c *ClientWithResponses) ListVolumeTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumeTemplatesResponse, error) {
	rsp, err := c.ListVolumeTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVolumeTemplatesResponse(rsp)
}

// CreateVolumeTemplateWithBodyWithResponse request with arbitrary body returning *CreateVolumeTemplateResponse
func (c *ClientWithResponses) CreateVolumeTemplateWithBodyWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error) {
	rsp, err := c.CreateVolumeTemplateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeTemplateWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error) {
	rsp, err := c.CreateVolumeTemplate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeTemplateResponse(rsp)
}

// DeleteVolumeTemplateWithResponse request returning *DeleteVolumeTemplateResponse
func (c *ClientWithResponses) DeleteVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateResponse, error) {
	rsp, err := c.DeleteVolumeTemplate(ctx, volumeTemplateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeTemplateResponse(rsp)
}

// GetVolumeTemplateWithResponse request returning *GetVolumeTemplateResponse
func (c *ClientWithResponses) GetVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*GetVolumeTemplateResponse, error) {
	rsp, err := c.GetVolumeTemplate(ctx, volumeTemplateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVolumeTemplateResponse(rsp)
}

// UpdateVolumeTemplateWithBodyWithResponse request with arbitrary body returning *UpdateVolumeTemplateResponse
func (c *ClientWithResponses) UpdateVolumeTemplateWithBodyWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error) {
	rsp, err := c.UpdateVolumeTemplateWithBody(ctx, volumeTemplateName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error) {
	rsp, err := c.UpdateVolumeTemplate(ctx, volumeTemplateName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeTemplateResponse(rsp)
}

// DeleteVolumeTemplateVersionWithResponse request returning *DeleteVolumeTemplateVersionResponse
func (c *ClientWithResponses) DeleteVolumeTemplateVersionWithResponse(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateVersionResponse, error) {
	rsp, err := c.DeleteVolumeTemplateVersion(ctx, volumeTemplateName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeTemplateVersionResponse(rsp)
}

// ListVolumesWithResponse request returning *ListVolumesResponse
func (c *ClientWithResponses) ListVolumesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumesResponse, error) {
	rsp, err := c.ListVolumes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, volumeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// GetVolumeWithResponse request returning *GetVolumeResponse
func (c *ClientWithResponses) GetVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*GetVolumeResponse, error) {
	rsp, err := c.GetVolume(ctx, volumeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVolumeResponse(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResponse
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, volumeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolume(ctx, volumeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// CheckWorkspaceAvailabilityWithBodyWithResponse request with arbitrary body returning *CheckWorkspaceAvailabilityResponse
func (c *ClientWithResponses) CheckWorkspaceAvailabilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error) {
	rsp, err := c.CheckWorkspaceAvailabilityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckWorkspaceAvailabilityResponse(rsp)
}

func (c *ClientWithResponses) CheckWorkspaceAvailabilityWithResponse(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error) {
	rsp, err := c.CheckWorkspaceAvailability(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckWorkspaceAvailabilityResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// GetWorkspaceWithResponse request returning *GetWorkspaceResponse
func (c *ClientWithResponses) GetWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error) {
	rsp, err := c.GetWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceResponse(rsp)
}

// UpdateWorkspaceWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceResponse
func (c *ClientWithResponses) UpdateWorkspaceWithBodyWithResponse(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspaceWithBody(ctx, workspaceName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceWithResponse(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspace(ctx, workspaceName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

// DeclineWorkspaceInvitationWithResponse request returning *DeclineWorkspaceInvitationResponse
func (c *ClientWithResponses) DeclineWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeclineWorkspaceInvitationResponse, error) {
	rsp, err := c.DeclineWorkspaceInvitation(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineWorkspaceInvitationResponse(rsp)
}

// AcceptWorkspaceInvitationWithResponse request returning *AcceptWorkspaceInvitationResponse
func (c *ClientWithResponses) AcceptWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*AcceptWorkspaceInvitationResponse, error) {
	rsp, err := c.AcceptWorkspaceInvitation(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptWorkspaceInvitationResponse(rsp)
}

// LeaveWorkspaceWithResponse request returning *LeaveWorkspaceResponse
func (c *ClientWithResponses) LeaveWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error) {
	rsp, err := c.LeaveWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveWorkspaceResponse(rsp)
}

// ParseListAgentsResponse parses an HTTP response from a ListAgentsWithResponse call
func ParseListAgentsResponse(rsp *http.Response) (*ListAgentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAgentResponse parses an HTTP response from a CreateAgentWithResponse call
func ParseCreateAgentResponse(rsp *http.Response) (*CreateAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAgentResponse parses an HTTP response from a DeleteAgentWithResponse call
func ParseDeleteAgentResponse(rsp *http.Response) (*DeleteAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAgentResponse parses an HTTP response from a GetAgentWithResponse call
func ParseGetAgentResponse(rsp *http.Response) (*GetAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAgentResponse parses an HTTP response from a UpdateAgentWithResponse call
func ParseUpdateAgentResponse(rsp *http.Response) (*UpdateAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAgentRevisionsResponse parses an HTTP response from a ListAgentRevisionsWithResponse call
func ParseListAgentRevisionsResponse(rsp *http.Response) (*ListAgentRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigurationResponse parses an HTTP response from a GetConfigurationWithResponse call
func ParseGetConfigurationResponse(rsp *http.Response) (*GetConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Configuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomDomainsResponse parses an HTTP response from a ListCustomDomainsWithResponse call
func ParseListCustomDomainsResponse(rsp *http.Response) (*ListCustomDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomDomainResponse parses an HTTP response from a CreateCustomDomainWithResponse call
func ParseCreateCustomDomainResponse(rsp *http.Response) (*CreateCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomDomainResponse parses an HTTP response from a DeleteCustomDomainWithResponse call
func ParseDeleteCustomDomainResponse(rsp *http.Response) (*DeleteCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomDomainResponse parses an HTTP response from a GetCustomDomainWithResponse call
func ParseGetCustomDomainResponse(rsp *http.Response) (*GetCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomDomainResponse parses an HTTP response from a UpdateCustomDomainWithResponse call
func ParseUpdateCustomDomainResponse(rsp *http.Response) (*UpdateCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVerifyCustomDomainResponse parses an HTTP response from a VerifyCustomDomainWithResponse call
func ParseVerifyCustomDomainResponse(rsp *http.Response) (*VerifyCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFunctionsResponse parses an HTTP response from a ListFunctionsWithResponse call
func ParseListFunctionsResponse(rsp *http.Response) (*ListFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateFunctionResponse parses an HTTP response from a CreateFunctionWithResponse call
func ParseCreateFunctionResponse(rsp *http.Response) (*CreateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFunctionResponse parses an HTTP response from a DeleteFunctionWithResponse call
func ParseDeleteFunctionResponse(rsp *http.Response) (*DeleteFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFunctionResponse parses an HTTP response from a GetFunctionWithResponse call
func ParseGetFunctionResponse(rsp *http.Response) (*GetFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFunctionResponse parses an HTTP response from a UpdateFunctionWithResponse call
func ParseUpdateFunctionResponse(rsp *http.Response) (*UpdateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFunctionRevisionsResponse parses an HTTP response from a ListFunctionRevisionsWithResponse call
func ParseListFunctionRevisionsResponse(rsp *http.Response) (*ListFunctionRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCleanupImagesResponse parses an HTTP response from a CleanupImagesWithResponse call
func ParseCleanupImagesResponse(rsp *http.Response) (*CleanupImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CleanupImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Number of images deleted
			Deleted *int `json:"deleted,omitempty"`

			// Message Result message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListImagesResponse parses an HTTP response from a ListImagesWithResponse call
func ParseListImagesResponse(rsp *http.Response) (*ListImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetImageResponse parses an HTTP response from a GetImageWithResponse call
func ParseGetImageResponse(rsp *http.Response) (*GetImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageTagResponse parses an HTTP response from a DeleteImageTagWithResponse call
func ParseDeleteImageTagResponse(rsp *http.Response) (*DeleteImageTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIntegrationConnectionsResponse parses an HTTP response from a ListIntegrationConnectionsWithResponse call
func ParseListIntegrationConnectionsResponse(rsp *http.Response) (*ListIntegrationConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIntegrationConnectionResponse parses an HTTP response from a CreateIntegrationConnectionWithResponse call
func ParseCreateIntegrationConnectionResponse(rsp *http.Response) (*CreateIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIntegrationConnectionResponse parses an HTTP response from a DeleteIntegrationConnectionWithResponse call
func ParseDeleteIntegrationConnectionResponse(rsp *http.Response) (*DeleteIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConnectionResponse parses an HTTP response from a GetIntegrationConnectionWithResponse call
func ParseGetIntegrationConnectionResponse(rsp *http.Response) (*GetIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateIntegrationConnectionResponse parses an HTTP response from a UpdateIntegrationConnectionWithResponse call
func ParseUpdateIntegrationConnectionResponse(rsp *http.Response) (*UpdateIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConnectionModelEndpointConfigurationsResponse parses an HTTP response from a GetIntegrationConnectionModelEndpointConfigurationsWithResponse call
func ParseGetIntegrationConnectionModelEndpointConfigurationsResponse(rsp *http.Response) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionModelEndpointConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListIntegrationConnectionModelsResponse parses an HTTP response from a ListIntegrationConnectionModelsWithResponse call
func ParseListIntegrationConnectionModelsResponse(rsp *http.Response) (*ListIntegrationConnectionModelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConnectionModelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIntegrationConnectionModelResponse parses an HTTP response from a GetIntegrationConnectionModelWithResponse call
func ParseGetIntegrationConnectionModelResponse(rsp *http.Response) (*GetIntegrationConnectionModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIntegrationResponse parses an HTTP response from a GetIntegrationWithResponse call
func ParseGetIntegrationResponse(rsp *http.Response) (*GetIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJobResponse parses an HTTP response from a CreateJobWithResponse call
func ParseCreateJobResponse(rsp *http.Response) (*CreateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobResponse parses an HTTP response from a DeleteJobWithResponse call
func ParseDeleteJobResponse(rsp *http.Response) (*DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateJobResponse parses an HTTP response from a UpdateJobWithResponse call
func ParseUpdateJobResponse(rsp *http.Response) (*UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobExecutionsResponse parses an HTTP response from a ListJobExecutionsWithResponse call
func ParseListJobExecutionsResponse(rsp *http.Response) (*ListJobExecutionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobExecutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJobExecutionResponse parses an HTTP response from a CreateJobExecutionWithResponse call
func ParseCreateJobExecutionResponse(rsp *http.Response) (*CreateJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateJobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobExecutionResponse parses an HTTP response from a DeleteJobExecutionWithResponse call
func ParseDeleteJobExecutionResponse(rsp *http.Response) (*DeleteJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobExecutionResponse parses an HTTP response from a GetJobExecutionWithResponse call
func ParseGetJobExecutionResponse(rsp *http.Response) (*GetJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobRevisionsResponse parses an HTTP response from a ListJobRevisionsWithResponse call
func ParseListJobRevisionsResponse(rsp *http.Response) (*ListJobRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLocationsResponse parses an HTTP response from a ListLocationsWithResponse call
func ParseListLocationsResponse(rsp *http.Response) (*ListLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMCPHubDefinitionsResponse parses an HTTP response from a ListMCPHubDefinitionsWithResponse call
func ParseListMCPHubDefinitionsResponse(rsp *http.Response) (*ListMCPHubDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMCPHubDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MCPDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelsResponse parses an HTTP response from a ListModelsWithResponse call
func ParseListModelsResponse(rsp *http.Response) (*ListModelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateModelResponse parses an HTTP response from a CreateModelWithResponse call
func ParseCreateModelResponse(rsp *http.Response) (*CreateModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteModelResponse parses an HTTP response from a DeleteModelWithResponse call
func ParseDeleteModelResponse(rsp *http.Response) (*DeleteModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetModelResponse parses an HTTP response from a GetModelWithResponse call
func ParseGetModelResponse(rsp *http.Response) (*GetModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateModelResponse parses an HTTP response from a UpdateModelWithResponse call
func ParseUpdateModelResponse(rsp *http.Response) (*UpdateModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListModelRevisionsResponse parses an HTTP response from a ListModelRevisionsWithResponse call
func ParseListModelRevisionsResponse(rsp *http.Response) (*ListModelRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPublicIpsResponse parses an HTTP response from a ListPublicIpsWithResponse call
func ParseListPublicIpsResponse(rsp *http.Response) (*ListPublicIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPublicIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicIps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxHubDefinitionsResponse parses an HTTP response from a ListSandboxHubDefinitionsWithResponse call
func ParseListSandboxHubDefinitionsResponse(rsp *http.Response) (*ListSandboxHubDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxHubDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SandboxDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxesResponse parses an HTTP response from a ListSandboxesWithResponse call
func ParseListSandboxesResponse(rsp *http.Response) (*ListSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSandboxResponse parses an HTTP response from a CreateSandboxWithResponse call
func ParseCreateSandboxResponse(rsp *http.Response) (*CreateSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SandboxError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SandboxError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SandboxError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest SandboxError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SandboxError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxResponse parses an HTTP response from a DeleteSandboxWithResponse call
func ParseDeleteSandboxResponse(rsp *http.Response) (*DeleteSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxResponse parses an HTTP response from a GetSandboxWithResponse call
func ParseGetSandboxResponse(rsp *http.Response) (*GetSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSandboxResponse parses an HTTP response from a UpdateSandboxWithResponse call
func ParseUpdateSandboxResponse(rsp *http.Response) (*UpdateSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSandboxPreviewsResponse parses an HTTP response from a ListSandboxPreviewsWithResponse call
func ParseListSandboxPreviewsResponse(rsp *http.Response) (*ListSandboxPreviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxPreviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxPreviewResponse parses an HTTP response from a CreateSandboxPreviewWithResponse call
func ParseCreateSandboxPreviewResponse(rsp *http.Response) (*CreateSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxPreviewResponse parses an HTTP response from a DeleteSandboxPreviewWithResponse call
func ParseDeleteSandboxPreviewResponse(rsp *http.Response) (*DeleteSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSandboxPreviewResponse parses an HTTP response from a GetSandboxPreviewWithResponse call
func ParseGetSandboxPreviewResponse(rsp *http.Response) (*GetSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSandboxPreviewResponse parses an HTTP response from a UpdateSandboxPreviewWithResponse call
func ParseUpdateSandboxPreviewResponse(rsp *http.Response) (*UpdateSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxPreviewTokensResponse parses an HTTP response from a ListSandboxPreviewTokensWithResponse call
func ParseListSandboxPreviewTokensResponse(rsp *http.Response) (*ListSandboxPreviewTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxPreviewTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PreviewToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxPreviewTokenResponse parses an HTTP response from a CreateSandboxPreviewTokenWithResponse call
func ParseCreateSandboxPreviewTokenResponse(rsp *http.Response) (*CreateSandboxPreviewTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxPreviewTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreviewToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxPreviewTokenResponse parses an HTTP response from a DeleteSandboxPreviewTokenWithResponse call
func ParseDeleteSandboxPreviewTokenResponse(rsp *http.Response) (*DeleteSandboxPreviewTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxPreviewTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Message Success message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceServiceAccountsResponse parses an HTTP response from a GetWorkspaceServiceAccountsWithResponse call
func ParseGetWorkspaceServiceAccountsResponse(rsp *http.Response) (*GetWorkspaceServiceAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceServiceAccountResponse parses an HTTP response from a CreateWorkspaceServiceAccountWithResponse call
func ParseCreateWorkspaceServiceAccountResponse(rsp *http.Response) (*CreateWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// ClientSecret Service account client secret (only returned on creation)
			ClientSecret *string `json:"client_secret,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceServiceAccountResponse parses an HTTP response from a DeleteWorkspaceServiceAccountWithResponse call
func ParseDeleteWorkspaceServiceAccountResponse(rsp *http.Response) (*DeleteWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWorkspaceServiceAccountResponse parses an HTTP response from a UpdateWorkspaceServiceAccountWithResponse call
func ParseUpdateWorkspaceServiceAccountResponse(rsp *http.Response) (*UpdateWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListApiKeysForServiceAccountResponse parses an HTTP response from a ListApiKeysForServiceAccountWithResponse call
func ParseListApiKeysForServiceAccountResponse(rsp *http.Response) (*ListApiKeysForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApiKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyForServiceAccountResponse parses an HTTP response from a CreateApiKeyForServiceAccountWithResponse call
func ParseCreateApiKeyForServiceAccountResponse(rsp *http.Response) (*CreateApiKeyForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeyForServiceAccountResponse parses an HTTP response from a DeleteApiKeyForServiceAccountWithResponse call
func ParseDeleteApiKeyForServiceAccountResponse(rsp *http.Response) (*DeleteApiKeyForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeyForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTemplatesResponse parses an HTTP response from a ListTemplatesWithResponse call
func ParseListTemplatesResponse(rsp *http.Response) (*ListTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplateResponse parses an HTTP response from a GetTemplateWithResponse call
func ParseGetTemplateResponse(rsp *http.Response) (*GetTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspaceUsersResponse parses an HTTP response from a ListWorkspaceUsersWithResponse call
func ParseListWorkspaceUsersResponse(rsp *http.Response) (*ListWorkspaceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteWorkspaceUserResponse parses an HTTP response from a InviteWorkspaceUserWithResponse call
func ParseInviteWorkspaceUserResponse(rsp *http.Response) (*InviteWorkspaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteWorkspaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveWorkspaceUserResponse parses an HTTP response from a RemoveWorkspaceUserWithResponse call
func ParseRemoveWorkspaceUserResponse(rsp *http.Response) (*RemoveWorkspaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveWorkspaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateWorkspaceUserRoleResponse parses an HTTP response from a UpdateWorkspaceUserRoleWithResponse call
func ParseUpdateWorkspaceUserRoleResponse(rsp *http.Response) (*UpdateWorkspaceUserRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceUserRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspaceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVolumeTemplatesResponse parses an HTTP response from a ListVolumeTemplatesWithResponse call
func ParseListVolumeTemplatesResponse(rsp *http.Response) (*ListVolumeTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVolumeTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeTemplateResponse parses an HTTP response from a CreateVolumeTemplateWithResponse call
func ParseCreateVolumeTemplateResponse(rsp *http.Response) (*CreateVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeTemplateResponse parses an HTTP response from a DeleteVolumeTemplateWithResponse call
func ParseDeleteVolumeTemplateResponse(rsp *http.Response) (*DeleteVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVolumeTemplateResponse parses an HTTP response from a GetVolumeTemplateWithResponse call
func ParseGetVolumeTemplateResponse(rsp *http.Response) (*GetVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeTemplateResponse parses an HTTP response from a UpdateVolumeTemplateWithResponse call
func ParseUpdateVolumeTemplateResponse(rsp *http.Response) (*UpdateVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeTemplateVersionResponse parses an HTTP response from a DeleteVolumeTemplateVersionWithResponse call
func ParseDeleteVolumeTemplateVersionResponse(rsp *http.Response) (*DeleteVolumeTemplateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeTemplateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`

			// Template Volume template for creating pre-configured volumes
			Template *VolumeTemplate `json:"template,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVolumesResponse parses an HTTP response from a ListVolumesWithResponse call
func ParseListVolumesResponse(rsp *http.Response) (*ListVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVolumeResponse parses an HTTP response from a GetVolumeWithResponse call
func ParseGetVolumeResponse(rsp *http.Response) (*GetVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResponse parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResponse(rsp *http.Response) (*UpdateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCheckWorkspaceAvailabilityResponse parses an HTTP response from a CheckWorkspaceAvailabilityWithResponse call
func ParseCheckWorkspaceAvailabilityResponse(rsp *http.Response) (*CheckWorkspaceAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckWorkspaceAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceResponse parses an HTTP response from a GetWorkspaceWithResponse call
func ParseGetWorkspaceResponse(rsp *http.Response) (*GetWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateWorkspaceResponse parses an HTTP response from a UpdateWorkspaceWithResponse call
func ParseUpdateWorkspaceResponse(rsp *http.Response) (*UpdateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeclineWorkspaceInvitationResponse parses an HTTP response from a DeclineWorkspaceInvitationWithResponse call
func ParseDeclineWorkspaceInvitationResponse(rsp *http.Response) (*DeclineWorkspaceInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineWorkspaceInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAcceptWorkspaceInvitationResponse parses an HTTP response from a AcceptWorkspaceInvitationWithResponse call
func ParseAcceptWorkspaceInvitationResponse(rsp *http.Response) (*AcceptWorkspaceInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptWorkspaceInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitationAccept
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveWorkspaceResponse parses an HTTP response from a LeaveWorkspaceWithResponse call
func ParseLeaveWorkspaceResponse(rsp *http.Response) (*LeaveWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"vEkCAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
