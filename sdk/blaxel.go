// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/blaxel-ai/toolkit/cli/register"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Agent Agent
type Agent struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Agent specification
	Spec *AgentSpec `json:"spec,omitempty"`

	// Status Agent status
	Status *string `json:"status,omitempty"`
}

// AgentSpec defines model for AgentSpec.
type AgentSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Description Description, small description computed from the prompt
	Description *string `json:"description,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Repository Repository
	Repository *Repository `json:"repository,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	// ApiKey Api key
	ApiKey *string `json:"apiKey,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// ExpiresIn Duration until expiration (in seconds)
	ExpiresIn *string `json:"expires_in,omitempty"`

	// Id Api key id, to retrieve it from the API
	Id *string `json:"id,omitempty"`

	// Name Name for the API key
	Name *string `json:"name,omitempty"`

	// Sub User subject identifier
	Sub *string `json:"sub,omitempty"`

	// SubType Subject type
	SubType *string `json:"sub_type,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Configuration Configuration
type Configuration struct {
	// Continents Continents
	Continents *[]Continent `json:"continents,omitempty"`

	// Countries Countries
	Countries *[]Country `json:"countries,omitempty"`

	// PrivateLocations Private locations managed with blaxel operator
	PrivateLocations *[]PrivateLocation `json:"privateLocations,omitempty"`

	// Regions Regions
	Regions *[]Region `json:"regions,omitempty"`
}

// Continent Continent
type Continent struct {
	// DisplayName Continent display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Continent code
	Name *string `json:"name,omitempty"`
}

// CoreEvent Core event
type CoreEvent struct {
	// CanaryRevision Canary revisionID link to the event
	CanaryRevision *string `json:"canaryRevision,omitempty"`

	// Message Event message
	Message *string `json:"message,omitempty"`

	// Revision RevisionID link to the event
	Revision *string `json:"revision,omitempty"`

	// Status Event status
	Status *string `json:"status,omitempty"`

	// Time Event time
	Time *string `json:"time,omitempty"`

	// Type Event type
	Type *string `json:"type,omitempty"`
}

// CoreEvents Core events
type CoreEvents = []CoreEvent

// CoreSpec Core specification
type CoreSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`
}

// Country Configuration
type Country struct {
	// DisplayName Country display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Country code
	Name *string `json:"name,omitempty"`
}

// CreateJobExecutionRequest Request to create a job execution
type CreateJobExecutionRequest struct {
	// ExecutionId Execution ID (optional, will be generated if not provided)
	ExecutionId *string `json:"executionId,omitempty"`

	// Id Unique message ID
	Id *string `json:"id,omitempty"`

	// JobId Job ID
	JobId *string `json:"jobId,omitempty"`

	// Tasks Array of task parameters for parallel execution
	Tasks *[]map[string]interface{} `json:"tasks,omitempty"`

	// WorkspaceId Workspace ID
	WorkspaceId *string `json:"workspaceId,omitempty"`
}

// CustomDomain Custom domain for preview deployments
// The custom domain represents a base domain (e.g., example.com) that will be used
// to serve preview deployments. Each preview will be accessible at a subdomain:
// <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
type CustomDomain struct {
	// Metadata Custom domain metadata
	Metadata *CustomDomainMetadata `json:"metadata,omitempty"`

	// Spec Custom domain specification
	Spec *CustomDomainSpec `json:"spec,omitempty"`
}

// CustomDomainMetadata defines model for CustomDomainMetadata.
type CustomDomainMetadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Display name for the custom domain
	DisplayName *string `json:"displayName,omitempty"`

	// Labels Labels
	Labels *MetadataLabels `json:"labels,omitempty"`

	// Name Domain name (e.g., "example.com")
	Name *string `json:"name,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// CustomDomainSpec Custom domain specification
type CustomDomainSpec struct {
	// CnameRecords CNAME target for the domain
	CnameRecords *string `json:"cnameRecords,omitempty"`

	// LastVerifiedAt Last verification attempt timestamp
	LastVerifiedAt *string `json:"lastVerifiedAt,omitempty"`

	// Region Region that the custom domain is associated with
	Region *string `json:"region,omitempty"`

	// Status Current status of the domain (pending, verified, failed)
	Status *string `json:"status,omitempty"`

	// TxtRecords Map of TXT record names to values for domain verification
	TxtRecords *map[string]string `json:"txtRecords,omitempty"`

	// VerificationError Error message if verification failed
	VerificationError *string `json:"verificationError,omitempty"`
}

// ExpirationPolicy Expiration policy for sandbox lifecycle management
type ExpirationPolicy struct {
	// Action Action to take when policy is triggered
	Action *string `json:"action,omitempty"`

	// Type Type of expiration policy
	Type *string `json:"type,omitempty"`

	// Value Duration value (e.g., '1h', '24h', '7d')
	Value *string `json:"value,omitempty"`
}

// Flavor A type of hardware available for deployments
type Flavor struct {
	// Name Flavor name (e.g. t4)
	Name *string `json:"name,omitempty"`

	// Type Flavor type (e.g. cpu, gpu)
	Type *string `json:"type,omitempty"`
}

// Flavors Types of hardware available for deployments
type Flavors = []Flavor

// Function Function
type Function struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Function specification
	Spec *FunctionSpec `json:"spec,omitempty"`

	// Status Function status
	Status *string `json:"status,omitempty"`
}

// FunctionSpec defines model for FunctionSpec.
type FunctionSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Description Function description, very important for the agent function to work with an LLM
	Description *string `json:"description,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// Image defines model for Image.
type Image struct {
	Metadata *ImageMetadata `json:"metadata,omitempty"`
	Spec     *ImageSpec     `json:"spec,omitempty"`
}

// ImageMetadata defines model for ImageMetadata.
type ImageMetadata struct {
	// CreatedAt The date and time when the image was created.
	CreatedAt *string `json:"createdAt,omitempty"`

	// DisplayName The display name of the image (registry/workspace/repository).
	DisplayName *string `json:"displayName,omitempty"`

	// LastDeployedAt The date and time when the image was last deployed (most recent across all tags).
	LastDeployedAt *string `json:"lastDeployedAt,omitempty"`

	// Name The name of the image (repository name).
	Name *string `json:"name,omitempty"`

	// ResourceType The resource type of the image.
	ResourceType *string `json:"resourceType,omitempty"`

	// UpdatedAt The date and time when the image was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Workspace The workspace of the image.
	Workspace *string `json:"workspace,omitempty"`
}

// ImageSpec defines model for ImageSpec.
type ImageSpec struct {
	// Size The size of the image in bytes.
	Size *int `json:"size,omitempty"`

	// Tags List of tags available for this image.
	Tags *[]ImageTag `json:"tags,omitempty"`
}

// ImageTag defines model for ImageTag.
type ImageTag struct {
	// CreatedAt The date and time when the tag was created.
	CreatedAt *string `json:"createdAt,omitempty"`

	// Name The name of the tag.
	Name *string `json:"name,omitempty"`

	// Size The size of the image in bytes.
	Size *int `json:"size,omitempty"`

	// UpdatedAt The date and time when the tag was last updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Integration Integration
type Integration struct {
	// AdditionalInfos Integration additional infos
	AdditionalInfos *map[string]string `json:"additionalInfos,omitempty"`

	// Endpoints Integration endpoints
	Endpoints *IntegrationEndpoints `json:"endpoints,omitempty"`

	// Headers Integration headers
	Headers *IntegrationHeaders `json:"headers,omitempty"`

	// Name Integration name
	Name *string `json:"name,omitempty"`

	// Organizations Integration organizations
	Organizations *[]IntegrationOrganization `json:"organizations,omitempty"`

	// Params Integration query params
	Params *IntegrationQueryParams `json:"params,omitempty"`

	// Repositories Integration repositories
	Repositories *[]IntegrationRepository `json:"repositories,omitempty"`
}

// IntegrationConnection Integration Connection
type IntegrationConnection struct {
	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Integration connection specification
	Spec *IntegrationConnectionSpec `json:"spec,omitempty"`
}

// IntegrationConnectionSpec Integration connection specification
type IntegrationConnectionSpec struct {
	// Config Additional configuration for the integration
	Config *map[string]string `json:"config,omitempty"`

	// Integration Integration type
	Integration *string `json:"integration,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Secret Integration secret
	Secret *map[string]string `json:"secret,omitempty"`
}

// IntegrationConnectionsList defines model for IntegrationConnectionsList.
type IntegrationConnectionsList = []string

// IntegrationEndpoint Integration endpoint
type IntegrationEndpoint struct {
	// Body Integration endpoint body
	Body *string `json:"body,omitempty"`

	// IgnoreModels Integration endpoint ignore models
	IgnoreModels *[]interface{} `json:"ignoreModels,omitempty"`

	// Method Integration endpoint method
	Method *string `json:"method,omitempty"`

	// Models Integration endpoint models
	Models *[]interface{} `json:"models,omitempty"`

	// StreamKey Integration endpoint stream key
	StreamKey *string `json:"streamKey,omitempty"`

	// StreamToken Integration endpoint token
	StreamToken *IntegrationEndpointToken `json:"streamToken,omitempty"`

	// Token Integration endpoint token
	Token *IntegrationEndpointToken `json:"token,omitempty"`
}

// IntegrationEndpointToken Integration endpoint token
type IntegrationEndpointToken struct {
	// Received Integration endpoint token received
	Received *string `json:"received,omitempty"`

	// Sent Integration endpoint token sent
	Sent *string `json:"sent,omitempty"`

	// Total Integration endpoint token total
	Total *string `json:"total,omitempty"`
}

// IntegrationEndpoints Integration endpoints
type IntegrationEndpoints map[string]IntegrationEndpoint

// IntegrationHeaders Integration headers
type IntegrationHeaders map[string]string

// IntegrationOrganization Integration organization
type IntegrationOrganization struct {
	// AvatarUrl Provider organization avatar URL
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// DisplayName Provider organization display name
	DisplayName *string `json:"displayName,omitempty"`

	// Id Provider organization ID
	Id *string `json:"id,omitempty"`

	// Name Provider organization name
	Name *string `json:"name,omitempty"`
}

// IntegrationQueryParams Integration query params
type IntegrationQueryParams map[string]string

// IntegrationRepository Integration repository
type IntegrationRepository struct {
	// Id Repository ID
	Id *string `json:"id,omitempty"`

	// IsBl Whether the repository has Blaxel imports
	IsBl *bool `json:"isBl,omitempty"`

	// Name Repository name
	Name *string `json:"name,omitempty"`

	// Organization Repository owner
	Organization *string `json:"organization,omitempty"`

	// Url Repository URL
	Url *string `json:"url,omitempty"`
}

// Job Job
type Job struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Job specification
	Spec *JobSpec `json:"spec,omitempty"`

	// Status Job status
	Status *string `json:"status,omitempty"`
}

// JobExecution Job execution
type JobExecution struct {
	// Metadata Job execution metadata
	Metadata *JobExecutionMetadata `json:"metadata,omitempty"`

	// Spec Job execution specification
	Spec *JobExecutionSpec `json:"spec,omitempty"`

	// Stats Job execution statistics
	Stats *JobExecutionStats `json:"stats,omitempty"`

	// Status Job execution status
	Status *JobExecutionStatus `json:"status,omitempty"`

	// Tasks List of execution tasks
	Tasks *[]JobExecutionTask `json:"tasks,omitempty"`
}

// JobExecutionMetadata Job execution metadata
type JobExecutionMetadata struct {
	// Cluster Cluster ID
	Cluster *string `json:"cluster,omitempty"`

	// CompletedAt Completion timestamp
	CompletedAt *string `json:"completedAt,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"createdAt,omitempty"`

	// DeletedAt Deletion timestamp
	DeletedAt *string `json:"deletedAt,omitempty"`

	// ExpiredAt Expiration timestamp
	ExpiredAt *string `json:"expiredAt,omitempty"`

	// Id Execution ID
	Id *string `json:"id,omitempty"`

	// Job Job name
	Job *string `json:"job,omitempty"`

	// StartedAt Start timestamp
	StartedAt *string `json:"startedAt,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Workspace Workspace ID
	Workspace *string `json:"workspace,omitempty"`
}

// JobExecutionSpec Job execution specification
type JobExecutionSpec struct {
	// Parallelism Number of parallel tasks
	Parallelism *int `json:"parallelism,omitempty"`

	// Tasks List of execution tasks
	Tasks *[]JobExecutionTask `json:"tasks,omitempty"`

	// Timeout Job timeout in seconds (captured at execution creation time)
	Timeout *int `json:"timeout,omitempty"`
}

// JobExecutionStats Job execution statistics
type JobExecutionStats struct {
	// Cancelled Number of cancelled tasks
	Cancelled *int `json:"cancelled,omitempty"`

	// Failure Number of failed tasks
	Failure *int `json:"failure,omitempty"`

	// Retried Number of retried tasks
	Retried *int `json:"retried,omitempty"`

	// Running Number of running tasks
	Running *int `json:"running,omitempty"`

	// Success Number of successful tasks
	Success *int `json:"success,omitempty"`

	// Total Total number of tasks
	Total *int `json:"total,omitempty"`
}

// JobExecutionStatus Job execution status
type JobExecutionStatus = string

// JobExecutionTask Job execution task
type JobExecutionTask struct {
	// Conditions Task conditions
	Conditions *[]JobExecutionTaskCondition `json:"conditions,omitempty"`

	// Metadata Job execution task metadata
	Metadata *JobExecutionTaskMetadata `json:"metadata,omitempty"`

	// Spec Job execution task specification
	Spec *JobExecutionTaskSpec `json:"spec,omitempty"`

	// Status Job execution task status
	Status *JobExecutionTaskStatus `json:"status,omitempty"`
}

// JobExecutionTaskCondition Job execution task condition
type JobExecutionTaskCondition struct {
	// ExecutionReason Execution reason
	ExecutionReason *string `json:"executionReason,omitempty"`

	// Message Condition message
	Message *string `json:"message,omitempty"`

	// Reason Condition reason
	Reason *string `json:"reason,omitempty"`

	// Severity Condition severity
	Severity *string `json:"severity,omitempty"`

	// State Condition state
	State *string `json:"state,omitempty"`

	// Type Condition type
	Type *string `json:"type,omitempty"`
}

// JobExecutionTaskMetadata Job execution task metadata
type JobExecutionTaskMetadata struct {
	// CompletedAt Completion timestamp
	CompletedAt *string `json:"completedAt,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"createdAt,omitempty"`

	// Name Task name
	Name *string `json:"name,omitempty"`

	// ScheduledAt Scheduled timestamp
	ScheduledAt *string `json:"scheduledAt,omitempty"`

	// StartedAt Start timestamp
	StartedAt *string `json:"startedAt,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// JobExecutionTaskSpec Job execution task specification
type JobExecutionTaskSpec struct {
	// MaxRetries Maximum number of retries
	MaxRetries *int `json:"maxRetries,omitempty"`

	// Timeout Task timeout duration
	Timeout *string `json:"timeout,omitempty"`
}

// JobExecutionTaskStatus Job execution task status
type JobExecutionTaskStatus = string

// JobSpec defines model for JobSpec.
type JobSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Region Region where the job should be created (e.g. us-was-1, eu-lon-1)
	Region *string `json:"region,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Triggers Triggers to use your agent
	Triggers *Triggers `json:"triggers,omitempty"`
}

// LocationResponse Location availability for policies
type LocationResponse struct {
	// Continent Continent of the location
	Continent *string `json:"continent,omitempty"`

	// Country Country of the location
	Country *string `json:"country,omitempty"`

	// Flavors Hardware flavors available in the location
	Flavors *[]Flavor `json:"flavors,omitempty"`

	// Location Name of the location
	Location *string `json:"location,omitempty"`

	// Region Region of the location
	Region *string `json:"region,omitempty"`

	// Status Status of the location
	Status *string `json:"status,omitempty"`
}

// MCPDefinition defines model for MCPDefinition.
type MCPDefinition struct {
	// Categories Categories of the artifact
	Categories *[]interface{} `json:"categories,omitempty"`

	// ComingSoon If the artifact is coming soon
	ComingSoon *bool `json:"coming_soon,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// Description Description of the artifact
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the artifact
	DisplayName *string `json:"displayName,omitempty"`

	// Enterprise If the artifact is enterprise
	Enterprise *bool `json:"enterprise,omitempty"`

	// Entrypoint Entrypoint of the artifact
	Entrypoint *map[string]interface{} `json:"entrypoint,omitempty"`

	// Form Form of the artifact
	Form *map[string]interface{} `json:"form,omitempty"`

	// Hidden If the artifact is hidden
	Hidden *bool `json:"hidden,omitempty"`

	// HiddenSecrets Hidden secrets of the artifact
	HiddenSecrets *[]string `json:"hiddenSecrets,omitempty"`

	// Icon Icon of the artifact
	Icon *string `json:"icon,omitempty"`

	// Image Image of the artifact
	Image *string `json:"image,omitempty"`

	// Integration Integration of the artifact
	Integration *string `json:"integration,omitempty"`

	// LongDescription Long description of the artifact
	LongDescription *string `json:"longDescription,omitempty"`

	// Name Name of the artifact
	Name *string `json:"name,omitempty"`

	// Transport Transport compatibility for the MCP, can be "websocket" or "http-stream"
	Transport *string `json:"transport,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// Url URL of the artifact
	Url *string `json:"url,omitempty"`
}

// Metadata defines model for Metadata.
type Metadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Model display name
	DisplayName *string `json:"displayName,omitempty"`

	// Labels Labels
	Labels *MetadataLabels `json:"labels,omitempty"`

	// Name Model name
	Name *string `json:"name,omitempty"`

	// Plan Plan
	Plan interface{} `json:"plan,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Url URL
	Url *string `json:"url,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// MetadataLabels Labels
type MetadataLabels map[string]string

// Model Logical object representing a model
type Model struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Model specification
	Spec *ModelSpec `json:"spec,omitempty"`

	// Status Model status
	Status *string `json:"status,omitempty"`
}

// ModelSpec defines model for ModelSpec.
type ModelSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`
	Policies               *PoliciesList               `json:"policies,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`
}

// OwnerFields Owner fields for Persistance
type OwnerFields struct {
	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// PendingInvitation defines model for PendingInvitation.
type PendingInvitation struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// Email User email
	Email *string `json:"email,omitempty"`

	// InvitedBy User sub
	InvitedBy *string `json:"invitedBy,omitempty"`

	// Role ACL role
	Role *string `json:"role,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PendingInvitationAccept Pending invitation accept
type PendingInvitationAccept struct {
	// Email User email
	Email *string `json:"email,omitempty"`

	// Workspace Workspace
	Workspace *Workspace `json:"workspace,omitempty"`
}

// PoliciesList defines model for PoliciesList.
type PoliciesList = []string

// Policy Rule that controls how a deployment is made and served (e.g. location restrictions)
type Policy struct {
	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Policy specification
	Spec *PolicySpec `json:"spec,omitempty"`
}

// PolicyLocation Policy location
type PolicyLocation struct {
	// Name Policy location name
	Name *string `json:"name,omitempty"`

	// Type Policy location type
	Type *string `json:"type,omitempty"`
}

// PolicyLocations PolicyLocations is a local type that wraps a slice of Location
type PolicyLocations = []PolicyLocation

// PolicyMaxTokens PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
type PolicyMaxTokens struct {
	// Granularity Granularity
	Granularity *string `json:"granularity,omitempty"`

	// Input Input
	Input *int `json:"input,omitempty"`

	// Output Output
	Output *int `json:"output,omitempty"`

	// RatioInputOverOutput RatioInputOverOutput
	RatioInputOverOutput *int `json:"ratioInputOverOutput,omitempty"`

	// Step Step
	Step *int `json:"step,omitempty"`

	// Total Total
	Total *int `json:"total,omitempty"`
}

// PolicyResourceType PolicyResourceType is a type of resource, e.g. model, function, etc.
type PolicyResourceType = string

// PolicyResourceTypes PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
type PolicyResourceTypes = []PolicyResourceType

// PolicySpec Policy specification
type PolicySpec struct {
	// Flavors Types of hardware available for deployments
	Flavors *Flavors `json:"flavors,omitempty"`

	// Locations PolicyLocations is a local type that wraps a slice of Location
	Locations *PolicyLocations `json:"locations,omitempty"`

	// MaxTokens PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
	MaxTokens *PolicyMaxTokens `json:"maxTokens,omitempty"`

	// ResourceTypes PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
	ResourceTypes *PolicyResourceTypes `json:"resourceTypes,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool `json:"sandbox,omitempty"`

	// Type Policy type, can be location or flavor
	Type *string `json:"type,omitempty"`
}

// Port A port for a resource
type Port struct {
	// Name The name of the port
	Name *string `json:"name,omitempty"`

	// Protocol The protocol of the port
	Protocol *string `json:"protocol,omitempty"`

	// Target The target port of the port
	Target *int `json:"target,omitempty"`
}

// Ports Set of ports for a resource
type Ports = []Port

// Preview Preview of a Resource
type Preview struct {
	// Metadata PreviewMetadata
	Metadata *PreviewMetadata `json:"metadata,omitempty"`

	// Spec Preview of a Resource
	Spec *PreviewSpec `json:"spec,omitempty"`
}

// PreviewMetadata defines model for PreviewMetadata.
type PreviewMetadata struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Model display name
	DisplayName *string `json:"displayName,omitempty"`

	// Name Preview name
	Name *string `json:"name,omitempty"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PreviewSpec Preview of a Resource
type PreviewSpec struct {
	// CustomDomain Custom domain bound to this preview
	CustomDomain *string `json:"customDomain,omitempty"`

	// Expires The expiration date for the preview in ISO 8601 format - 2024-12-31T23:59:59Z
	Expires *string `json:"expires,omitempty"`

	// Port Port of the preview
	Port *int `json:"port,omitempty"`

	// PrefixUrl Prefix URL
	PrefixUrl *string `json:"prefixUrl,omitempty"`

	// Public Whether the preview is public
	Public *bool `json:"public,omitempty"`

	// Region Region where the preview is deployed, this is readonly
	Region *string `json:"region,omitempty"`

	// RequestHeaders Those headers will be set in all requests to your preview. This is especially useful to set the Authorization header.
	RequestHeaders *map[string]string `json:"requestHeaders,omitempty"`

	// ResponseHeaders Those headers will be set in all responses of your preview. This is especially useful to set the CORS headers.
	ResponseHeaders *map[string]string `json:"responseHeaders,omitempty"`

	// Ttl Time to live for the preview (e.g., "1h", "24h", "7d"). After this duration, the preview will be automatically deleted.
	Ttl *string `json:"ttl,omitempty"`

	// Url URL of the preview
	Url *string `json:"url,omitempty"`
}

// PreviewToken Token for a Preview
type PreviewToken struct {
	// Metadata PreviewTokenMetadata
	Metadata *PreviewTokenMetadata `json:"metadata,omitempty"`

	// Spec Spec for a Preview Token
	Spec *PreviewTokenSpec `json:"spec,omitempty"`
}

// PreviewTokenMetadata PreviewTokenMetadata
type PreviewTokenMetadata struct {
	// Name Token name
	Name *string `json:"name,omitempty"`

	// PreviewName Preview name
	PreviewName *string `json:"previewName,omitempty"`

	// ResourceName Resource name
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceType Resource type
	ResourceType *string `json:"resourceType,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// PreviewTokenSpec Spec for a Preview Token
type PreviewTokenSpec struct {
	// Expired Whether the token is expired
	Expired *bool `json:"expired,omitempty"`

	// ExpiresAt Expiration time of the token
	ExpiresAt *string `json:"expiresAt,omitempty"`

	// Token Token
	Token *string `json:"token,omitempty"`
}

// PrivateLocation Private location available for policies
type PrivateLocation struct {
	// Name Location name
	Name *string `json:"name,omitempty"`
}

// PublicIp defines model for PublicIp.
type PublicIp struct {
	// Description Description of the region/location
	Description *string `json:"description,omitempty"`

	// Ipv4Cidrs List of public ipv4 addresses
	Ipv4Cidrs *[]string `json:"ipv4Cidrs,omitempty"`

	// Ipv6Cidrs List of public ipv6 addresses
	Ipv6Cidrs *[]string `json:"ipv6Cidrs,omitempty"`
}

// PublicIps defines model for PublicIps.
type PublicIps map[string]PublicIp

// Region Region
type Region struct {
	// Allowed Region display name
	Allowed *string `json:"allowed,omitempty"`

	// Continent Region display name
	Continent *string `json:"continent,omitempty"`

	// Country Region display name
	Country *string `json:"country,omitempty"`

	// InfoGeneration Region display name
	InfoGeneration *string `json:"infoGeneration,omitempty"`

	// Location Region display name
	Location *string `json:"location,omitempty"`

	// Name Region name
	Name *string `json:"name,omitempty"`
}

// Repository Repository
type Repository struct {
	// Type Repository type
	Type *string `json:"type,omitempty"`

	// Url Repository URL
	Url *string `json:"url,omitempty"`
}

// RevisionConfiguration Revision configuration
type RevisionConfiguration struct {
	// Active Active revision id
	Active *string `json:"active,omitempty"`

	// Canary Canary revision id
	Canary *string `json:"canary,omitempty"`

	// CanaryPercent Canary revision percent
	CanaryPercent *int `json:"canaryPercent,omitempty"`

	// StickySessionTtl Sticky session TTL in seconds (0 = disabled)
	StickySessionTtl *int `json:"stickySessionTtl,omitempty"`

	// Traffic Traffic percentage
	Traffic *int `json:"traffic,omitempty"`
}

// RevisionMetadata Revision metadata
type RevisionMetadata struct {
	// Active Is the revision active
	Active *bool `json:"active,omitempty"`

	// Canary Is the revision canary
	Canary *bool `json:"canary,omitempty"`

	// CreatedAt Revision created at
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy Revision created by
	CreatedBy *string `json:"createdBy,omitempty"`

	// Id Revision ID
	Id *string `json:"id,omitempty"`

	// PreviousActive Is the revision previous active
	PreviousActive *bool `json:"previousActive,omitempty"`

	// Status Status of the revision
	Status *string `json:"status,omitempty"`

	// TrafficPercent Percent of traffic to the revision
	TrafficPercent *int `json:"trafficPercent,omitempty"`
}

// Runtime Set of configurations for a deployment
type Runtime struct {
	// Args The arguments to pass to the deployment runtime
	Args *[]interface{} `json:"args,omitempty"`

	// Command The command to run the deployment
	Command *[]interface{} `json:"command,omitempty"`

	// Configuration The configuration for the deployment
	Configuration *map[string]interface{} `json:"configuration,omitempty"`

	// Cpu The CPU for the deployment in cores, only available for private cluster
	Cpu *int `json:"cpu,omitempty"`

	// EndpointName Endpoint Name of the model. In case of hf_private_endpoint, it is the endpoint name. In case of hf_public_endpoint, it is not used.
	EndpointName *string `json:"endpointName,omitempty"`

	// Envs The env variables to set in the deployment. Should be a list of Kubernetes EnvVar types
	Envs *[]interface{} `json:"envs,omitempty"`

	// Expires The expiration date for the deployment in ISO 8601 format - 2024-12-31T23:59:59Z
	Expires *string `json:"expires,omitempty"`

	// Generation The generation of the deployment
	Generation *string `json:"generation,omitempty"`

	// Image The Docker image for the deployment
	Image *string `json:"image,omitempty"`

	// MaxConcurrentTasks The maximum number of concurrent task for an execution
	MaxConcurrentTasks *int `json:"maxConcurrentTasks,omitempty"`

	// MaxRetries The maximum number of retries for the deployment
	MaxRetries *int `json:"maxRetries,omitempty"`

	// MaxScale The minimum number of replicas for the deployment. Can be 0 or 1 (in which case the deployment is always running in at least one location).
	MaxScale *int `json:"maxScale,omitempty"`

	// Memory The memory for the deployment in MB
	Memory *int `json:"memory,omitempty"`

	// MetricPort The port to serve the metrics on
	MetricPort *int `json:"metricPort,omitempty"`

	// MinScale The maximum number of replicas for the deployment.
	MinScale *int `json:"minScale,omitempty"`

	// Model The slug name of the origin model at HuggingFace.
	Model *string `json:"model,omitempty"`

	// Organization The organization of the model
	Organization *string `json:"organization,omitempty"`

	// Ports Set of ports for a resource
	Ports *Ports `json:"ports,omitempty"`

	// StartupProbe The readiness probe. Should be a Kubernetes Probe type
	StartupProbe *map[string]interface{} `json:"startupProbe,omitempty"`

	// Timeout The timeout for the deployment in seconds
	Timeout *int `json:"timeout,omitempty"`

	// Transport The transport for the deployment, used by MCPs: "websocket" or "http-stream"
	Transport *string `json:"transport,omitempty"`

	// Ttl The TTL for the deployment in seconds - 30m, 24h, 7d
	Ttl *string `json:"ttl,omitempty"`

	// Type The type of origin for the deployment (hf_private_endpoint, hf_public_endpoint)
	Type *string `json:"type,omitempty"`
}

// Sandbox Micro VM for running agentic tasks
type Sandbox struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// LastUsedAt Last time the sandbox was used (read-only, managed by the system)
	LastUsedAt *string `json:"lastUsedAt,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Sandbox specification
	Spec *SandboxSpec `json:"spec,omitempty"`

	// Status Sandbox status
	Status *string `json:"status,omitempty"`

	// Ttl TTL timestamp for automatic deletion (optional, nil means no auto-deletion)
	Ttl *int `json:"ttl,omitempty"`
}

// SandboxDefinition Sandbox definition for admin store operations
type SandboxDefinition struct {
	// Categories Categories of the defintion
	Categories *[]interface{} `json:"categories,omitempty"`

	// ComingSoon If the definition is coming soon
	ComingSoon *bool `json:"coming_soon,omitempty"`

	// Description Description of the defintion
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the definition
	DisplayName *string `json:"displayName,omitempty"`

	// Enterprise If the definition is enterprise
	Enterprise *bool `json:"enterprise,omitempty"`

	// Hidden If the definition is hidden
	Hidden *bool `json:"hidden,omitempty"`

	// Icon Icon of the definition
	Icon *string `json:"icon,omitempty"`

	// Image Image of the Sandbox definition
	Image *string `json:"image,omitempty"`

	// LongDescription Long description of the defintion
	LongDescription *string `json:"longDescription,omitempty"`

	// Memory Memory of the Sandbox definition in MB
	Memory *int `json:"memory,omitempty"`

	// Name Name of the artifact
	Name *string `json:"name,omitempty"`

	// Ports Set of ports for a resource
	Ports *Ports `json:"ports,omitempty"`

	// Tags Tags of the definition
	Tags *string `json:"tags,omitempty"`

	// Url URL of the definition
	Url *string `json:"url,omitempty"`
}

// SandboxLifecycle Lifecycle configuration for sandbox management
type SandboxLifecycle struct {
	// ExpirationPolicies List of expiration policies
	ExpirationPolicies *[]ExpirationPolicy `json:"expirationPolicies,omitempty"`
}

// SandboxSpec defines model for SandboxSpec.
type SandboxSpec struct {
	// Configurations Optional configurations for the object
	Configurations *struct {
		// Key Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
		Key *SpecConfiguration `json:"key,omitempty"`
	} `json:"configurations,omitempty"`

	// Enabled Enable or disable the resource
	Enabled *bool `json:"enabled,omitempty"`

	// Flavors Types of hardware available for deployments
	Flavors                *Flavors                    `json:"flavors,omitempty"`
	IntegrationConnections *IntegrationConnectionsList `json:"integrationConnections,omitempty"`

	// Lifecycle Lifecycle configuration for sandbox management
	Lifecycle *SandboxLifecycle `json:"lifecycle,omitempty"`
	Policies  *PoliciesList     `json:"policies,omitempty"`

	// Region Region where the sandbox should be created (e.g. us-pdx-1, eu-lon-1)
	Region *string `json:"region,omitempty"`

	// Revision Revision configuration
	Revision *RevisionConfiguration `json:"revision,omitempty"`

	// Runtime Set of configurations for a deployment
	Runtime *Runtime `json:"runtime,omitempty"`

	// Sandbox Sandbox mode
	Sandbox *bool              `json:"sandbox,omitempty"`
	Volumes *VolumeAttachments `json:"volumes,omitempty"`
}

// SpecConfiguration Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
type SpecConfiguration struct {
	// Secret ACconfiguration secret
	Secret *bool `json:"secret,omitempty"`

	// Value Configuration value
	Value *string `json:"value,omitempty"`
}

// Template Blaxel template
type Template struct {
	// DefaultBranch Default branch of the template
	DefaultBranch *string `json:"defaultBranch,omitempty"`

	// Description Description of the template
	Description *string `json:"description,omitempty"`

	// DownloadCount Number of downloads/clones of the repository
	DownloadCount *int `json:"downloadCount,omitempty"`

	// ForksCount Number of forks the repository has
	ForksCount *int `json:"forksCount,omitempty"`

	// Icon URL to the template's icon
	Icon *string `json:"icon,omitempty"`

	// IconDark URL to the template's icon in dark mode
	IconDark *string `json:"iconDark,omitempty"`

	// Name Name of the template
	Name *string `json:"name,omitempty"`

	// Sha SHA of the variable
	Sha *string `json:"sha,omitempty"`

	// StarCount Number of stars the repository has
	StarCount *int `json:"starCount,omitempty"`

	// Topics Topic of the template
	Topics *[]string `json:"topics,omitempty"`

	// Url URL of the template
	Url *string `json:"url,omitempty"`

	// Variables Variables of the template
	Variables *[]TemplateVariable `json:"variables,omitempty"`
}

// TemplateVariable Blaxel template variable
type TemplateVariable struct {
	// Description Description of the variable
	Description *string `json:"description,omitempty"`

	// Integration Integration of the variable
	Integration *string `json:"integration,omitempty"`

	// Name Name of the variable
	Name *string `json:"name,omitempty"`

	// Path Path of the variable
	Path *string `json:"path,omitempty"`

	// Secret Whether the variable is secret
	Secret *bool `json:"secret,omitempty"`
}

// TimeFields Time fields for Persistance
type TimeFields struct {
	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// Trigger Trigger configuration
type Trigger struct {
	// Configuration Trigger configuration
	Configuration *TriggerConfiguration `json:"configuration,omitempty"`

	// Enabled Enable or disable the trigger (default: true)
	Enabled *bool `json:"enabled,omitempty"`

	// Id The id of the trigger
	Id *string `json:"id,omitempty"`

	// Type The type of trigger, can be http or http-async
	Type *string `json:"type,omitempty"`
}

// TriggerConfiguration Trigger configuration
type TriggerConfiguration struct {
	// AuthenticationType The authentication type of the trigger
	AuthenticationType *string `json:"authenticationType,omitempty"`

	// CallbackSecret The callback secret for async triggers (auto-generated, encrypted)
	CallbackSecret *string `json:"callbackSecret,omitempty"`

	// CallbackUrl The callback URL for async triggers (optional)
	CallbackUrl *string `json:"callbackUrl,omitempty"`

	// Path The path of the trigger
	Path *string `json:"path,omitempty"`

	// Retry The retry of the trigger
	Retry *int `json:"retry,omitempty"`

	// Schedule The schedule of the trigger, cron expression * * * * *
	Schedule *string `json:"schedule,omitempty"`

	// Tasks The tasks configuration of the cronjob
	Tasks *[]TriggerConfigurationTask `json:"tasks,omitempty"`

	// Timeout The timeout in seconds for async triggers (max 900s, MK3 only)
	Timeout *int `json:"timeout,omitempty"`
}

// TriggerConfigurationTask The tasks configuration of the cronjob
type TriggerConfigurationTask = map[string]interface{}

// Triggers Triggers to use your agent
type Triggers = []Trigger

// Volume Volume resource for persistent storage
type Volume struct {
	// Events Core events
	Events *CoreEvents `json:"events,omitempty"`

	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Volume specification - immutable configuration
	Spec *VolumeSpec `json:"spec,omitempty"`

	// State Volume state - mutable runtime state
	State *VolumeState `json:"state,omitempty"`

	// Status Volume status computed from events
	Status *string `json:"status,omitempty"`

	// TerminatedAt Timestamp when the volume was marked for termination
	TerminatedAt *string `json:"terminatedAt,omitempty"`
}

// VolumeAttachment Volume attachment configuration for sandbox
type VolumeAttachment struct {
	// MountPath Mount path in the container
	MountPath *string `json:"mountPath,omitempty"`

	// Name Name of the volume to attach
	Name *string `json:"name,omitempty"`

	// ReadOnly Whether the volume is mounted as read-only
	ReadOnly *bool `json:"readOnly,omitempty"`
}

// VolumeAttachments defines model for VolumeAttachments.
type VolumeAttachments = []VolumeAttachment

// VolumeSpec Volume specification - immutable configuration
type VolumeSpec struct {
	// InfrastructureId The internal infrastructure resource identifier for this volume
	InfrastructureId *string `json:"infrastructureId,omitempty"`

	// Region Region where the volume should be created (e.g. us-pdx-1, eu-lon-1)
	Region *string `json:"region,omitempty"`

	// Size Size of the volume in MB
	Size *int `json:"size,omitempty"`

	// StorageClass Storage class for the volume
	StorageClass *string `json:"storageClass,omitempty"`

	// Template Volume template with revision (e.g. "mytemplate:1" or "mytemplate:latest")
	Template *string `json:"template,omitempty"`
}

// VolumeState Volume state - mutable runtime state
type VolumeState struct {
	// AttachedTo Resource this volume is attached to (e.g. "sandbox:my-sandbox", "model:my-model")
	AttachedTo *string `json:"attachedTo,omitempty"`
}

// VolumeTemplate Volume template for creating pre-configured volumes
type VolumeTemplate struct {
	// Metadata Metadata
	Metadata *Metadata `json:"metadata,omitempty"`

	// Spec Volume template specification
	Spec *VolumeTemplateSpec `json:"spec,omitempty"`

	// State Volume template state
	State *VolumeTemplateState `json:"state,omitempty"`

	// Versions List of versions for this template
	Versions *[]VolumeTemplateVersion `json:"versions,omitempty"`
}

// VolumeTemplateSpec Volume template specification
type VolumeTemplateSpec struct {
	// DefaultSize Default size of the volume in MB
	DefaultSize *int `json:"defaultSize,omitempty"`

	// Description Description of the volume template
	Description *string `json:"description,omitempty"`
}

// VolumeTemplateState Volume template state
type VolumeTemplateState struct {
	// LastVersionUploadedAt Timestamp of last version upload
	LastVersionUploadedAt *string `json:"lastVersionUploadedAt,omitempty"`

	// LatestVersion Current/latest S3 version ID
	LatestVersion *string `json:"latestVersion,omitempty"`

	// Status Status of the volume template (created, ready, error)
	Status *string `json:"status,omitempty"`

	// VersionCount Total number of versions for this template
	VersionCount *int `json:"versionCount,omitempty"`
}

// VolumeTemplateVersion Volume template version tracking individual versions of template content
type VolumeTemplateVersion struct {
	// Bucket S3 bucket name where this version is stored
	Bucket *string `json:"bucket,omitempty"`

	// ContentSize Size of the template content in bytes
	ContentSize *int `json:"contentSize,omitempty"`

	// Name Name of the template version
	Name *string `json:"name,omitempty"`

	// Region AWS region where this version is stored
	Region *string `json:"region,omitempty"`

	// Status Status of the version (CREATED, READY, FAILED)
	Status *string `json:"status,omitempty"`

	// TemplateName Template name this version belongs to
	TemplateName *string `json:"templateName,omitempty"`

	// VersionId S3 version ID for this template version
	VersionId *string `json:"versionId,omitempty"`

	// Workspace Workspace name
	Workspace *string `json:"workspace,omitempty"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	// AccountId Workspace account id
	AccountId *string `json:"accountId,omitempty"`

	// CreatedAt The date and time when the resource was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy The user or service account who created the resource
	CreatedBy *string `json:"createdBy,omitempty"`

	// DisplayName Workspace display name
	DisplayName *string `json:"displayName,omitempty"`

	// Id Autogenerated unique workspace id
	Id *string `json:"id,omitempty"`

	// Labels Workspace labels
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// Name Workspace name
	Name *string `json:"name,omitempty"`

	// Region Workspace write region
	Region *string `json:"region,omitempty"`

	// Runtime Workspace runtime
	Runtime *WorkspaceRuntime `json:"runtime,omitempty"`

	// Status Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
	Status *string `json:"status,omitempty"`

	// StatusReason Reason for current status (only set for error status)
	StatusReason *string `json:"statusReason,omitempty"`

	// UpdatedAt The date and time when the resource was updated
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// UpdatedBy The user or service account who updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// WorkspaceRuntime Workspace runtime
type WorkspaceRuntime struct {
	// Generation Workspace generation
	Generation *string `json:"generation,omitempty"`
}

// WorkspaceUser Workspace user
type WorkspaceUser struct {
	// Accepted Whether the user has accepted the workspace invitation
	Accepted *bool `json:"accepted,omitempty"`

	// Email Workspace user email
	Email *string `json:"email,omitempty"`

	// EmailVerified Whether the user's email has been verified
	EmailVerified *bool `json:"email_verified,omitempty"`

	// FamilyName Workspace user family name
	FamilyName *string `json:"family_name,omitempty"`

	// GivenName Workspace user given name
	GivenName *string `json:"given_name,omitempty"`

	// Role Workspace user role
	Role *string `json:"role,omitempty"`

	// Sub Workspace user identifier
	Sub *string `json:"sub,omitempty"`
}

// GetAgentParams defines parameters for GetAgent.
type GetAgentParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// GetFunctionParams defines parameters for GetFunction.
type GetFunctionParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// GetJobParams defines parameters for GetJob.
type GetJobParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// ListJobExecutionsParams defines parameters for ListJobExecutions.
type ListJobExecutionsParams struct {
	// Limit Number of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Page offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPublicIpsParams defines parameters for ListPublicIps.
type ListPublicIpsParams struct {
	// Region Filter by region name (only returns mk3 region data)
	Region *string `form:"region,omitempty" json:"region,omitempty"`
}

// CreateSandboxParams defines parameters for CreateSandbox.
type CreateSandboxParams struct {
	// CreateIfNotExist If true, return existing sandbox instead of 409 error when sandbox exists and is not in FAILED/TERMINATED/TERMINATING state
	CreateIfNotExist *bool `form:"createIfNotExist,omitempty" json:"createIfNotExist,omitempty"`
}

// GetSandboxParams defines parameters for GetSandbox.
type GetSandboxParams struct {
	// ShowSecrets Show secret values (admin only)
	ShowSecrets *bool `form:"show_secrets,omitempty" json:"show_secrets,omitempty"`
}

// CreateWorkspaceServiceAccountJSONBody defines parameters for CreateWorkspaceServiceAccount.
type CreateWorkspaceServiceAccountJSONBody struct {
	// Description Service account description
	Description *string `json:"description,omitempty"`

	// Name Service account name
	Name string `json:"name"`
}

// UpdateWorkspaceServiceAccountJSONBody defines parameters for UpdateWorkspaceServiceAccount.
type UpdateWorkspaceServiceAccountJSONBody struct {
	// Description Service account description
	Description *string `json:"description,omitempty"`

	// Name Service account name
	Name *string `json:"name,omitempty"`
}

// CreateApiKeyForServiceAccountJSONBody defines parameters for CreateApiKeyForServiceAccount.
type CreateApiKeyForServiceAccountJSONBody struct {
	// ExpiresIn Expiration period for the API key
	ExpiresIn *string `json:"expires_in,omitempty"`

	// Name Name for the API key
	Name *string `json:"name,omitempty"`
}

// InviteWorkspaceUserJSONBody defines parameters for InviteWorkspaceUser.
type InviteWorkspaceUserJSONBody struct {
	Email *openapi_types.Email `json:"email,omitempty"`
}

// UpdateWorkspaceUserRoleJSONBody defines parameters for UpdateWorkspaceUserRole.
type UpdateWorkspaceUserRoleJSONBody struct {
	// Role The new role to assign to the user
	Role string `json:"role"`
}

// CreateVolumeTemplateParams defines parameters for CreateVolumeTemplate.
type CreateVolumeTemplateParams struct {
	// Upload If true, returns a presigned URL for uploading the template content
	Upload *bool `form:"upload,omitempty" json:"upload,omitempty"`

	// Version Version name for the template version being created
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// UpdateVolumeTemplateParams defines parameters for UpdateVolumeTemplate.
type UpdateVolumeTemplateParams struct {
	// Upload If true, returns a presigned URL for uploading the template content
	Upload *bool `form:"upload,omitempty" json:"upload,omitempty"`

	// Version Version name for the template version being created
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// CheckWorkspaceAvailabilityJSONBody defines parameters for CheckWorkspaceAvailability.
type CheckWorkspaceAvailabilityJSONBody struct {
	Name string `json:"name"`
}

// CreateAgentJSONRequestBody defines body for CreateAgent for application/json ContentType.
type CreateAgentJSONRequestBody = Agent

// UpdateAgentJSONRequestBody defines body for UpdateAgent for application/json ContentType.
type UpdateAgentJSONRequestBody = Agent

// CreateCustomDomainJSONRequestBody defines body for CreateCustomDomain for application/json ContentType.
type CreateCustomDomainJSONRequestBody = CustomDomain

// UpdateCustomDomainJSONRequestBody defines body for UpdateCustomDomain for application/json ContentType.
type UpdateCustomDomainJSONRequestBody = CustomDomain

// CreateFunctionJSONRequestBody defines body for CreateFunction for application/json ContentType.
type CreateFunctionJSONRequestBody = Function

// UpdateFunctionJSONRequestBody defines body for UpdateFunction for application/json ContentType.
type UpdateFunctionJSONRequestBody = Function

// CreateIntegrationConnectionJSONRequestBody defines body for CreateIntegrationConnection for application/json ContentType.
type CreateIntegrationConnectionJSONRequestBody = IntegrationConnection

// UpdateIntegrationConnectionJSONRequestBody defines body for UpdateIntegrationConnection for application/json ContentType.
type UpdateIntegrationConnectionJSONRequestBody = IntegrationConnection

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody = Job

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = Job

// CreateJobExecutionJSONRequestBody defines body for CreateJobExecution for application/json ContentType.
type CreateJobExecutionJSONRequestBody = CreateJobExecutionRequest

// CreateModelJSONRequestBody defines body for CreateModel for application/json ContentType.
type CreateModelJSONRequestBody = Model

// UpdateModelJSONRequestBody defines body for UpdateModel for application/json ContentType.
type UpdateModelJSONRequestBody = Model

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = Policy

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = Policy

// CreateSandboxJSONRequestBody defines body for CreateSandbox for application/json ContentType.
type CreateSandboxJSONRequestBody = Sandbox

// UpdateSandboxJSONRequestBody defines body for UpdateSandbox for application/json ContentType.
type UpdateSandboxJSONRequestBody = Sandbox

// CreateSandboxPreviewJSONRequestBody defines body for CreateSandboxPreview for application/json ContentType.
type CreateSandboxPreviewJSONRequestBody = Preview

// UpdateSandboxPreviewJSONRequestBody defines body for UpdateSandboxPreview for application/json ContentType.
type UpdateSandboxPreviewJSONRequestBody = Preview

// CreateSandboxPreviewTokenJSONRequestBody defines body for CreateSandboxPreviewToken for application/json ContentType.
type CreateSandboxPreviewTokenJSONRequestBody = PreviewToken

// CreateWorkspaceServiceAccountJSONRequestBody defines body for CreateWorkspaceServiceAccount for application/json ContentType.
type CreateWorkspaceServiceAccountJSONRequestBody CreateWorkspaceServiceAccountJSONBody

// UpdateWorkspaceServiceAccountJSONRequestBody defines body for UpdateWorkspaceServiceAccount for application/json ContentType.
type UpdateWorkspaceServiceAccountJSONRequestBody UpdateWorkspaceServiceAccountJSONBody

// CreateApiKeyForServiceAccountJSONRequestBody defines body for CreateApiKeyForServiceAccount for application/json ContentType.
type CreateApiKeyForServiceAccountJSONRequestBody CreateApiKeyForServiceAccountJSONBody

// InviteWorkspaceUserJSONRequestBody defines body for InviteWorkspaceUser for application/json ContentType.
type InviteWorkspaceUserJSONRequestBody InviteWorkspaceUserJSONBody

// UpdateWorkspaceUserRoleJSONRequestBody defines body for UpdateWorkspaceUserRole for application/json ContentType.
type UpdateWorkspaceUserRoleJSONRequestBody UpdateWorkspaceUserRoleJSONBody

// CreateVolumeTemplateJSONRequestBody defines body for CreateVolumeTemplate for application/json ContentType.
type CreateVolumeTemplateJSONRequestBody = VolumeTemplate

// UpdateVolumeTemplateJSONRequestBody defines body for UpdateVolumeTemplate for application/json ContentType.
type UpdateVolumeTemplateJSONRequestBody = VolumeTemplate

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = Volume

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody = Volume

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = Workspace

// CheckWorkspaceAvailabilityJSONRequestBody defines body for CheckWorkspaceAvailability for application/json ContentType.
type CheckWorkspaceAvailabilityJSONRequestBody CheckWorkspaceAvailabilityJSONBody

// UpdateWorkspaceJSONRequestBody defines body for UpdateWorkspace for application/json ContentType.
type UpdateWorkspaceJSONRequestBody = Workspace

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	RunServer string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, runServer string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server:    server,
		RunServer: runServer,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	Run(
		ctx context.Context,
		workspaceName string,
		resourceType string,
		resourceName string,
		method string,
		path string,
		headers map[string]string,
		params []string,
		body string,
		debug bool,
		local bool,
		reqEditors ...RequestEditorFn,
	) (*http.Response, error)

	// ListAgents request
	ListAgents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentWithBody request with any body
	CreateAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgent(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAgent request
	DeleteAgent(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgent request
	GetAgent(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAgentWithBody request with any body
	UpdateAgentWithBody(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAgent(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAgentRevisions request
	ListAgentRevisions(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfiguration request
	GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomDomains request
	ListCustomDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomDomainWithBody request with any body
	CreateCustomDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomDomain(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomDomain request
	DeleteCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomDomain request
	GetCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomDomainWithBody request with any body
	UpdateCustomDomainWithBody(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomDomain(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyCustomDomain request
	VerifyCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctions request
	ListFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFunctionWithBody request with any body
	CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFunction request
	DeleteFunction(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunction request
	GetFunction(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFunctionWithBody request with any body
	UpdateFunctionWithBody(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFunction(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctionRevisions request
	ListFunctionRevisions(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CleanupImages request
	CleanupImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListImages request
	ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImage request
	GetImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImageTag request
	DeleteImageTag(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConnections request
	ListIntegrationConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIntegrationConnectionWithBody request with any body
	CreateIntegrationConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIntegrationConnection(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIntegrationConnection request
	DeleteIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnection request
	GetIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIntegrationConnectionWithBody request with any body
	UpdateIntegrationConnectionWithBody(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIntegrationConnection(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnectionModelEndpointConfigurations request
	GetIntegrationConnectionModelEndpointConfigurations(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConnectionModels request
	ListIntegrationConnectionModels(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConnectionModel request
	GetIntegrationConnectionModel(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegration request
	GetIntegration(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobWithBody request with any body
	CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJob request
	DeleteJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobWithBody request with any body
	UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJob(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobExecutions request
	ListJobExecutions(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobExecutionWithBody request with any body
	CreateJobExecutionWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJobExecution(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJobExecution request
	DeleteJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobExecution request
	GetJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobRevisions request
	ListJobRevisions(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLocations request
	ListLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMCPHubDefinitions request
	ListMCPHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModels request
	ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModelWithBody request with any body
	CreateModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModel(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModel request
	DeleteModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModel request
	GetModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateModelWithBody request with any body
	UpdateModelWithBody(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateModel(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModelRevisions request
	ListModelRevisions(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPublicIps request
	ListPublicIps(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxHubDefinitions request
	ListSandboxHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxes request
	ListSandboxes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxWithBody request with any body
	CreateSandboxWithBody(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandbox(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandbox request
	DeleteSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandbox request
	GetSandbox(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSandboxWithBody request with any body
	UpdateSandboxWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSandbox(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxPreviews request
	ListSandboxPreviews(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxPreviewWithBody request with any body
	CreateSandboxPreviewWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandboxPreview(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxPreview request
	DeleteSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxPreview request
	GetSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSandboxPreviewWithBody request with any body
	UpdateSandboxPreviewWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSandboxPreview(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxPreviewTokens request
	ListSandboxPreviewTokens(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxPreviewTokenWithBody request with any body
	CreateSandboxPreviewTokenWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandboxPreviewToken request
	DeleteSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspaceServiceAccounts request
	GetWorkspaceServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceServiceAccountWithBody request with any body
	CreateWorkspaceServiceAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspaceServiceAccount(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspaceServiceAccount request
	DeleteWorkspaceServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceServiceAccountWithBody request with any body
	UpdateWorkspaceServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspaceServiceAccount(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiKeysForServiceAccount request
	ListApiKeysForServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyForServiceAccountWithBody request with any body
	CreateApiKeyForServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKeyForServiceAccount(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKeyForServiceAccount request
	DeleteApiKeyForServiceAccount(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTemplates request
	ListTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplate request
	GetTemplate(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceUsers request
	ListWorkspaceUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteWorkspaceUserWithBody request with any body
	InviteWorkspaceUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteWorkspaceUser(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveWorkspaceUser request
	RemoveWorkspaceUser(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceUserRoleWithBody request with any body
	UpdateWorkspaceUserRoleWithBody(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspaceUserRole(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVolumeTemplates request
	ListVolumeTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeTemplateWithBody request with any body
	CreateVolumeTemplateWithBody(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolumeTemplate(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeTemplate request
	DeleteVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVolumeTemplate request
	GetVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeTemplateWithBody request with any body
	UpdateVolumeTemplateWithBody(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolumeTemplate(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeTemplateVersion request
	DeleteVolumeTemplateVersion(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVolumes request
	ListVolumes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVolume request
	GetVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeWithBody request with any body
	UpdateVolumeWithBody(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceWithBody request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckWorkspaceAvailabilityWithBody request with any body
	CheckWorkspaceAvailabilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckWorkspaceAvailability(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspace request
	GetWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkspaceWithBody request with any body
	UpdateWorkspaceWithBody(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkspace(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineWorkspaceInvitation request
	DeclineWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptWorkspaceInvitation request
	AcceptWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveWorkspace request
	LeaveWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// RegisterCliCommands registers CLI commands for the client
func (c *ClientWithResponses) RegisterCliCommands(reg register.Register, ctx context.Context) {

	// Register CLI commands for ListAgents
	reg.CliCommand(ctx, "ListAgents", c.ListAgents)

	// Register CLI commands for CreateAgent
	reg.CliCommand(ctx, "CreateAgent", c.CreateAgent)

	// Register CLI commands for DeleteAgent
	reg.CliCommand(ctx, "DeleteAgent", c.DeleteAgent)

	// Register CLI commands for GetAgent
	reg.CliCommand(ctx, "GetAgent", c.GetAgent)

	// Register CLI commands for UpdateAgent
	reg.CliCommand(ctx, "UpdateAgent", c.UpdateAgent)

	// Register CLI commands for ListAgentRevisions
	reg.CliCommand(ctx, "ListAgentRevisions", c.ListAgentRevisions)

	// Register CLI commands for GetConfiguration
	reg.CliCommand(ctx, "GetConfiguration", c.GetConfiguration)

	// Register CLI commands for ListCustomDomains
	reg.CliCommand(ctx, "ListCustomDomains", c.ListCustomDomains)

	// Register CLI commands for CreateCustomDomain
	reg.CliCommand(ctx, "CreateCustomDomain", c.CreateCustomDomain)

	// Register CLI commands for DeleteCustomDomain
	reg.CliCommand(ctx, "DeleteCustomDomain", c.DeleteCustomDomain)

	// Register CLI commands for GetCustomDomain
	reg.CliCommand(ctx, "GetCustomDomain", c.GetCustomDomain)

	// Register CLI commands for UpdateCustomDomain
	reg.CliCommand(ctx, "UpdateCustomDomain", c.UpdateCustomDomain)

	// Register CLI commands for VerifyCustomDomain
	reg.CliCommand(ctx, "VerifyCustomDomain", c.VerifyCustomDomain)

	// Register CLI commands for ListFunctions
	reg.CliCommand(ctx, "ListFunctions", c.ListFunctions)

	// Register CLI commands for CreateFunction
	reg.CliCommand(ctx, "CreateFunction", c.CreateFunction)

	// Register CLI commands for DeleteFunction
	reg.CliCommand(ctx, "DeleteFunction", c.DeleteFunction)

	// Register CLI commands for GetFunction
	reg.CliCommand(ctx, "GetFunction", c.GetFunction)

	// Register CLI commands for UpdateFunction
	reg.CliCommand(ctx, "UpdateFunction", c.UpdateFunction)

	// Register CLI commands for ListFunctionRevisions
	reg.CliCommand(ctx, "ListFunctionRevisions", c.ListFunctionRevisions)

	// Register CLI commands for CleanupImages
	reg.CliCommand(ctx, "CleanupImages", c.CleanupImages)

	// Register CLI commands for ListImages
	reg.CliCommand(ctx, "ListImages", c.ListImages)

	// Register CLI commands for DeleteImage
	reg.CliCommand(ctx, "DeleteImage", c.DeleteImage)

	// Register CLI commands for GetImage
	reg.CliCommand(ctx, "GetImage", c.GetImage)

	// Register CLI commands for DeleteImageTag
	reg.CliCommand(ctx, "DeleteImageTag", c.DeleteImageTag)

	// Register CLI commands for ListIntegrationConnections
	reg.CliCommand(ctx, "ListIntegrationConnections", c.ListIntegrationConnections)

	// Register CLI commands for CreateIntegrationConnection
	reg.CliCommand(ctx, "CreateIntegrationConnection", c.CreateIntegrationConnection)

	// Register CLI commands for DeleteIntegrationConnection
	reg.CliCommand(ctx, "DeleteIntegrationConnection", c.DeleteIntegrationConnection)

	// Register CLI commands for GetIntegrationConnection
	reg.CliCommand(ctx, "GetIntegrationConnection", c.GetIntegrationConnection)

	// Register CLI commands for UpdateIntegrationConnection
	reg.CliCommand(ctx, "UpdateIntegrationConnection", c.UpdateIntegrationConnection)

	// Register CLI commands for GetIntegrationConnectionModelEndpointConfigurations
	reg.CliCommand(ctx, "GetIntegrationConnectionModelEndpointConfigurations", c.GetIntegrationConnectionModelEndpointConfigurations)

	// Register CLI commands for ListIntegrationConnectionModels
	reg.CliCommand(ctx, "ListIntegrationConnectionModels", c.ListIntegrationConnectionModels)

	// Register CLI commands for GetIntegrationConnectionModel
	reg.CliCommand(ctx, "GetIntegrationConnectionModel", c.GetIntegrationConnectionModel)

	// Register CLI commands for GetIntegration
	reg.CliCommand(ctx, "GetIntegration", c.GetIntegration)

	// Register CLI commands for ListJobs
	reg.CliCommand(ctx, "ListJobs", c.ListJobs)

	// Register CLI commands for CreateJob
	reg.CliCommand(ctx, "CreateJob", c.CreateJob)

	// Register CLI commands for DeleteJob
	reg.CliCommand(ctx, "DeleteJob", c.DeleteJob)

	// Register CLI commands for GetJob
	reg.CliCommand(ctx, "GetJob", c.GetJob)

	// Register CLI commands for UpdateJob
	reg.CliCommand(ctx, "UpdateJob", c.UpdateJob)

	// Register CLI commands for ListJobExecutions
	reg.CliCommand(ctx, "ListJobExecutions", c.ListJobExecutions)

	// Register CLI commands for CreateJobExecution
	reg.CliCommand(ctx, "CreateJobExecution", c.CreateJobExecution)

	// Register CLI commands for DeleteJobExecution
	reg.CliCommand(ctx, "DeleteJobExecution", c.DeleteJobExecution)

	// Register CLI commands for GetJobExecution
	reg.CliCommand(ctx, "GetJobExecution", c.GetJobExecution)

	// Register CLI commands for ListJobRevisions
	reg.CliCommand(ctx, "ListJobRevisions", c.ListJobRevisions)

	// Register CLI commands for ListLocations
	reg.CliCommand(ctx, "ListLocations", c.ListLocations)

	// Register CLI commands for ListMCPHubDefinitions
	reg.CliCommand(ctx, "ListMCPHubDefinitions", c.ListMCPHubDefinitions)

	// Register CLI commands for ListModels
	reg.CliCommand(ctx, "ListModels", c.ListModels)

	// Register CLI commands for CreateModel
	reg.CliCommand(ctx, "CreateModel", c.CreateModel)

	// Register CLI commands for DeleteModel
	reg.CliCommand(ctx, "DeleteModel", c.DeleteModel)

	// Register CLI commands for GetModel
	reg.CliCommand(ctx, "GetModel", c.GetModel)

	// Register CLI commands for UpdateModel
	reg.CliCommand(ctx, "UpdateModel", c.UpdateModel)

	// Register CLI commands for ListModelRevisions
	reg.CliCommand(ctx, "ListModelRevisions", c.ListModelRevisions)

	// Register CLI commands for ListPolicies
	reg.CliCommand(ctx, "ListPolicies", c.ListPolicies)

	// Register CLI commands for CreatePolicy
	reg.CliCommand(ctx, "CreatePolicy", c.CreatePolicy)

	// Register CLI commands for DeletePolicy
	reg.CliCommand(ctx, "DeletePolicy", c.DeletePolicy)

	// Register CLI commands for GetPolicy
	reg.CliCommand(ctx, "GetPolicy", c.GetPolicy)

	// Register CLI commands for UpdatePolicy
	reg.CliCommand(ctx, "UpdatePolicy", c.UpdatePolicy)

	// Register CLI commands for ListPublicIps
	reg.CliCommand(ctx, "ListPublicIps", c.ListPublicIps)

	// Register CLI commands for ListSandboxHubDefinitions
	reg.CliCommand(ctx, "ListSandboxHubDefinitions", c.ListSandboxHubDefinitions)

	// Register CLI commands for ListSandboxes
	reg.CliCommand(ctx, "ListSandboxes", c.ListSandboxes)

	// Register CLI commands for CreateSandbox
	reg.CliCommand(ctx, "CreateSandbox", c.CreateSandbox)

	// Register CLI commands for DeleteSandbox
	reg.CliCommand(ctx, "DeleteSandbox", c.DeleteSandbox)

	// Register CLI commands for GetSandbox
	reg.CliCommand(ctx, "GetSandbox", c.GetSandbox)

	// Register CLI commands for UpdateSandbox
	reg.CliCommand(ctx, "UpdateSandbox", c.UpdateSandbox)

	// Register CLI commands for ListSandboxPreviews
	reg.CliCommand(ctx, "ListSandboxPreviews", c.ListSandboxPreviews)

	// Register CLI commands for CreateSandboxPreview
	reg.CliCommand(ctx, "CreateSandboxPreview", c.CreateSandboxPreview)

	// Register CLI commands for DeleteSandboxPreview
	reg.CliCommand(ctx, "DeleteSandboxPreview", c.DeleteSandboxPreview)

	// Register CLI commands for GetSandboxPreview
	reg.CliCommand(ctx, "GetSandboxPreview", c.GetSandboxPreview)

	// Register CLI commands for UpdateSandboxPreview
	reg.CliCommand(ctx, "UpdateSandboxPreview", c.UpdateSandboxPreview)

	// Register CLI commands for ListSandboxPreviewTokens
	reg.CliCommand(ctx, "ListSandboxPreviewTokens", c.ListSandboxPreviewTokens)

	// Register CLI commands for CreateSandboxPreviewToken
	reg.CliCommand(ctx, "CreateSandboxPreviewToken", c.CreateSandboxPreviewToken)

	// Register CLI commands for DeleteSandboxPreviewToken
	reg.CliCommand(ctx, "DeleteSandboxPreviewToken", c.DeleteSandboxPreviewToken)

	// Register CLI commands for GetWorkspaceServiceAccounts
	reg.CliCommand(ctx, "GetWorkspaceServiceAccounts", c.GetWorkspaceServiceAccounts)

	// Register CLI commands for CreateWorkspaceServiceAccount
	reg.CliCommand(ctx, "CreateWorkspaceServiceAccount", c.CreateWorkspaceServiceAccount)

	// Register CLI commands for DeleteWorkspaceServiceAccount
	reg.CliCommand(ctx, "DeleteWorkspaceServiceAccount", c.DeleteWorkspaceServiceAccount)

	// Register CLI commands for UpdateWorkspaceServiceAccount
	reg.CliCommand(ctx, "UpdateWorkspaceServiceAccount", c.UpdateWorkspaceServiceAccount)

	// Register CLI commands for ListApiKeysForServiceAccount
	reg.CliCommand(ctx, "ListApiKeysForServiceAccount", c.ListApiKeysForServiceAccount)

	// Register CLI commands for CreateApiKeyForServiceAccount
	reg.CliCommand(ctx, "CreateApiKeyForServiceAccount", c.CreateApiKeyForServiceAccount)

	// Register CLI commands for DeleteApiKeyForServiceAccount
	reg.CliCommand(ctx, "DeleteApiKeyForServiceAccount", c.DeleteApiKeyForServiceAccount)

	// Register CLI commands for ListTemplates
	reg.CliCommand(ctx, "ListTemplates", c.ListTemplates)

	// Register CLI commands for GetTemplate
	reg.CliCommand(ctx, "GetTemplate", c.GetTemplate)

	// Register CLI commands for ListWorkspaceUsers
	reg.CliCommand(ctx, "ListWorkspaceUsers", c.ListWorkspaceUsers)

	// Register CLI commands for InviteWorkspaceUser
	reg.CliCommand(ctx, "InviteWorkspaceUser", c.InviteWorkspaceUser)

	// Register CLI commands for RemoveWorkspaceUser
	reg.CliCommand(ctx, "RemoveWorkspaceUser", c.RemoveWorkspaceUser)

	// Register CLI commands for UpdateWorkspaceUserRole
	reg.CliCommand(ctx, "UpdateWorkspaceUserRole", c.UpdateWorkspaceUserRole)

	// Register CLI commands for ListVolumeTemplates
	reg.CliCommand(ctx, "ListVolumeTemplates", c.ListVolumeTemplates)

	// Register CLI commands for CreateVolumeTemplate
	reg.CliCommand(ctx, "CreateVolumeTemplate", c.CreateVolumeTemplate)

	// Register CLI commands for DeleteVolumeTemplate
	reg.CliCommand(ctx, "DeleteVolumeTemplate", c.DeleteVolumeTemplate)

	// Register CLI commands for GetVolumeTemplate
	reg.CliCommand(ctx, "GetVolumeTemplate", c.GetVolumeTemplate)

	// Register CLI commands for UpdateVolumeTemplate
	reg.CliCommand(ctx, "UpdateVolumeTemplate", c.UpdateVolumeTemplate)

	// Register CLI commands for DeleteVolumeTemplateVersion
	reg.CliCommand(ctx, "DeleteVolumeTemplateVersion", c.DeleteVolumeTemplateVersion)

	// Register CLI commands for ListVolumes
	reg.CliCommand(ctx, "ListVolumes", c.ListVolumes)

	// Register CLI commands for CreateVolume
	reg.CliCommand(ctx, "CreateVolume", c.CreateVolume)

	// Register CLI commands for DeleteVolume
	reg.CliCommand(ctx, "DeleteVolume", c.DeleteVolume)

	// Register CLI commands for GetVolume
	reg.CliCommand(ctx, "GetVolume", c.GetVolume)

	// Register CLI commands for UpdateVolume
	reg.CliCommand(ctx, "UpdateVolume", c.UpdateVolume)

	// Register CLI commands for ListWorkspaces
	reg.CliCommand(ctx, "ListWorkspaces", c.ListWorkspaces)

	// Register CLI commands for CreateWorkspace
	reg.CliCommand(ctx, "CreateWorkspace", c.CreateWorkspace)

	// Register CLI commands for CheckWorkspaceAvailability
	reg.CliCommand(ctx, "CheckWorkspaceAvailability", c.CheckWorkspaceAvailability)

	// Register CLI commands for DeleteWorkspace
	reg.CliCommand(ctx, "DeleteWorkspace", c.DeleteWorkspace)

	// Register CLI commands for GetWorkspace
	reg.CliCommand(ctx, "GetWorkspace", c.GetWorkspace)

	// Register CLI commands for UpdateWorkspace
	reg.CliCommand(ctx, "UpdateWorkspace", c.UpdateWorkspace)

	// Register CLI commands for DeclineWorkspaceInvitation
	reg.CliCommand(ctx, "DeclineWorkspaceInvitation", c.DeclineWorkspaceInvitation)

	// Register CLI commands for AcceptWorkspaceInvitation
	reg.CliCommand(ctx, "AcceptWorkspaceInvitation", c.AcceptWorkspaceInvitation)

	// Register CLI commands for LeaveWorkspace
	reg.CliCommand(ctx, "LeaveWorkspace", c.LeaveWorkspace)

}

func (c *Client) ListAgents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgent(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgent(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentRequest(c.Server, agentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgent(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentRequest(c.Server, agentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentWithBody(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentRequestWithBody(c.Server, agentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgent(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentRequest(c.Server, agentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAgentRevisions(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentRevisionsRequest(c.Server, agentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomDomains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomDomainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomDomain(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomDomainWithBody(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomDomainRequestWithBody(c.Server, domainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomDomain(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomDomainRequest(c.Server, domainName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyCustomDomain(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyCustomDomainRequest(c.Server, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFunction(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFunctionRequest(c.Server, functionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunction(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionRequest(c.Server, functionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunctionWithBody(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequestWithBody(c.Server, functionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFunction(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFunctionRequest(c.Server, functionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctionRevisions(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionRevisionsRequest(c.Server, functionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CleanupImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCleanupImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, resourceType, imageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImage(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageRequest(c.Server, resourceType, imageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImageTag(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageTagRequest(c.Server, resourceType, imageName, tagName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConnectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationConnection(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIntegrationConnectionRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnection(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationConnectionWithBody(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationConnectionRequestWithBody(c.Server, connectionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationConnection(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationConnectionRequest(c.Server, connectionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnectionModelEndpointConfigurations(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionModelEndpointConfigurationsRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConnectionModels(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConnectionModelsRequest(c.Server, connectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConnectionModel(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConnectionModelRequest(c.Server, connectionName, modelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegration(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationRequest(c.Server, integrationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJob(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobExecutions(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobExecutionsRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobExecutionWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobExecutionRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobExecution(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobExecutionRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobExecutionRequest(c.Server, jobId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobExecution(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobExecutionRequest(c.Server, jobId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobRevisions(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobRevisionsRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLocationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMCPHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMCPHubDefinitionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModel(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModelRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModel(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModelWithBody(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelRequestWithBody(c.Server, modelName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModel(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelRequest(c.Server, modelName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModelRevisions(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelRevisionsRequest(c.Server, modelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPublicIps(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPublicIpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxHubDefinitions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxHubDefinitionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxWithBody(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandbox(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandbox(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandbox(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxRequest(c.Server, sandboxName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxRequestWithBody(c.Server, sandboxName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandbox(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxRequest(c.Server, sandboxName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxPreviews(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxPreviewsRequest(c.Server, sandboxName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewWithBody(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewRequestWithBody(c.Server, sandboxName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreview(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewRequest(c.Server, sandboxName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxPreviewRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxPreview(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxPreviewRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxPreviewWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxPreviewRequestWithBody(c.Server, sandboxName, previewName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxPreview(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxPreviewRequest(c.Server, sandboxName, previewName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxPreviewTokens(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxPreviewTokensRequest(c.Server, sandboxName, previewName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewTokenWithBody(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewTokenRequestWithBody(c.Server, sandboxName, previewName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxPreviewTokenRequest(c.Server, sandboxName, previewName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandboxPreviewToken(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxPreviewTokenRequest(c.Server, sandboxName, previewName, tokenName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspaceServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceServiceAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceServiceAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceServiceAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceServiceAccount(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceServiceAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspaceServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceServiceAccountRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceServiceAccountRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceServiceAccount(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceServiceAccountRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiKeysForServiceAccount(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysForServiceAccountRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyForServiceAccountWithBody(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyForServiceAccountRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyForServiceAccount(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyForServiceAccountRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKeyForServiceAccount(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeyForServiceAccountRequest(c.Server, clientId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplate(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateRequest(c.Server, templateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteWorkspaceUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteWorkspaceUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteWorkspaceUser(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteWorkspaceUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveWorkspaceUser(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveWorkspaceUserRequest(c.Server, subOrEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceUserRoleWithBody(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceUserRoleRequestWithBody(c.Server, subOrEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceUserRole(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceUserRoleRequest(c.Server, subOrEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVolumeTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVolumeTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeTemplateWithBody(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeTemplateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeTemplate(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeTemplateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeTemplateRequest(c.Server, volumeTemplateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVolumeTemplate(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVolumeTemplateRequest(c.Server, volumeTemplateName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeTemplateWithBody(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeTemplateRequestWithBody(c.Server, volumeTemplateName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeTemplate(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeTemplateRequest(c.Server, volumeTemplateName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeTemplateVersion(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeTemplateVersionRequest(c.Server, volumeTemplateName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVolumes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVolumesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, volumeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVolume(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVolumeRequest(c.Server, volumeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, volumeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, volumeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckWorkspaceAvailabilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckWorkspaceAvailabilityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckWorkspaceAvailability(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckWorkspaceAvailabilityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspaceWithBody(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequestWithBody(c.Server, workspaceName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkspace(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkspaceRequest(c.Server, workspaceName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineWorkspaceInvitationRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptWorkspaceInvitation(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptWorkspaceInvitationRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveWorkspace(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveWorkspaceRequest(c.Server, workspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAgentsRequest generates requests for ListAgents
func NewListAgentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentRequest calls the generic CreateAgent builder with application/json body
func NewCreateAgentRequest(server string, body CreateAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentRequestWithBody generates requests for CreateAgent with any type of body
func NewCreateAgentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAgentRequest generates requests for DeleteAgent
func NewDeleteAgentRequest(server string, agentName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAgentRequest generates requests for GetAgent
func NewGetAgentRequest(server string, agentName string, params *GetAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAgentRequest calls the generic UpdateAgent builder with application/json body
func NewUpdateAgentRequest(server string, agentName string, body UpdateAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAgentRequestWithBody(server, agentName, "application/json", bodyReader)
}

// NewUpdateAgentRequestWithBody generates requests for UpdateAgent with any type of body
func NewUpdateAgentRequestWithBody(server string, agentName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAgentRevisionsRequest generates requests for ListAgentRevisions
func NewListAgentRevisionsRequest(server string, agentName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentName", runtime.ParamLocationPath, agentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationRequest generates requests for GetConfiguration
func NewGetConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomDomainsRequest generates requests for ListCustomDomains
func NewListCustomDomainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomDomainRequest calls the generic CreateCustomDomain builder with application/json body
func NewCreateCustomDomainRequest(server string, body CreateCustomDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomDomainRequestWithBody generates requests for CreateCustomDomain with any type of body
func NewCreateCustomDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomDomainRequest generates requests for DeleteCustomDomain
func NewDeleteCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomDomainRequest generates requests for GetCustomDomain
func NewGetCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomDomainRequest calls the generic UpdateCustomDomain builder with application/json body
func NewUpdateCustomDomainRequest(server string, domainName string, body UpdateCustomDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomDomainRequestWithBody(server, domainName, "application/json", bodyReader)
}

// NewUpdateCustomDomainRequestWithBody generates requests for UpdateCustomDomain with any type of body
func NewUpdateCustomDomainRequestWithBody(server string, domainName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyCustomDomainRequest generates requests for VerifyCustomDomain
func NewVerifyCustomDomainRequest(server string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customdomains/%s/verify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFunctionsRequest generates requests for ListFunctions
func NewListFunctionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFunctionRequest calls the generic CreateFunction builder with application/json body
func NewCreateFunctionRequest(server string, body CreateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFunctionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFunctionRequestWithBody generates requests for CreateFunction with any type of body
func NewCreateFunctionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFunctionRequest generates requests for DeleteFunction
func NewDeleteFunctionRequest(server string, functionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFunctionRequest generates requests for GetFunction
func NewGetFunctionRequest(server string, functionName string, params *GetFunctionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFunctionRequest calls the generic UpdateFunction builder with application/json body
func NewUpdateFunctionRequest(server string, functionName string, body UpdateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFunctionRequestWithBody(server, functionName, "application/json", bodyReader)
}

// NewUpdateFunctionRequestWithBody generates requests for UpdateFunction with any type of body
func NewUpdateFunctionRequestWithBody(server string, functionName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFunctionRevisionsRequest generates requests for ListFunctionRevisions
func NewListFunctionRevisionsRequest(server string, functionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "functionName", runtime.ParamLocationPath, functionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCleanupImagesRequest generates requests for CleanupImages
func NewCleanupImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListImagesRequest generates requests for ListImages
func NewListImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, resourceType string, imageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImageRequest generates requests for GetImage
func NewGetImageRequest(server string, resourceType string, imageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImageTagRequest generates requests for DeleteImageTag
func NewDeleteImageTagRequest(server string, resourceType string, imageName string, tagName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageName", runtime.ParamLocationPath, imageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tagName", runtime.ParamLocationPath, tagName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s/%s/tags/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationConnectionsRequest generates requests for ListIntegrationConnections
func NewListIntegrationConnectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIntegrationConnectionRequest calls the generic CreateIntegrationConnection builder with application/json body
func NewCreateIntegrationConnectionRequest(server string, body CreateIntegrationConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIntegrationConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIntegrationConnectionRequestWithBody generates requests for CreateIntegrationConnection with any type of body
func NewCreateIntegrationConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIntegrationConnectionRequest generates requests for DeleteIntegrationConnection
func NewDeleteIntegrationConnectionRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConnectionRequest generates requests for GetIntegrationConnection
func NewGetIntegrationConnectionRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIntegrationConnectionRequest calls the generic UpdateIntegrationConnection builder with application/json body
func NewUpdateIntegrationConnectionRequest(server string, connectionName string, body UpdateIntegrationConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIntegrationConnectionRequestWithBody(server, connectionName, "application/json", bodyReader)
}

// NewUpdateIntegrationConnectionRequestWithBody generates requests for UpdateIntegrationConnection with any type of body
func NewUpdateIntegrationConnectionRequestWithBody(server string, connectionName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIntegrationConnectionModelEndpointConfigurationsRequest generates requests for GetIntegrationConnectionModelEndpointConfigurations
func NewGetIntegrationConnectionModelEndpointConfigurationsRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/endpointConfigurations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationConnectionModelsRequest generates requests for ListIntegrationConnectionModels
func NewListIntegrationConnectionModelsRequest(server string, connectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConnectionModelRequest generates requests for GetIntegrationConnectionModel
func NewGetIntegrationConnectionModelRequest(server string, connectionName string, modelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionName", runtime.ParamLocationPath, connectionName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "modelId", runtime.ParamLocationPath, modelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/connections/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationRequest generates requests for GetIntegration
func NewGetIntegrationRequest(server string, integrationName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationName", runtime.ParamLocationPath, integrationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobRequest calls the generic CreateJob builder with application/json body
func NewCreateJobRequest(server string, body CreateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateJobRequestWithBody generates requests for CreateJob with any type of body
func NewCreateJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobRequest generates requests for DeleteJob
func NewDeleteJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, jobId string, params *GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJobRequest calls the generic UpdateJob builder with application/json body
func NewUpdateJobRequest(server string, jobId string, body UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewUpdateJobRequestWithBody generates requests for UpdateJob with any type of body
func NewUpdateJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListJobExecutionsRequest generates requests for ListJobExecutions
func NewListJobExecutionsRequest(server string, jobId string, params *ListJobExecutionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobExecutionRequest calls the generic CreateJobExecution builder with application/json body
func NewCreateJobExecutionRequest(server string, jobId string, body CreateJobExecutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobExecutionRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewCreateJobExecutionRequestWithBody generates requests for CreateJobExecution with any type of body
func NewCreateJobExecutionRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobExecutionRequest generates requests for DeleteJobExecution
func NewDeleteJobExecutionRequest(server string, jobId string, executionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobExecutionRequest generates requests for GetJobExecution
func NewGetJobExecutionRequest(server string, jobId string, executionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobRevisionsRequest generates requests for ListJobRevisions
func NewListJobRevisionsRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLocationsRequest generates requests for ListLocations
func NewListLocationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMCPHubDefinitionsRequest generates requests for ListMCPHubDefinitions
func NewListMCPHubDefinitionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mcp/hub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListModelsRequest generates requests for ListModels
func NewListModelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModelRequest calls the generic CreateModel builder with application/json body
func NewCreateModelRequest(server string, body CreateModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateModelRequestWithBody generates requests for CreateModel with any type of body
func NewCreateModelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModelRequest generates requests for DeleteModel
func NewDeleteModelRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModelRequest generates requests for GetModel
func NewGetModelRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateModelRequest calls the generic UpdateModel builder with application/json body
func NewUpdateModelRequest(server string, modelName string, body UpdateModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateModelRequestWithBody(server, modelName, "application/json", bodyReader)
}

// NewUpdateModelRequestWithBody generates requests for UpdateModel with any type of body
func NewUpdateModelRequestWithBody(server string, modelName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModelRevisionsRequest generates requests for ListModelRevisions
func NewListModelRevisionsRequest(server string, modelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "modelName", runtime.ParamLocationPath, modelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/revisions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyName string, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyName, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPublicIpsRequest generates requests for ListPublicIps
func NewListPublicIpsRequest(server string, params *ListPublicIpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxHubDefinitionsRequest generates requests for ListSandboxHubDefinitions
func NewListSandboxHubDefinitionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/hub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxesRequest generates requests for ListSandboxes
func NewListSandboxesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxRequest calls the generic CreateSandbox builder with application/json body
func NewCreateSandboxRequest(server string, params *CreateSandboxParams, body CreateSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSandboxRequestWithBody generates requests for CreateSandbox with any type of body
func NewCreateSandboxRequestWithBody(server string, params *CreateSandboxParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreateIfNotExist != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createIfNotExist", runtime.ParamLocationQuery, *params.CreateIfNotExist); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxRequest generates requests for DeleteSandbox
func NewDeleteSandboxRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxRequest generates requests for GetSandbox
func NewGetSandboxRequest(server string, sandboxName string, params *GetSandboxParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowSecrets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_secrets", runtime.ParamLocationQuery, *params.ShowSecrets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSandboxRequest calls the generic UpdateSandbox builder with application/json body
func NewUpdateSandboxRequest(server string, sandboxName string, body UpdateSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSandboxRequestWithBody(server, sandboxName, "application/json", bodyReader)
}

// NewUpdateSandboxRequestWithBody generates requests for UpdateSandbox with any type of body
func NewUpdateSandboxRequestWithBody(server string, sandboxName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSandboxPreviewsRequest generates requests for ListSandboxPreviews
func NewListSandboxPreviewsRequest(server string, sandboxName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxPreviewRequest calls the generic CreateSandboxPreview builder with application/json body
func NewCreateSandboxPreviewRequest(server string, sandboxName string, body CreateSandboxPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxPreviewRequestWithBody(server, sandboxName, "application/json", bodyReader)
}

// NewCreateSandboxPreviewRequestWithBody generates requests for CreateSandboxPreview with any type of body
func NewCreateSandboxPreviewRequestWithBody(server string, sandboxName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxPreviewRequest generates requests for DeleteSandboxPreview
func NewDeleteSandboxPreviewRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxPreviewRequest generates requests for GetSandboxPreview
func NewGetSandboxPreviewRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSandboxPreviewRequest calls the generic UpdateSandboxPreview builder with application/json body
func NewUpdateSandboxPreviewRequest(server string, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSandboxPreviewRequestWithBody(server, sandboxName, previewName, "application/json", bodyReader)
}

// NewUpdateSandboxPreviewRequestWithBody generates requests for UpdateSandboxPreview with any type of body
func NewUpdateSandboxPreviewRequestWithBody(server string, sandboxName string, previewName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSandboxPreviewTokensRequest generates requests for ListSandboxPreviewTokens
func NewListSandboxPreviewTokensRequest(server string, sandboxName string, previewName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxPreviewTokenRequest calls the generic CreateSandboxPreviewToken builder with application/json body
func NewCreateSandboxPreviewTokenRequest(server string, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxPreviewTokenRequestWithBody(server, sandboxName, previewName, "application/json", bodyReader)
}

// NewCreateSandboxPreviewTokenRequestWithBody generates requests for CreateSandboxPreviewToken with any type of body
func NewCreateSandboxPreviewTokenRequestWithBody(server string, sandboxName string, previewName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSandboxPreviewTokenRequest generates requests for DeleteSandboxPreviewToken
func NewDeleteSandboxPreviewTokenRequest(server string, sandboxName string, previewName string, tokenName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxName", runtime.ParamLocationPath, sandboxName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "previewName", runtime.ParamLocationPath, previewName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenName", runtime.ParamLocationPath, tokenName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/previews/%s/tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceServiceAccountsRequest generates requests for GetWorkspaceServiceAccounts
func NewGetWorkspaceServiceAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceServiceAccountRequest calls the generic CreateWorkspaceServiceAccount builder with application/json body
func NewCreateWorkspaceServiceAccountRequest(server string, body CreateWorkspaceServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceServiceAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceServiceAccountRequestWithBody generates requests for CreateWorkspaceServiceAccount with any type of body
func NewCreateWorkspaceServiceAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceServiceAccountRequest generates requests for DeleteWorkspaceServiceAccount
func NewDeleteWorkspaceServiceAccountRequest(server string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceServiceAccountRequest calls the generic UpdateWorkspaceServiceAccount builder with application/json body
func NewUpdateWorkspaceServiceAccountRequest(server string, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceServiceAccountRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewUpdateWorkspaceServiceAccountRequestWithBody generates requests for UpdateWorkspaceServiceAccount with any type of body
func NewUpdateWorkspaceServiceAccountRequestWithBody(server string, clientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListApiKeysForServiceAccountRequest generates requests for ListApiKeysForServiceAccount
func NewListApiKeysForServiceAccountRequest(server string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyForServiceAccountRequest calls the generic CreateApiKeyForServiceAccount builder with application/json body
func NewCreateApiKeyForServiceAccountRequest(server string, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyForServiceAccountRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewCreateApiKeyForServiceAccountRequestWithBody generates requests for CreateApiKeyForServiceAccount with any type of body
func NewCreateApiKeyForServiceAccountRequestWithBody(server string, clientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeyForServiceAccountRequest generates requests for DeleteApiKeyForServiceAccount
func NewDeleteApiKeyForServiceAccountRequest(server string, clientId string, apiKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "apiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_accounts/%s/api_keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTemplatesRequest generates requests for ListTemplates
func NewListTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateRequest generates requests for GetTemplate
func NewGetTemplateRequest(server string, templateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateName", runtime.ParamLocationPath, templateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceUsersRequest generates requests for ListWorkspaceUsers
func NewListWorkspaceUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteWorkspaceUserRequest calls the generic InviteWorkspaceUser builder with application/json body
func NewInviteWorkspaceUserRequest(server string, body InviteWorkspaceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteWorkspaceUserRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteWorkspaceUserRequestWithBody generates requests for InviteWorkspaceUser with any type of body
func NewInviteWorkspaceUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveWorkspaceUserRequest generates requests for RemoveWorkspaceUser
func NewRemoveWorkspaceUserRequest(server string, subOrEmail string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subOrEmail", runtime.ParamLocationPath, subOrEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceUserRoleRequest calls the generic UpdateWorkspaceUserRole builder with application/json body
func NewUpdateWorkspaceUserRoleRequest(server string, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceUserRoleRequestWithBody(server, subOrEmail, "application/json", bodyReader)
}

// NewUpdateWorkspaceUserRoleRequestWithBody generates requests for UpdateWorkspaceUserRole with any type of body
func NewUpdateWorkspaceUserRoleRequestWithBody(server string, subOrEmail string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subOrEmail", runtime.ParamLocationPath, subOrEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVolumeTemplatesRequest generates requests for ListVolumeTemplates
func NewListVolumeTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeTemplateRequest calls the generic CreateVolumeTemplate builder with application/json body
func NewCreateVolumeTemplateRequest(server string, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeTemplateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVolumeTemplateRequestWithBody generates requests for CreateVolumeTemplate with any type of body
func NewCreateVolumeTemplateRequestWithBody(server string, params *CreateVolumeTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Upload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upload", runtime.ParamLocationQuery, *params.Upload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeTemplateRequest generates requests for DeleteVolumeTemplate
func NewDeleteVolumeTemplateRequest(server string, volumeTemplateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVolumeTemplateRequest generates requests for GetVolumeTemplate
func NewGetVolumeTemplateRequest(server string, volumeTemplateName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeTemplateRequest calls the generic UpdateVolumeTemplate builder with application/json body
func NewUpdateVolumeTemplateRequest(server string, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeTemplateRequestWithBody(server, volumeTemplateName, params, "application/json", bodyReader)
}

// NewUpdateVolumeTemplateRequestWithBody generates requests for UpdateVolumeTemplate with any type of body
func NewUpdateVolumeTemplateRequestWithBody(server string, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Upload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upload", runtime.ParamLocationQuery, *params.Upload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeTemplateVersionRequest generates requests for DeleteVolumeTemplateVersion
func NewDeleteVolumeTemplateVersionRequest(server string, volumeTemplateName string, versionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeTemplateName", runtime.ParamLocationPath, volumeTemplateName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "versionName", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volume_templates/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVolumesRequest generates requests for ListVolumes
func NewListVolumesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, volumeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVolumeRequest generates requests for GetVolume
func NewGetVolumeRequest(server string, volumeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, volumeName string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, volumeName, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, volumeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volumeName", runtime.ParamLocationPath, volumeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckWorkspaceAvailabilityRequest calls the generic CheckWorkspaceAvailability builder with application/json body
func NewCheckWorkspaceAvailabilityRequest(server string, body CheckWorkspaceAvailabilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckWorkspaceAvailabilityRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckWorkspaceAvailabilityRequestWithBody generates requests for CheckWorkspaceAvailability with any type of body
func NewCheckWorkspaceAvailabilityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/availability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceRequest generates requests for GetWorkspace
func NewGetWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkspaceRequest calls the generic UpdateWorkspace builder with application/json body
func NewUpdateWorkspaceRequest(server string, workspaceName string, body UpdateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkspaceRequestWithBody(server, workspaceName, "application/json", bodyReader)
}

// NewUpdateWorkspaceRequestWithBody generates requests for UpdateWorkspace with any type of body
func NewUpdateWorkspaceRequestWithBody(server string, workspaceName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeclineWorkspaceInvitationRequest generates requests for DeclineWorkspaceInvitation
func NewDeclineWorkspaceInvitationRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/decline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptWorkspaceInvitationRequest generates requests for AcceptWorkspaceInvitation
func NewAcceptWorkspaceInvitationRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/join", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveWorkspaceRequest generates requests for LeaveWorkspace
func NewLeaveWorkspaceRequest(server string, workspaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceName", runtime.ParamLocationPath, workspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/leave", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, runServer string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, runServer, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAgentsWithResponse request
	ListAgentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAgentsResponse, error)

	// CreateAgentWithBodyWithResponse request with any body
	CreateAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error)

	CreateAgentWithResponse(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error)

	// DeleteAgentWithResponse request
	DeleteAgentWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*DeleteAgentResponse, error)

	// GetAgentWithResponse request
	GetAgentWithResponse(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*GetAgentResponse, error)

	// UpdateAgentWithBodyWithResponse request with any body
	UpdateAgentWithBodyWithResponse(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error)

	UpdateAgentWithResponse(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error)

	// ListAgentRevisionsWithResponse request
	ListAgentRevisionsWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*ListAgentRevisionsResponse, error)

	// GetConfigurationWithResponse request
	GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error)

	// ListCustomDomainsWithResponse request
	ListCustomDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCustomDomainsResponse, error)

	// CreateCustomDomainWithBodyWithResponse request with any body
	CreateCustomDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error)

	CreateCustomDomainWithResponse(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error)

	// DeleteCustomDomainWithResponse request
	DeleteCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*DeleteCustomDomainResponse, error)

	// GetCustomDomainWithResponse request
	GetCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*GetCustomDomainResponse, error)

	// UpdateCustomDomainWithBodyWithResponse request with any body
	UpdateCustomDomainWithBodyWithResponse(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error)

	UpdateCustomDomainWithResponse(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error)

	// VerifyCustomDomainWithResponse request
	VerifyCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*VerifyCustomDomainResponse, error)

	// ListFunctionsWithResponse request
	ListFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFunctionsResponse, error)

	// CreateFunctionWithBodyWithResponse request with any body
	CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error)

	// DeleteFunctionWithResponse request
	DeleteFunctionWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error)

	// GetFunctionWithResponse request
	GetFunctionWithResponse(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*GetFunctionResponse, error)

	// UpdateFunctionWithBodyWithResponse request with any body
	UpdateFunctionWithBodyWithResponse(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	UpdateFunctionWithResponse(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error)

	// ListFunctionRevisionsWithResponse request
	ListFunctionRevisionsWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*ListFunctionRevisionsResponse, error)

	// CleanupImagesWithResponse request
	CleanupImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CleanupImagesResponse, error)

	// ListImagesWithResponse request
	ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// GetImageWithResponse request
	GetImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*GetImageResponse, error)

	// DeleteImageTagWithResponse request
	DeleteImageTagWithResponse(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*DeleteImageTagResponse, error)

	// ListIntegrationConnectionsWithResponse request
	ListIntegrationConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionsResponse, error)

	// CreateIntegrationConnectionWithBodyWithResponse request with any body
	CreateIntegrationConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error)

	CreateIntegrationConnectionWithResponse(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error)

	// DeleteIntegrationConnectionWithResponse request
	DeleteIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*DeleteIntegrationConnectionResponse, error)

	// GetIntegrationConnectionWithResponse request
	GetIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionResponse, error)

	// UpdateIntegrationConnectionWithBodyWithResponse request with any body
	UpdateIntegrationConnectionWithBodyWithResponse(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error)

	UpdateIntegrationConnectionWithResponse(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error)

	// GetIntegrationConnectionModelEndpointConfigurationsWithResponse request
	GetIntegrationConnectionModelEndpointConfigurationsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error)

	// ListIntegrationConnectionModelsWithResponse request
	ListIntegrationConnectionModelsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionModelsResponse, error)

	// GetIntegrationConnectionModelWithResponse request
	GetIntegrationConnectionModelWithResponse(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelResponse, error)

	// GetIntegrationWithResponse request
	GetIntegrationWithResponse(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error)

	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// CreateJobWithBodyWithResponse request with any body
	CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	// DeleteJobWithResponse request
	DeleteJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// UpdateJobWithBodyWithResponse request with any body
	UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	UpdateJobWithResponse(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	// ListJobExecutionsWithResponse request
	ListJobExecutionsWithResponse(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*ListJobExecutionsResponse, error)

	// CreateJobExecutionWithBodyWithResponse request with any body
	CreateJobExecutionWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error)

	CreateJobExecutionWithResponse(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error)

	// DeleteJobExecutionWithResponse request
	DeleteJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*DeleteJobExecutionResponse, error)

	// GetJobExecutionWithResponse request
	GetJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*GetJobExecutionResponse, error)

	// ListJobRevisionsWithResponse request
	ListJobRevisionsWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*ListJobRevisionsResponse, error)

	// ListLocationsWithResponse request
	ListLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error)

	// ListMCPHubDefinitionsWithResponse request
	ListMCPHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMCPHubDefinitionsResponse, error)

	// ListModelsWithResponse request
	ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResponse, error)

	// CreateModelWithBodyWithResponse request with any body
	CreateModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResponse, error)

	CreateModelWithResponse(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResponse, error)

	// DeleteModelWithResponse request
	DeleteModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*DeleteModelResponse, error)

	// GetModelWithResponse request
	GetModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*GetModelResponse, error)

	// UpdateModelWithBodyWithResponse request with any body
	UpdateModelWithBodyWithResponse(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error)

	UpdateModelWithResponse(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error)

	// ListModelRevisionsWithResponse request
	ListModelRevisionsWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*ListModelRevisionsResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyWithResponse request
	GetPolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListPublicIpsWithResponse request
	ListPublicIpsWithResponse(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*ListPublicIpsResponse, error)

	// ListSandboxHubDefinitionsWithResponse request
	ListSandboxHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxHubDefinitionsResponse, error)

	// ListSandboxesWithResponse request
	ListSandboxesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error)

	// CreateSandboxWithBodyWithResponse request with any body
	CreateSandboxWithBodyWithResponse(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	CreateSandboxWithResponse(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	// DeleteSandboxWithResponse request
	DeleteSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error)

	// GetSandboxWithResponse request
	GetSandboxWithResponse(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error)

	// UpdateSandboxWithBodyWithResponse request with any body
	UpdateSandboxWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error)

	UpdateSandboxWithResponse(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error)

	// ListSandboxPreviewsWithResponse request
	ListSandboxPreviewsWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewsResponse, error)

	// CreateSandboxPreviewWithBodyWithResponse request with any body
	CreateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error)

	CreateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error)

	// DeleteSandboxPreviewWithResponse request
	DeleteSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewResponse, error)

	// GetSandboxPreviewWithResponse request
	GetSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*GetSandboxPreviewResponse, error)

	// UpdateSandboxPreviewWithBodyWithResponse request with any body
	UpdateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error)

	UpdateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error)

	// ListSandboxPreviewTokensWithResponse request
	ListSandboxPreviewTokensWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewTokensResponse, error)

	// CreateSandboxPreviewTokenWithBodyWithResponse request with any body
	CreateSandboxPreviewTokenWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error)

	CreateSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error)

	// DeleteSandboxPreviewTokenWithResponse request
	DeleteSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewTokenResponse, error)

	// GetWorkspaceServiceAccountsWithResponse request
	GetWorkspaceServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkspaceServiceAccountsResponse, error)

	// CreateWorkspaceServiceAccountWithBodyWithResponse request with any body
	CreateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error)

	CreateWorkspaceServiceAccountWithResponse(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error)

	// DeleteWorkspaceServiceAccountWithResponse request
	DeleteWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceServiceAccountResponse, error)

	// UpdateWorkspaceServiceAccountWithBodyWithResponse request with any body
	UpdateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error)

	UpdateWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error)

	// ListApiKeysForServiceAccountWithResponse request
	ListApiKeysForServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*ListApiKeysForServiceAccountResponse, error)

	// CreateApiKeyForServiceAccountWithBodyWithResponse request with any body
	CreateApiKeyForServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error)

	CreateApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error)

	// DeleteApiKeyForServiceAccountWithResponse request
	DeleteApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyForServiceAccountResponse, error)

	// ListTemplatesWithResponse request
	ListTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error)

	// GetTemplateWithResponse request
	GetTemplateWithResponse(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error)

	// ListWorkspaceUsersWithResponse request
	ListWorkspaceUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error)

	// InviteWorkspaceUserWithBodyWithResponse request with any body
	InviteWorkspaceUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error)

	InviteWorkspaceUserWithResponse(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error)

	// RemoveWorkspaceUserWithResponse request
	RemoveWorkspaceUserWithResponse(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*RemoveWorkspaceUserResponse, error)

	// UpdateWorkspaceUserRoleWithBodyWithResponse request with any body
	UpdateWorkspaceUserRoleWithBodyWithResponse(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error)

	UpdateWorkspaceUserRoleWithResponse(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error)

	// ListVolumeTemplatesWithResponse request
	ListVolumeTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumeTemplatesResponse, error)

	// CreateVolumeTemplateWithBodyWithResponse request with any body
	CreateVolumeTemplateWithBodyWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error)

	CreateVolumeTemplateWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error)

	// DeleteVolumeTemplateWithResponse request
	DeleteVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateResponse, error)

	// GetVolumeTemplateWithResponse request
	GetVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*GetVolumeTemplateResponse, error)

	// UpdateVolumeTemplateWithBodyWithResponse request with any body
	UpdateVolumeTemplateWithBodyWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error)

	UpdateVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error)

	// DeleteVolumeTemplateVersionWithResponse request
	DeleteVolumeTemplateVersionWithResponse(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateVersionResponse, error)

	// ListVolumesWithResponse request
	ListVolumesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumesResponse, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// GetVolumeWithResponse request
	GetVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*GetVolumeResponse, error)

	// UpdateVolumeWithBodyWithResponse request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	UpdateVolumeWithResponse(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	// ListWorkspacesWithResponse request
	ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// CreateWorkspaceWithBodyWithResponse request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// CheckWorkspaceAvailabilityWithBodyWithResponse request with any body
	CheckWorkspaceAvailabilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error)

	CheckWorkspaceAvailabilityWithResponse(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error)

	// DeleteWorkspaceWithResponse request
	DeleteWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// GetWorkspaceWithResponse request
	GetWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error)

	// UpdateWorkspaceWithBodyWithResponse request with any body
	UpdateWorkspaceWithBodyWithResponse(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)

	UpdateWorkspaceWithResponse(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error)

	// DeclineWorkspaceInvitationWithResponse request
	DeclineWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeclineWorkspaceInvitationResponse, error)

	// AcceptWorkspaceInvitationWithResponse request
	AcceptWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*AcceptWorkspaceInvitationResponse, error)

	// LeaveWorkspaceWithResponse request
	LeaveWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error)
}

type ListAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Agent
}

// Status returns HTTPResponse.Status
func (r ListAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r CreateAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r DeleteAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r GetAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Agent
}

// Status returns HTTPResponse.Status
func (r UpdateAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAgentRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListAgentRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Configuration
}

// Status returns HTTPResponse.Status
func (r GetConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CustomDomain
}

// Status returns HTTPResponse.Status
func (r ListCustomDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r CreateCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r DeleteCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r GetCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r UpdateCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyCustomDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomDomain
}

// Status returns HTTPResponse.Status
func (r VerifyCustomDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyCustomDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Function
}

// Status returns HTTPResponse.Status
func (r ListFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r CreateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r DeleteFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r GetFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFunctionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Function
}

// Status returns HTTPResponse.Status
func (r UpdateFunctionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFunctionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListFunctionRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CleanupImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Number of images deleted
		Deleted *int `json:"deleted,omitempty"`

		// Message Result message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CleanupImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CleanupImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Image
}

// Status returns HTTPResponse.Status
func (r ListImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r GetImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
}

// Status returns HTTPResponse.Status
func (r DeleteImageTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r CreateIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r DeleteIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIntegrationConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConnection
}

// Status returns HTTPResponse.Status
func (r UpdateIntegrationConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIntegrationConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionModelEndpointConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionModelEndpointConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionModelEndpointConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConnectionModelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConnectionModelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConnectionModelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConnectionModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConnectionModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConnectionModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r GetIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r CreateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobExecutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JobExecution
}

// Status returns HTTPResponse.Status
func (r ListJobExecutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobExecutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r CreateJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r DeleteJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobExecution
}

// Status returns HTTPResponse.Status
func (r GetJobExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListJobRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LocationResponse
}

// Status returns HTTPResponse.Status
func (r ListLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMCPHubDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MCPDefinition
}

// Status returns HTTPResponse.Status
func (r ListMCPHubDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMCPHubDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Model
}

// Status returns HTTPResponse.Status
func (r ListModelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r CreateModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r DeleteModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r GetModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r UpdateModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelRevisionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RevisionMetadata
}

// Status returns HTTPResponse.Status
func (r ListModelRevisionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelRevisionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Policy
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPublicIpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicIps
}

// Status returns HTTPResponse.Status
func (r ListPublicIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPublicIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxHubDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SandboxDefinition
}

// Status returns HTTPResponse.Status
func (r ListSandboxHubDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxHubDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Sandbox
}

// Status returns HTTPResponse.Status
func (r ListSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r CreateSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r GetSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
}

// Status returns HTTPResponse.Status
func (r UpdateSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxPreviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Preview
}

// Status returns HTTPResponse.Status
func (r ListSandboxPreviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxPreviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r CreateSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r GetSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSandboxPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preview
}

// Status returns HTTPResponse.Status
func (r UpdateSandboxPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSandboxPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxPreviewTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PreviewToken
}

// Status returns HTTPResponse.Status
func (r ListSandboxPreviewTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxPreviewTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxPreviewTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreviewToken
}

// Status returns HTTPResponse.Status
func (r CreateSandboxPreviewTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxPreviewTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxPreviewTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Message Success message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxPreviewTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxPreviewTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// ClientSecret Service account client secret (only returned on creation)
		ClientSecret *string `json:"client_secret,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientId Service account client ID
		ClientId *string `json:"client_id,omitempty"`

		// CreatedAt Creation timestamp
		CreatedAt *string `json:"created_at,omitempty"`

		// Description Service account description
		Description *string `json:"description,omitempty"`

		// Name Service account name
		Name *string `json:"name,omitempty"`

		// UpdatedAt Last update timestamp
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiKeysForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApiKey
}

// Status returns HTTPResponse.Status
func (r ListApiKeysForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKey
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeyForServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeyForServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeyForServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
}

// Status returns HTTPResponse.Status
func (r ListTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Template
}

// Status returns HTTPResponse.Status
func (r GetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceUser
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteWorkspaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitation
}

// Status returns HTTPResponse.Status
func (r InviteWorkspaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteWorkspaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveWorkspaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveWorkspaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveWorkspaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceUserRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspaceUser
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceUserRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceUserRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVolumeTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r ListVolumeTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVolumeTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r CreateVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r GetVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeTemplate
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeTemplateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`

		// Template Volume template for creating pre-configured volumes
		Template *VolumeTemplate `json:"template,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeTemplateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeTemplateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Volume
}

// Status returns HTTPResponse.Status
func (r ListVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r GetVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckWorkspaceAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r CheckWorkspaceAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckWorkspaceAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineWorkspaceInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitation
}

// Status returns HTTPResponse.Status
func (r DeclineWorkspaceInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineWorkspaceInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptWorkspaceInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingInvitationAccept
}

// Status returns HTTPResponse.Status
func (r AcceptWorkspaceInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptWorkspaceInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r LeaveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAgentsWithResponse request returning *ListAgentsResponse
func (c *ClientWithResponses) ListAgentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAgentsResponse, error) {
	rsp, err := c.ListAgents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentsResponse(rsp)
}

// CreateAgentWithBodyWithResponse request with arbitrary body returning *CreateAgentResponse
func (c *ClientWithResponses) CreateAgentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error) {
	rsp, err := c.CreateAgentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentWithResponse(ctx context.Context, body CreateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentResponse, error) {
	rsp, err := c.CreateAgent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentResponse(rsp)
}

// DeleteAgentWithResponse request returning *DeleteAgentResponse
func (c *ClientWithResponses) DeleteAgentWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*DeleteAgentResponse, error) {
	rsp, err := c.DeleteAgent(ctx, agentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentResponse(rsp)
}

// GetAgentWithResponse request returning *GetAgentResponse
func (c *ClientWithResponses) GetAgentWithResponse(ctx context.Context, agentName string, params *GetAgentParams, reqEditors ...RequestEditorFn) (*GetAgentResponse, error) {
	rsp, err := c.GetAgent(ctx, agentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentResponse(rsp)
}

// UpdateAgentWithBodyWithResponse request with arbitrary body returning *UpdateAgentResponse
func (c *ClientWithResponses) UpdateAgentWithBodyWithResponse(ctx context.Context, agentName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error) {
	rsp, err := c.UpdateAgentWithBody(ctx, agentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentResponse(rsp)
}

func (c *ClientWithResponses) UpdateAgentWithResponse(ctx context.Context, agentName string, body UpdateAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentResponse, error) {
	rsp, err := c.UpdateAgent(ctx, agentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentResponse(rsp)
}

// ListAgentRevisionsWithResponse request returning *ListAgentRevisionsResponse
func (c *ClientWithResponses) ListAgentRevisionsWithResponse(ctx context.Context, agentName string, reqEditors ...RequestEditorFn) (*ListAgentRevisionsResponse, error) {
	rsp, err := c.ListAgentRevisions(ctx, agentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentRevisionsResponse(rsp)
}

// GetConfigurationWithResponse request returning *GetConfigurationResponse
func (c *ClientWithResponses) GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error) {
	rsp, err := c.GetConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationResponse(rsp)
}

// ListCustomDomainsWithResponse request returning *ListCustomDomainsResponse
func (c *ClientWithResponses) ListCustomDomainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCustomDomainsResponse, error) {
	rsp, err := c.ListCustomDomains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomDomainsResponse(rsp)
}

// CreateCustomDomainWithBodyWithResponse request with arbitrary body returning *CreateCustomDomainResponse
func (c *ClientWithResponses) CreateCustomDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error) {
	rsp, err := c.CreateCustomDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomDomainWithResponse(ctx context.Context, body CreateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomDomainResponse, error) {
	rsp, err := c.CreateCustomDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomDomainResponse(rsp)
}

// DeleteCustomDomainWithResponse request returning *DeleteCustomDomainResponse
func (c *ClientWithResponses) DeleteCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*DeleteCustomDomainResponse, error) {
	rsp, err := c.DeleteCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomDomainResponse(rsp)
}

// GetCustomDomainWithResponse request returning *GetCustomDomainResponse
func (c *ClientWithResponses) GetCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*GetCustomDomainResponse, error) {
	rsp, err := c.GetCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomDomainResponse(rsp)
}

// UpdateCustomDomainWithBodyWithResponse request with arbitrary body returning *UpdateCustomDomainResponse
func (c *ClientWithResponses) UpdateCustomDomainWithBodyWithResponse(ctx context.Context, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error) {
	rsp, err := c.UpdateCustomDomainWithBody(ctx, domainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomDomainResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomDomainWithResponse(ctx context.Context, domainName string, body UpdateCustomDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomDomainResponse, error) {
	rsp, err := c.UpdateCustomDomain(ctx, domainName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomDomainResponse(rsp)
}

// VerifyCustomDomainWithResponse request returning *VerifyCustomDomainResponse
func (c *ClientWithResponses) VerifyCustomDomainWithResponse(ctx context.Context, domainName string, reqEditors ...RequestEditorFn) (*VerifyCustomDomainResponse, error) {
	rsp, err := c.VerifyCustomDomain(ctx, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyCustomDomainResponse(rsp)
}

// ListFunctionsWithResponse request returning *ListFunctionsResponse
func (c *ClientWithResponses) ListFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFunctionsResponse, error) {
	rsp, err := c.ListFunctions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionsResponse(rsp)
}

// CreateFunctionWithBodyWithResponse request with arbitrary body returning *CreateFunctionResponse
func (c *ClientWithResponses) CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunctionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

func (c *ClientWithResponses) CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResponse, error) {
	rsp, err := c.CreateFunction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResponse(rsp)
}

// DeleteFunctionWithResponse request returning *DeleteFunctionResponse
func (c *ClientWithResponses) DeleteFunctionWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*DeleteFunctionResponse, error) {
	rsp, err := c.DeleteFunction(ctx, functionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFunctionResponse(rsp)
}

// GetFunctionWithResponse request returning *GetFunctionResponse
func (c *ClientWithResponses) GetFunctionWithResponse(ctx context.Context, functionName string, params *GetFunctionParams, reqEditors ...RequestEditorFn) (*GetFunctionResponse, error) {
	rsp, err := c.GetFunction(ctx, functionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionResponse(rsp)
}

// UpdateFunctionWithBodyWithResponse request with arbitrary body returning *UpdateFunctionResponse
func (c *ClientWithResponses) UpdateFunctionWithBodyWithResponse(ctx context.Context, functionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunctionWithBody(ctx, functionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

func (c *ClientWithResponses) UpdateFunctionWithResponse(ctx context.Context, functionName string, body UpdateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFunctionResponse, error) {
	rsp, err := c.UpdateFunction(ctx, functionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFunctionResponse(rsp)
}

// ListFunctionRevisionsWithResponse request returning *ListFunctionRevisionsResponse
func (c *ClientWithResponses) ListFunctionRevisionsWithResponse(ctx context.Context, functionName string, reqEditors ...RequestEditorFn) (*ListFunctionRevisionsResponse, error) {
	rsp, err := c.ListFunctionRevisions(ctx, functionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionRevisionsResponse(rsp)
}

// CleanupImagesWithResponse request returning *CleanupImagesResponse
func (c *ClientWithResponses) CleanupImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CleanupImagesResponse, error) {
	rsp, err := c.CleanupImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCleanupImagesResponse(rsp)
}

// ListImagesWithResponse request returning *ListImagesResponse
func (c *ClientWithResponses) ListImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImagesResponse, error) {
	rsp, err := c.ListImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImagesResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, resourceType, imageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// GetImageWithResponse request returning *GetImageResponse
func (c *ClientWithResponses) GetImageWithResponse(ctx context.Context, resourceType string, imageName string, reqEditors ...RequestEditorFn) (*GetImageResponse, error) {
	rsp, err := c.GetImage(ctx, resourceType, imageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageResponse(rsp)
}

// DeleteImageTagWithResponse request returning *DeleteImageTagResponse
func (c *ClientWithResponses) DeleteImageTagWithResponse(ctx context.Context, resourceType string, imageName string, tagName string, reqEditors ...RequestEditorFn) (*DeleteImageTagResponse, error) {
	rsp, err := c.DeleteImageTag(ctx, resourceType, imageName, tagName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageTagResponse(rsp)
}

// ListIntegrationConnectionsWithResponse request returning *ListIntegrationConnectionsResponse
func (c *ClientWithResponses) ListIntegrationConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionsResponse, error) {
	rsp, err := c.ListIntegrationConnections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConnectionsResponse(rsp)
}

// CreateIntegrationConnectionWithBodyWithResponse request with arbitrary body returning *CreateIntegrationConnectionResponse
func (c *ClientWithResponses) CreateIntegrationConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error) {
	rsp, err := c.CreateIntegrationConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateIntegrationConnectionWithResponse(ctx context.Context, body CreateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationConnectionResponse, error) {
	rsp, err := c.CreateIntegrationConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationConnectionResponse(rsp)
}

// DeleteIntegrationConnectionWithResponse request returning *DeleteIntegrationConnectionResponse
func (c *ClientWithResponses) DeleteIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*DeleteIntegrationConnectionResponse, error) {
	rsp, err := c.DeleteIntegrationConnection(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIntegrationConnectionResponse(rsp)
}

// GetIntegrationConnectionWithResponse request returning *GetIntegrationConnectionResponse
func (c *ClientWithResponses) GetIntegrationConnectionWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionResponse, error) {
	rsp, err := c.GetIntegrationConnection(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionResponse(rsp)
}

// UpdateIntegrationConnectionWithBodyWithResponse request with arbitrary body returning *UpdateIntegrationConnectionResponse
func (c *ClientWithResponses) UpdateIntegrationConnectionWithBodyWithResponse(ctx context.Context, connectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error) {
	rsp, err := c.UpdateIntegrationConnectionWithBody(ctx, connectionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateIntegrationConnectionWithResponse(ctx context.Context, connectionName string, body UpdateIntegrationConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationConnectionResponse, error) {
	rsp, err := c.UpdateIntegrationConnection(ctx, connectionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationConnectionResponse(rsp)
}

// GetIntegrationConnectionModelEndpointConfigurationsWithResponse request returning *GetIntegrationConnectionModelEndpointConfigurationsResponse
func (c *ClientWithResponses) GetIntegrationConnectionModelEndpointConfigurationsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error) {
	rsp, err := c.GetIntegrationConnectionModelEndpointConfigurations(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionModelEndpointConfigurationsResponse(rsp)
}

// ListIntegrationConnectionModelsWithResponse request returning *ListIntegrationConnectionModelsResponse
func (c *ClientWithResponses) ListIntegrationConnectionModelsWithResponse(ctx context.Context, connectionName string, reqEditors ...RequestEditorFn) (*ListIntegrationConnectionModelsResponse, error) {
	rsp, err := c.ListIntegrationConnectionModels(ctx, connectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConnectionModelsResponse(rsp)
}

// GetIntegrationConnectionModelWithResponse request returning *GetIntegrationConnectionModelResponse
func (c *ClientWithResponses) GetIntegrationConnectionModelWithResponse(ctx context.Context, connectionName string, modelId string, reqEditors ...RequestEditorFn) (*GetIntegrationConnectionModelResponse, error) {
	rsp, err := c.GetIntegrationConnectionModel(ctx, connectionName, modelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConnectionModelResponse(rsp)
}

// GetIntegrationWithResponse request returning *GetIntegrationResponse
func (c *ClientWithResponses) GetIntegrationWithResponse(ctx context.Context, integrationName string, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error) {
	rsp, err := c.GetIntegration(ctx, integrationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// CreateJobWithBodyWithResponse request with arbitrary body returning *CreateJobResponse
func (c *ClientWithResponses) CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

func (c *ClientWithResponses) CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

// DeleteJobWithResponse request returning *DeleteJobResponse
func (c *ClientWithResponses) DeleteJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error) {
	rsp, err := c.DeleteJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, jobId string, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// UpdateJobWithBodyWithResponse request with arbitrary body returning *UpdateJobResponse
func (c *ClientWithResponses) UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobWithResponse(ctx context.Context, jobId string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

// ListJobExecutionsWithResponse request returning *ListJobExecutionsResponse
func (c *ClientWithResponses) ListJobExecutionsWithResponse(ctx context.Context, jobId string, params *ListJobExecutionsParams, reqEditors ...RequestEditorFn) (*ListJobExecutionsResponse, error) {
	rsp, err := c.ListJobExecutions(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobExecutionsResponse(rsp)
}

// CreateJobExecutionWithBodyWithResponse request with arbitrary body returning *CreateJobExecutionResponse
func (c *ClientWithResponses) CreateJobExecutionWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error) {
	rsp, err := c.CreateJobExecutionWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobExecutionResponse(rsp)
}

func (c *ClientWithResponses) CreateJobExecutionWithResponse(ctx context.Context, jobId string, body CreateJobExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobExecutionResponse, error) {
	rsp, err := c.CreateJobExecution(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobExecutionResponse(rsp)
}

// DeleteJobExecutionWithResponse request returning *DeleteJobExecutionResponse
func (c *ClientWithResponses) DeleteJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*DeleteJobExecutionResponse, error) {
	rsp, err := c.DeleteJobExecution(ctx, jobId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobExecutionResponse(rsp)
}

// GetJobExecutionWithResponse request returning *GetJobExecutionResponse
func (c *ClientWithResponses) GetJobExecutionWithResponse(ctx context.Context, jobId string, executionId string, reqEditors ...RequestEditorFn) (*GetJobExecutionResponse, error) {
	rsp, err := c.GetJobExecution(ctx, jobId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobExecutionResponse(rsp)
}

// ListJobRevisionsWithResponse request returning *ListJobRevisionsResponse
func (c *ClientWithResponses) ListJobRevisionsWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*ListJobRevisionsResponse, error) {
	rsp, err := c.ListJobRevisions(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobRevisionsResponse(rsp)
}

// ListLocationsWithResponse request returning *ListLocationsResponse
func (c *ClientWithResponses) ListLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error) {
	rsp, err := c.ListLocations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLocationsResponse(rsp)
}

// ListMCPHubDefinitionsWithResponse request returning *ListMCPHubDefinitionsResponse
func (c *ClientWithResponses) ListMCPHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMCPHubDefinitionsResponse, error) {
	rsp, err := c.ListMCPHubDefinitions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMCPHubDefinitionsResponse(rsp)
}

// ListModelsWithResponse request returning *ListModelsResponse
func (c *ClientWithResponses) ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResponse, error) {
	rsp, err := c.ListModels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelsResponse(rsp)
}

// CreateModelWithBodyWithResponse request with arbitrary body returning *CreateModelResponse
func (c *ClientWithResponses) CreateModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelResponse, error) {
	rsp, err := c.CreateModelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResponse(rsp)
}

func (c *ClientWithResponses) CreateModelWithResponse(ctx context.Context, body CreateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelResponse, error) {
	rsp, err := c.CreateModel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelResponse(rsp)
}

// DeleteModelWithResponse request returning *DeleteModelResponse
func (c *ClientWithResponses) DeleteModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*DeleteModelResponse, error) {
	rsp, err := c.DeleteModel(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModelResponse(rsp)
}

// GetModelWithResponse request returning *GetModelResponse
func (c *ClientWithResponses) GetModelWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*GetModelResponse, error) {
	rsp, err := c.GetModel(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelResponse(rsp)
}

// UpdateModelWithBodyWithResponse request with arbitrary body returning *UpdateModelResponse
func (c *ClientWithResponses) UpdateModelWithBodyWithResponse(ctx context.Context, modelName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error) {
	rsp, err := c.UpdateModelWithBody(ctx, modelName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelResponse(rsp)
}

func (c *ClientWithResponses) UpdateModelWithResponse(ctx context.Context, modelName string, body UpdateModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelResponse, error) {
	rsp, err := c.UpdateModel(ctx, modelName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelResponse(rsp)
}

// ListModelRevisionsWithResponse request returning *ListModelRevisionsResponse
func (c *ClientWithResponses) ListModelRevisionsWithResponse(ctx context.Context, modelName string, reqEditors ...RequestEditorFn) (*ListModelRevisionsResponse, error) {
	rsp, err := c.ListModelRevisions(ctx, modelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelRevisionsResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyName string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyName string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListPublicIpsWithResponse request returning *ListPublicIpsResponse
func (c *ClientWithResponses) ListPublicIpsWithResponse(ctx context.Context, params *ListPublicIpsParams, reqEditors ...RequestEditorFn) (*ListPublicIpsResponse, error) {
	rsp, err := c.ListPublicIps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPublicIpsResponse(rsp)
}

// ListSandboxHubDefinitionsWithResponse request returning *ListSandboxHubDefinitionsResponse
func (c *ClientWithResponses) ListSandboxHubDefinitionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxHubDefinitionsResponse, error) {
	rsp, err := c.ListSandboxHubDefinitions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxHubDefinitionsResponse(rsp)
}

// ListSandboxesWithResponse request returning *ListSandboxesResponse
func (c *ClientWithResponses) ListSandboxesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error) {
	rsp, err := c.ListSandboxes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxesResponse(rsp)
}

// CreateSandboxWithBodyWithResponse request with arbitrary body returning *CreateSandboxResponse
func (c *ClientWithResponses) CreateSandboxWithBodyWithResponse(ctx context.Context, params *CreateSandboxParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandboxWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxWithResponse(ctx context.Context, params *CreateSandboxParams, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandbox(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

// DeleteSandboxWithResponse request returning *DeleteSandboxResponse
func (c *ClientWithResponses) DeleteSandboxWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error) {
	rsp, err := c.DeleteSandbox(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxResponse(rsp)
}

// GetSandboxWithResponse request returning *GetSandboxResponse
func (c *ClientWithResponses) GetSandboxWithResponse(ctx context.Context, sandboxName string, params *GetSandboxParams, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error) {
	rsp, err := c.GetSandbox(ctx, sandboxName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxResponse(rsp)
}

// UpdateSandboxWithBodyWithResponse request with arbitrary body returning *UpdateSandboxResponse
func (c *ClientWithResponses) UpdateSandboxWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error) {
	rsp, err := c.UpdateSandboxWithBody(ctx, sandboxName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxResponse(rsp)
}

func (c *ClientWithResponses) UpdateSandboxWithResponse(ctx context.Context, sandboxName string, body UpdateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxResponse, error) {
	rsp, err := c.UpdateSandbox(ctx, sandboxName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxResponse(rsp)
}

// ListSandboxPreviewsWithResponse request returning *ListSandboxPreviewsResponse
func (c *ClientWithResponses) ListSandboxPreviewsWithResponse(ctx context.Context, sandboxName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewsResponse, error) {
	rsp, err := c.ListSandboxPreviews(ctx, sandboxName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxPreviewsResponse(rsp)
}

// CreateSandboxPreviewWithBodyWithResponse request with arbitrary body returning *CreateSandboxPreviewResponse
func (c *ClientWithResponses) CreateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error) {
	rsp, err := c.CreateSandboxPreviewWithBody(ctx, sandboxName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, body CreateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewResponse, error) {
	rsp, err := c.CreateSandboxPreview(ctx, sandboxName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewResponse(rsp)
}

// DeleteSandboxPreviewWithResponse request returning *DeleteSandboxPreviewResponse
func (c *ClientWithResponses) DeleteSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewResponse, error) {
	rsp, err := c.DeleteSandboxPreview(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxPreviewResponse(rsp)
}

// GetSandboxPreviewWithResponse request returning *GetSandboxPreviewResponse
func (c *ClientWithResponses) GetSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*GetSandboxPreviewResponse, error) {
	rsp, err := c.GetSandboxPreview(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxPreviewResponse(rsp)
}

// UpdateSandboxPreviewWithBodyWithResponse request with arbitrary body returning *UpdateSandboxPreviewResponse
func (c *ClientWithResponses) UpdateSandboxPreviewWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error) {
	rsp, err := c.UpdateSandboxPreviewWithBody(ctx, sandboxName, previewName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxPreviewResponse(rsp)
}

func (c *ClientWithResponses) UpdateSandboxPreviewWithResponse(ctx context.Context, sandboxName string, previewName string, body UpdateSandboxPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxPreviewResponse, error) {
	rsp, err := c.UpdateSandboxPreview(ctx, sandboxName, previewName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxPreviewResponse(rsp)
}

// ListSandboxPreviewTokensWithResponse request returning *ListSandboxPreviewTokensResponse
func (c *ClientWithResponses) ListSandboxPreviewTokensWithResponse(ctx context.Context, sandboxName string, previewName string, reqEditors ...RequestEditorFn) (*ListSandboxPreviewTokensResponse, error) {
	rsp, err := c.ListSandboxPreviewTokens(ctx, sandboxName, previewName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxPreviewTokensResponse(rsp)
}

// CreateSandboxPreviewTokenWithBodyWithResponse request with arbitrary body returning *CreateSandboxPreviewTokenResponse
func (c *ClientWithResponses) CreateSandboxPreviewTokenWithBodyWithResponse(ctx context.Context, sandboxName string, previewName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error) {
	rsp, err := c.CreateSandboxPreviewTokenWithBody(ctx, sandboxName, previewName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, body CreateSandboxPreviewTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxPreviewTokenResponse, error) {
	rsp, err := c.CreateSandboxPreviewToken(ctx, sandboxName, previewName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxPreviewTokenResponse(rsp)
}

// DeleteSandboxPreviewTokenWithResponse request returning *DeleteSandboxPreviewTokenResponse
func (c *ClientWithResponses) DeleteSandboxPreviewTokenWithResponse(ctx context.Context, sandboxName string, previewName string, tokenName string, reqEditors ...RequestEditorFn) (*DeleteSandboxPreviewTokenResponse, error) {
	rsp, err := c.DeleteSandboxPreviewToken(ctx, sandboxName, previewName, tokenName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxPreviewTokenResponse(rsp)
}

// GetWorkspaceServiceAccountsWithResponse request returning *GetWorkspaceServiceAccountsResponse
func (c *ClientWithResponses) GetWorkspaceServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkspaceServiceAccountsResponse, error) {
	rsp, err := c.GetWorkspaceServiceAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceServiceAccountsResponse(rsp)
}

// CreateWorkspaceServiceAccountWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceServiceAccountResponse
func (c *ClientWithResponses) CreateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.CreateWorkspaceServiceAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceServiceAccountWithResponse(ctx context.Context, body CreateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.CreateWorkspaceServiceAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceServiceAccountResponse(rsp)
}

// DeleteWorkspaceServiceAccountWithResponse request returning *DeleteWorkspaceServiceAccountResponse
func (c *ClientWithResponses) DeleteWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceServiceAccountResponse, error) {
	rsp, err := c.DeleteWorkspaceServiceAccount(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceServiceAccountResponse(rsp)
}

// UpdateWorkspaceServiceAccountWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceServiceAccountResponse
func (c *ClientWithResponses) UpdateWorkspaceServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.UpdateWorkspaceServiceAccountWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceServiceAccountWithResponse(ctx context.Context, clientId string, body UpdateWorkspaceServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceServiceAccountResponse, error) {
	rsp, err := c.UpdateWorkspaceServiceAccount(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceServiceAccountResponse(rsp)
}

// ListApiKeysForServiceAccountWithResponse request returning *ListApiKeysForServiceAccountResponse
func (c *ClientWithResponses) ListApiKeysForServiceAccountWithResponse(ctx context.Context, clientId string, reqEditors ...RequestEditorFn) (*ListApiKeysForServiceAccountResponse, error) {
	rsp, err := c.ListApiKeysForServiceAccount(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysForServiceAccountResponse(rsp)
}

// CreateApiKeyForServiceAccountWithBodyWithResponse request with arbitrary body returning *CreateApiKeyForServiceAccountResponse
func (c *ClientWithResponses) CreateApiKeyForServiceAccountWithBodyWithResponse(ctx context.Context, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error) {
	rsp, err := c.CreateApiKeyForServiceAccountWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyForServiceAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, body CreateApiKeyForServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyForServiceAccountResponse, error) {
	rsp, err := c.CreateApiKeyForServiceAccount(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyForServiceAccountResponse(rsp)
}

// DeleteApiKeyForServiceAccountWithResponse request returning *DeleteApiKeyForServiceAccountResponse
func (c *ClientWithResponses) DeleteApiKeyForServiceAccountWithResponse(ctx context.Context, clientId string, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyForServiceAccountResponse, error) {
	rsp, err := c.DeleteApiKeyForServiceAccount(ctx, clientId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeyForServiceAccountResponse(rsp)
}

// ListTemplatesWithResponse request returning *ListTemplatesResponse
func (c *ClientWithResponses) ListTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error) {
	rsp, err := c.ListTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTemplatesResponse(rsp)
}

// GetTemplateWithResponse request returning *GetTemplateResponse
func (c *ClientWithResponses) GetTemplateWithResponse(ctx context.Context, templateName string, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error) {
	rsp, err := c.GetTemplate(ctx, templateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateResponse(rsp)
}

// ListWorkspaceUsersWithResponse request returning *ListWorkspaceUsersResponse
func (c *ClientWithResponses) ListWorkspaceUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error) {
	rsp, err := c.ListWorkspaceUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceUsersResponse(rsp)
}

// InviteWorkspaceUserWithBodyWithResponse request with arbitrary body returning *InviteWorkspaceUserResponse
func (c *ClientWithResponses) InviteWorkspaceUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error) {
	rsp, err := c.InviteWorkspaceUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteWorkspaceUserResponse(rsp)
}

func (c *ClientWithResponses) InviteWorkspaceUserWithResponse(ctx context.Context, body InviteWorkspaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteWorkspaceUserResponse, error) {
	rsp, err := c.InviteWorkspaceUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteWorkspaceUserResponse(rsp)
}

// RemoveWorkspaceUserWithResponse request returning *RemoveWorkspaceUserResponse
func (c *ClientWithResponses) RemoveWorkspaceUserWithResponse(ctx context.Context, subOrEmail string, reqEditors ...RequestEditorFn) (*RemoveWorkspaceUserResponse, error) {
	rsp, err := c.RemoveWorkspaceUser(ctx, subOrEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveWorkspaceUserResponse(rsp)
}

// UpdateWorkspaceUserRoleWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceUserRoleResponse
func (c *ClientWithResponses) UpdateWorkspaceUserRoleWithBodyWithResponse(ctx context.Context, subOrEmail string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error) {
	rsp, err := c.UpdateWorkspaceUserRoleWithBody(ctx, subOrEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceUserRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceUserRoleWithResponse(ctx context.Context, subOrEmail string, body UpdateWorkspaceUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceUserRoleResponse, error) {
	rsp, err := c.UpdateWorkspaceUserRole(ctx, subOrEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceUserRoleResponse(rsp)
}

// ListVolumeTemplatesWithResponse request returning *ListVolumeTemplatesResponse
func (c *ClientWithResponses) ListVolumeTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumeTemplatesResponse, error) {
	rsp, err := c.ListVolumeTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVolumeTemplatesResponse(rsp)
}

// CreateVolumeTemplateWithBodyWithResponse request with arbitrary body returning *CreateVolumeTemplateResponse
func (c *ClientWithResponses) CreateVolumeTemplateWithBodyWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error) {
	rsp, err := c.CreateVolumeTemplateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeTemplateWithResponse(ctx context.Context, params *CreateVolumeTemplateParams, body CreateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeTemplateResponse, error) {
	rsp, err := c.CreateVolumeTemplate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeTemplateResponse(rsp)
}

// DeleteVolumeTemplateWithResponse request returning *DeleteVolumeTemplateResponse
func (c *ClientWithResponses) DeleteVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateResponse, error) {
	rsp, err := c.DeleteVolumeTemplate(ctx, volumeTemplateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeTemplateResponse(rsp)
}

// GetVolumeTemplateWithResponse request returning *GetVolumeTemplateResponse
func (c *ClientWithResponses) GetVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, reqEditors ...RequestEditorFn) (*GetVolumeTemplateResponse, error) {
	rsp, err := c.GetVolumeTemplate(ctx, volumeTemplateName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVolumeTemplateResponse(rsp)
}

// UpdateVolumeTemplateWithBodyWithResponse request with arbitrary body returning *UpdateVolumeTemplateResponse
func (c *ClientWithResponses) UpdateVolumeTemplateWithBodyWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error) {
	rsp, err := c.UpdateVolumeTemplateWithBody(ctx, volumeTemplateName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeTemplateWithResponse(ctx context.Context, volumeTemplateName string, params *UpdateVolumeTemplateParams, body UpdateVolumeTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeTemplateResponse, error) {
	rsp, err := c.UpdateVolumeTemplate(ctx, volumeTemplateName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeTemplateResponse(rsp)
}

// DeleteVolumeTemplateVersionWithResponse request returning *DeleteVolumeTemplateVersionResponse
func (c *ClientWithResponses) DeleteVolumeTemplateVersionWithResponse(ctx context.Context, volumeTemplateName string, versionName string, reqEditors ...RequestEditorFn) (*DeleteVolumeTemplateVersionResponse, error) {
	rsp, err := c.DeleteVolumeTemplateVersion(ctx, volumeTemplateName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeTemplateVersionResponse(rsp)
}

// ListVolumesWithResponse request returning *ListVolumesResponse
func (c *ClientWithResponses) ListVolumesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListVolumesResponse, error) {
	rsp, err := c.ListVolumes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, volumeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// GetVolumeWithResponse request returning *GetVolumeResponse
func (c *ClientWithResponses) GetVolumeWithResponse(ctx context.Context, volumeName string, reqEditors ...RequestEditorFn) (*GetVolumeResponse, error) {
	rsp, err := c.GetVolume(ctx, volumeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVolumeResponse(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResponse
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, volumeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, volumeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, volumeName string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolume(ctx, volumeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// CheckWorkspaceAvailabilityWithBodyWithResponse request with arbitrary body returning *CheckWorkspaceAvailabilityResponse
func (c *ClientWithResponses) CheckWorkspaceAvailabilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error) {
	rsp, err := c.CheckWorkspaceAvailabilityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckWorkspaceAvailabilityResponse(rsp)
}

func (c *ClientWithResponses) CheckWorkspaceAvailabilityWithResponse(ctx context.Context, body CheckWorkspaceAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckWorkspaceAvailabilityResponse, error) {
	rsp, err := c.CheckWorkspaceAvailability(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckWorkspaceAvailabilityResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// GetWorkspaceWithResponse request returning *GetWorkspaceResponse
func (c *ClientWithResponses) GetWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error) {
	rsp, err := c.GetWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceResponse(rsp)
}

// UpdateWorkspaceWithBodyWithResponse request with arbitrary body returning *UpdateWorkspaceResponse
func (c *ClientWithResponses) UpdateWorkspaceWithBodyWithResponse(ctx context.Context, workspaceName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspaceWithBody(ctx, workspaceName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkspaceWithResponse(ctx context.Context, workspaceName string, body UpdateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	rsp, err := c.UpdateWorkspace(ctx, workspaceName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkspaceResponse(rsp)
}

// DeclineWorkspaceInvitationWithResponse request returning *DeclineWorkspaceInvitationResponse
func (c *ClientWithResponses) DeclineWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*DeclineWorkspaceInvitationResponse, error) {
	rsp, err := c.DeclineWorkspaceInvitation(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineWorkspaceInvitationResponse(rsp)
}

// AcceptWorkspaceInvitationWithResponse request returning *AcceptWorkspaceInvitationResponse
func (c *ClientWithResponses) AcceptWorkspaceInvitationWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*AcceptWorkspaceInvitationResponse, error) {
	rsp, err := c.AcceptWorkspaceInvitation(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptWorkspaceInvitationResponse(rsp)
}

// LeaveWorkspaceWithResponse request returning *LeaveWorkspaceResponse
func (c *ClientWithResponses) LeaveWorkspaceWithResponse(ctx context.Context, workspaceName string, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error) {
	rsp, err := c.LeaveWorkspace(ctx, workspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveWorkspaceResponse(rsp)
}

// ParseListAgentsResponse parses an HTTP response from a ListAgentsWithResponse call
func ParseListAgentsResponse(rsp *http.Response) (*ListAgentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAgentResponse parses an HTTP response from a CreateAgentWithResponse call
func ParseCreateAgentResponse(rsp *http.Response) (*CreateAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAgentResponse parses an HTTP response from a DeleteAgentWithResponse call
func ParseDeleteAgentResponse(rsp *http.Response) (*DeleteAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAgentResponse parses an HTTP response from a GetAgentWithResponse call
func ParseGetAgentResponse(rsp *http.Response) (*GetAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAgentResponse parses an HTTP response from a UpdateAgentWithResponse call
func ParseUpdateAgentResponse(rsp *http.Response) (*UpdateAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Agent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAgentRevisionsResponse parses an HTTP response from a ListAgentRevisionsWithResponse call
func ParseListAgentRevisionsResponse(rsp *http.Response) (*ListAgentRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigurationResponse parses an HTTP response from a GetConfigurationWithResponse call
func ParseGetConfigurationResponse(rsp *http.Response) (*GetConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Configuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomDomainsResponse parses an HTTP response from a ListCustomDomainsWithResponse call
func ParseListCustomDomainsResponse(rsp *http.Response) (*ListCustomDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomDomainResponse parses an HTTP response from a CreateCustomDomainWithResponse call
func ParseCreateCustomDomainResponse(rsp *http.Response) (*CreateCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomDomainResponse parses an HTTP response from a DeleteCustomDomainWithResponse call
func ParseDeleteCustomDomainResponse(rsp *http.Response) (*DeleteCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomDomainResponse parses an HTTP response from a GetCustomDomainWithResponse call
func ParseGetCustomDomainResponse(rsp *http.Response) (*GetCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomDomainResponse parses an HTTP response from a UpdateCustomDomainWithResponse call
func ParseUpdateCustomDomainResponse(rsp *http.Response) (*UpdateCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVerifyCustomDomainResponse parses an HTTP response from a VerifyCustomDomainWithResponse call
func ParseVerifyCustomDomainResponse(rsp *http.Response) (*VerifyCustomDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyCustomDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFunctionsResponse parses an HTTP response from a ListFunctionsWithResponse call
func ParseListFunctionsResponse(rsp *http.Response) (*ListFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFunctionResponse parses an HTTP response from a CreateFunctionWithResponse call
func ParseCreateFunctionResponse(rsp *http.Response) (*CreateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFunctionResponse parses an HTTP response from a DeleteFunctionWithResponse call
func ParseDeleteFunctionResponse(rsp *http.Response) (*DeleteFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFunctionResponse parses an HTTP response from a GetFunctionWithResponse call
func ParseGetFunctionResponse(rsp *http.Response) (*GetFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFunctionResponse parses an HTTP response from a UpdateFunctionWithResponse call
func ParseUpdateFunctionResponse(rsp *http.Response) (*UpdateFunctionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFunctionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Function
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFunctionRevisionsResponse parses an HTTP response from a ListFunctionRevisionsWithResponse call
func ParseListFunctionRevisionsResponse(rsp *http.Response) (*ListFunctionRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCleanupImagesResponse parses an HTTP response from a CleanupImagesWithResponse call
func ParseCleanupImagesResponse(rsp *http.Response) (*CleanupImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CleanupImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Number of images deleted
			Deleted *int `json:"deleted,omitempty"`

			// Message Result message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListImagesResponse parses an HTTP response from a ListImagesWithResponse call
func ParseListImagesResponse(rsp *http.Response) (*ListImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetImageResponse parses an HTTP response from a GetImageWithResponse call
func ParseGetImageResponse(rsp *http.Response) (*GetImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageTagResponse parses an HTTP response from a DeleteImageTagWithResponse call
func ParseDeleteImageTagResponse(rsp *http.Response) (*DeleteImageTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIntegrationConnectionsResponse parses an HTTP response from a ListIntegrationConnectionsWithResponse call
func ParseListIntegrationConnectionsResponse(rsp *http.Response) (*ListIntegrationConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIntegrationConnectionResponse parses an HTTP response from a CreateIntegrationConnectionWithResponse call
func ParseCreateIntegrationConnectionResponse(rsp *http.Response) (*CreateIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteIntegrationConnectionResponse parses an HTTP response from a DeleteIntegrationConnectionWithResponse call
func ParseDeleteIntegrationConnectionResponse(rsp *http.Response) (*DeleteIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConnectionResponse parses an HTTP response from a GetIntegrationConnectionWithResponse call
func ParseGetIntegrationConnectionResponse(rsp *http.Response) (*GetIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateIntegrationConnectionResponse parses an HTTP response from a UpdateIntegrationConnectionWithResponse call
func ParseUpdateIntegrationConnectionResponse(rsp *http.Response) (*UpdateIntegrationConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIntegrationConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConnectionModelEndpointConfigurationsResponse parses an HTTP response from a GetIntegrationConnectionModelEndpointConfigurationsWithResponse call
func ParseGetIntegrationConnectionModelEndpointConfigurationsResponse(rsp *http.Response) (*GetIntegrationConnectionModelEndpointConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionModelEndpointConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListIntegrationConnectionModelsResponse parses an HTTP response from a ListIntegrationConnectionModelsWithResponse call
func ParseListIntegrationConnectionModelsResponse(rsp *http.Response) (*ListIntegrationConnectionModelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConnectionModelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIntegrationConnectionModelResponse parses an HTTP response from a GetIntegrationConnectionModelWithResponse call
func ParseGetIntegrationConnectionModelResponse(rsp *http.Response) (*GetIntegrationConnectionModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConnectionModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIntegrationResponse parses an HTTP response from a GetIntegrationWithResponse call
func ParseGetIntegrationResponse(rsp *http.Response) (*GetIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJobResponse parses an HTTP response from a CreateJobWithResponse call
func ParseCreateJobResponse(rsp *http.Response) (*CreateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobResponse parses an HTTP response from a DeleteJobWithResponse call
func ParseDeleteJobResponse(rsp *http.Response) (*DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateJobResponse parses an HTTP response from a UpdateJobWithResponse call
func ParseUpdateJobResponse(rsp *http.Response) (*UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobExecutionsResponse parses an HTTP response from a ListJobExecutionsWithResponse call
func ParseListJobExecutionsResponse(rsp *http.Response) (*ListJobExecutionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobExecutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJobExecutionResponse parses an HTTP response from a CreateJobExecutionWithResponse call
func ParseCreateJobExecutionResponse(rsp *http.Response) (*CreateJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobExecutionResponse parses an HTTP response from a DeleteJobExecutionWithResponse call
func ParseDeleteJobExecutionResponse(rsp *http.Response) (*DeleteJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobExecutionResponse parses an HTTP response from a GetJobExecutionWithResponse call
func ParseGetJobExecutionResponse(rsp *http.Response) (*GetJobExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobRevisionsResponse parses an HTTP response from a ListJobRevisionsWithResponse call
func ParseListJobRevisionsResponse(rsp *http.Response) (*ListJobRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLocationsResponse parses an HTTP response from a ListLocationsWithResponse call
func ParseListLocationsResponse(rsp *http.Response) (*ListLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMCPHubDefinitionsResponse parses an HTTP response from a ListMCPHubDefinitionsWithResponse call
func ParseListMCPHubDefinitionsResponse(rsp *http.Response) (*ListMCPHubDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMCPHubDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MCPDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelsResponse parses an HTTP response from a ListModelsWithResponse call
func ParseListModelsResponse(rsp *http.Response) (*ListModelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateModelResponse parses an HTTP response from a CreateModelWithResponse call
func ParseCreateModelResponse(rsp *http.Response) (*CreateModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteModelResponse parses an HTTP response from a DeleteModelWithResponse call
func ParseDeleteModelResponse(rsp *http.Response) (*DeleteModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModelResponse parses an HTTP response from a GetModelWithResponse call
func ParseGetModelResponse(rsp *http.Response) (*GetModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateModelResponse parses an HTTP response from a UpdateModelWithResponse call
func ParseUpdateModelResponse(rsp *http.Response) (*UpdateModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelRevisionsResponse parses an HTTP response from a ListModelRevisionsWithResponse call
func ParseListModelRevisionsResponse(rsp *http.Response) (*ListModelRevisionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelRevisionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RevisionMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPublicIpsResponse parses an HTTP response from a ListPublicIpsWithResponse call
func ParseListPublicIpsResponse(rsp *http.Response) (*ListPublicIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPublicIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicIps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxHubDefinitionsResponse parses an HTTP response from a ListSandboxHubDefinitionsWithResponse call
func ParseListSandboxHubDefinitionsResponse(rsp *http.Response) (*ListSandboxHubDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxHubDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SandboxDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxesResponse parses an HTTP response from a ListSandboxesWithResponse call
func ParseListSandboxesResponse(rsp *http.Response) (*ListSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxResponse parses an HTTP response from a CreateSandboxWithResponse call
func ParseCreateSandboxResponse(rsp *http.Response) (*CreateSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxResponse parses an HTTP response from a DeleteSandboxWithResponse call
func ParseDeleteSandboxResponse(rsp *http.Response) (*DeleteSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSandboxResponse parses an HTTP response from a GetSandboxWithResponse call
func ParseGetSandboxResponse(rsp *http.Response) (*GetSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSandboxResponse parses an HTTP response from a UpdateSandboxWithResponse call
func ParseUpdateSandboxResponse(rsp *http.Response) (*UpdateSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxPreviewsResponse parses an HTTP response from a ListSandboxPreviewsWithResponse call
func ParseListSandboxPreviewsResponse(rsp *http.Response) (*ListSandboxPreviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxPreviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxPreviewResponse parses an HTTP response from a CreateSandboxPreviewWithResponse call
func ParseCreateSandboxPreviewResponse(rsp *http.Response) (*CreateSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxPreviewResponse parses an HTTP response from a DeleteSandboxPreviewWithResponse call
func ParseDeleteSandboxPreviewResponse(rsp *http.Response) (*DeleteSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSandboxPreviewResponse parses an HTTP response from a GetSandboxPreviewWithResponse call
func ParseGetSandboxPreviewResponse(rsp *http.Response) (*GetSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSandboxPreviewResponse parses an HTTP response from a UpdateSandboxPreviewWithResponse call
func ParseUpdateSandboxPreviewResponse(rsp *http.Response) (*UpdateSandboxPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSandboxPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSandboxPreviewTokensResponse parses an HTTP response from a ListSandboxPreviewTokensWithResponse call
func ParseListSandboxPreviewTokensResponse(rsp *http.Response) (*ListSandboxPreviewTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxPreviewTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PreviewToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSandboxPreviewTokenResponse parses an HTTP response from a CreateSandboxPreviewTokenWithResponse call
func ParseCreateSandboxPreviewTokenResponse(rsp *http.Response) (*CreateSandboxPreviewTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxPreviewTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreviewToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxPreviewTokenResponse parses an HTTP response from a DeleteSandboxPreviewTokenWithResponse call
func ParseDeleteSandboxPreviewTokenResponse(rsp *http.Response) (*DeleteSandboxPreviewTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxPreviewTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Message Success message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceServiceAccountsResponse parses an HTTP response from a GetWorkspaceServiceAccountsWithResponse call
func ParseGetWorkspaceServiceAccountsResponse(rsp *http.Response) (*GetWorkspaceServiceAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceServiceAccountResponse parses an HTTP response from a CreateWorkspaceServiceAccountWithResponse call
func ParseCreateWorkspaceServiceAccountResponse(rsp *http.Response) (*CreateWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// ClientSecret Service account client secret (only returned on creation)
			ClientSecret *string `json:"client_secret,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceServiceAccountResponse parses an HTTP response from a DeleteWorkspaceServiceAccountWithResponse call
func ParseDeleteWorkspaceServiceAccountResponse(rsp *http.Response) (*DeleteWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWorkspaceServiceAccountResponse parses an HTTP response from a UpdateWorkspaceServiceAccountWithResponse call
func ParseUpdateWorkspaceServiceAccountResponse(rsp *http.Response) (*UpdateWorkspaceServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientId Service account client ID
			ClientId *string `json:"client_id,omitempty"`

			// CreatedAt Creation timestamp
			CreatedAt *string `json:"created_at,omitempty"`

			// Description Service account description
			Description *string `json:"description,omitempty"`

			// Name Service account name
			Name *string `json:"name,omitempty"`

			// UpdatedAt Last update timestamp
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListApiKeysForServiceAccountResponse parses an HTTP response from a ListApiKeysForServiceAccountWithResponse call
func ParseListApiKeysForServiceAccountResponse(rsp *http.Response) (*ListApiKeysForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApiKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyForServiceAccountResponse parses an HTTP response from a CreateApiKeyForServiceAccountWithResponse call
func ParseCreateApiKeyForServiceAccountResponse(rsp *http.Response) (*CreateApiKeyForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeyForServiceAccountResponse parses an HTTP response from a DeleteApiKeyForServiceAccountWithResponse call
func ParseDeleteApiKeyForServiceAccountResponse(rsp *http.Response) (*DeleteApiKeyForServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeyForServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTemplatesResponse parses an HTTP response from a ListTemplatesWithResponse call
func ParseListTemplatesResponse(rsp *http.Response) (*ListTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplateResponse parses an HTTP response from a GetTemplateWithResponse call
func ParseGetTemplateResponse(rsp *http.Response) (*GetTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspaceUsersResponse parses an HTTP response from a ListWorkspaceUsersWithResponse call
func ParseListWorkspaceUsersResponse(rsp *http.Response) (*ListWorkspaceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteWorkspaceUserResponse parses an HTTP response from a InviteWorkspaceUserWithResponse call
func ParseInviteWorkspaceUserResponse(rsp *http.Response) (*InviteWorkspaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteWorkspaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveWorkspaceUserResponse parses an HTTP response from a RemoveWorkspaceUserWithResponse call
func ParseRemoveWorkspaceUserResponse(rsp *http.Response) (*RemoveWorkspaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveWorkspaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateWorkspaceUserRoleResponse parses an HTTP response from a UpdateWorkspaceUserRoleWithResponse call
func ParseUpdateWorkspaceUserRoleResponse(rsp *http.Response) (*UpdateWorkspaceUserRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceUserRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspaceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVolumeTemplatesResponse parses an HTTP response from a ListVolumeTemplatesWithResponse call
func ParseListVolumeTemplatesResponse(rsp *http.Response) (*ListVolumeTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVolumeTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeTemplateResponse parses an HTTP response from a CreateVolumeTemplateWithResponse call
func ParseCreateVolumeTemplateResponse(rsp *http.Response) (*CreateVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeTemplateResponse parses an HTTP response from a DeleteVolumeTemplateWithResponse call
func ParseDeleteVolumeTemplateResponse(rsp *http.Response) (*DeleteVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVolumeTemplateResponse parses an HTTP response from a GetVolumeTemplateWithResponse call
func ParseGetVolumeTemplateResponse(rsp *http.Response) (*GetVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeTemplateResponse parses an HTTP response from a UpdateVolumeTemplateWithResponse call
func ParseUpdateVolumeTemplateResponse(rsp *http.Response) (*UpdateVolumeTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeTemplateVersionResponse parses an HTTP response from a DeleteVolumeTemplateVersionWithResponse call
func ParseDeleteVolumeTemplateVersionResponse(rsp *http.Response) (*DeleteVolumeTemplateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeTemplateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`

			// Template Volume template for creating pre-configured volumes
			Template *VolumeTemplate `json:"template,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVolumesResponse parses an HTTP response from a ListVolumesWithResponse call
func ParseListVolumesResponse(rsp *http.Response) (*ListVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVolumeResponse parses an HTTP response from a GetVolumeWithResponse call
func ParseGetVolumeResponse(rsp *http.Response) (*GetVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResponse parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResponse(rsp *http.Response) (*UpdateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckWorkspaceAvailabilityResponse parses an HTTP response from a CheckWorkspaceAvailabilityWithResponse call
func ParseCheckWorkspaceAvailabilityResponse(rsp *http.Response) (*CheckWorkspaceAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckWorkspaceAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkspaceResponse parses an HTTP response from a GetWorkspaceWithResponse call
func ParseGetWorkspaceResponse(rsp *http.Response) (*GetWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWorkspaceResponse parses an HTTP response from a UpdateWorkspaceWithResponse call
func ParseUpdateWorkspaceResponse(rsp *http.Response) (*UpdateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeclineWorkspaceInvitationResponse parses an HTTP response from a DeclineWorkspaceInvitationWithResponse call
func ParseDeclineWorkspaceInvitationResponse(rsp *http.Response) (*DeclineWorkspaceInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineWorkspaceInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAcceptWorkspaceInvitationResponse parses an HTTP response from a AcceptWorkspaceInvitationWithResponse call
func ParseAcceptWorkspaceInvitationResponse(rsp *http.Response) (*AcceptWorkspaceInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptWorkspaceInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingInvitationAccept
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveWorkspaceResponse parses an HTTP response from a LeaveWorkspaceWithResponse call
func ParseLeaveWorkspaceResponse(rsp *http.Response) (*LeaveWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9f3PbOLLgV0HprmqSK9lKZua9vXXV+8PjeDKetSc+28m8u81UCiIhCTFFcglQjtaV",
	"736FXyRINkBQlmRnxrVVO44INIDuRnej0d24H0XZMs9SknI2OrofsWhBllj+eTwnKRd/xIRFBc05zdLR",
	"kf55PMqLLCcFp0Q2JisD4X8WZDY6Gv2PSQ14oqFOTrKCnKqWX8ejJeE4xhz39bow7b6ORywnUV97OcNr",
	"0VB04JiXzLEMpL+OR3ydk9HRiPGCpvPR16/VL9n0M4m4gFSDPbof4SR5Nxsd/bN/vXoi9y2ENWbTntyb",
	"+l9jxJY4SZDVAImRSk5iNCuyJeILgvIiW+a8u47xqCB5xijPinUf2q7qlmL5BZ3PSdFL0hvT7uvXr3+M",
	"YSTnJKIzGmH5K4TZnP6DrMPRekOX5GdKkphJxPqavrtLSWG1bRIBVwO35p1TdEvWED7Jl5wWhH2iENnK",
	"Qq4RlSmnCZJN1Q8vaIoYibI0Zi8hqDR2TgLReIx4hgrCC0pWBFFe0/348gwCl+Il6QL8DS8JmmWF6ela",
	"Iiun3c7vGSkQKyXNEI1JyumMksLR/5P6sQ3kWveXX7ubrstA51k6P0joisRmwnIBOIoIYzSdo58S/IUk",
	"EFOdZOmMzjVFulNpfm6LsyhLOa2EYqen+TYeUU6WAWJP9xjVcgUXBZYbLcrKVFAWHMl8Ch5IdFhDw+QF",
	"XWFOzjO1DYHRLlULlJgmaIlTPCcxuqN8gaYS00hgCfOsCJ3SZXNcaGoFmcMzutIfAodSzbsjfIW5Q5PE",
	"Td8OV8SU5Qle/wburqob0s2Q3IXBu7PuH2UxCVNJlT6FwBUESa3cZW6c4mJ9RVaUwVtDfkeFbnD2BiU0",
	"vRUySAgOA7OzrCVhDM+BlckZIvMZ1FGuqVwNnINL26spuLT9eMTp0jlx+Q3qA4o43QcWcD4SMh8NB0gA",
	"wxHARqvMEXiktp7uiMRaYAKTfSf/wAlqNqwUjl5yG+wt6TVMxJSb4hrEJEnxNCGAIj2VH1BWiJ0p/xTz",
	"KQjLyiKyyDTNsoRgKUBmCV5l/cbPz7qZ0OApJ3M1vZMsTUlUockH4AzsdU6ZXFGeJTTSePLKWN3O9LP3",
	"k19gqnYt5I5HhTBg1I7w9tfNxMbDaTzNvgAqX31Ay4ZQq1ANbwmlxQbq7B7pLGFuLJtV7wGSuSCYk1+z",
	"6ekXEpUCzBX5V0kYh2Sc/CBkWyR7IYw+Z1NETM/uYct8OYO43XxEZ2/Qi0zvyjG6o0mCpgTNSSo0OIkR",
	"naE04+LssKIxiYMN0/cp/VdJjEBHZ2+gjp+zKTS7X7OpowPH7BY6pwnhhbIZEt9Rjgu8JJwUSq6IfyYJ",
	"SRq4quRkhyhteXiXFbcsxxGBZvq7+QjOF6R5yXi2fJMtMXQ4UF9RLD+r2Yt9Su5QTPIkWy/F1vqY3iwI",
	"ihpNC5IXhImvCKMpZsR8eEEO54djRL7gZZ6QwyhbvkR8gXlF6pKR+GPKM8RIsSLQeIfoFEeL6ovpqO1r",
	"ISoxR1jY/WrMo4/px/LVqx8i3eOAxvLf5FD/cKg+i2keqC7qu5ksnkavv/+ham3PvcPmof4BG+9DfQV2",
	"X3VS76PshTWrPR9XvRLujSXZKqXb4CRo1yV4ShIW6oE5V62dclJhSE1BE/zjyKLxxxEoZKp96NuFsMQG",
	"zozNjVYxUQ9ZHXZRA1aPgSRmeEWirIghW+6344tTxHExJ7wij48ujH8ghThjx8eA0jjHjKOVbKCmgzDn",
	"ZJkrc5VxvMxhS3vusLPF70p6dPgGUYYwY1lEpdoQp8EhtvdJWRS19S1F+aKWYTlJY5rOx3oxJB6jGaaJ",
	"Qx3xL9zCMI5jqtTbZYMSnW7NCV3gXMzi5r9vUCGBSd5iQgGvcFISpVv0BG0cQzxkfz8tiqwANLL4uVKX",
	"dNakm1ptmIY5rTxK0uRbQ9q/8jlJ61H5S7R1hhI6I9E6Sog+2i+h4yGOYI/JsfxdHsHwLUF3C1KNQRnS",
	"/kJoJa6j0s06J4IQpD1nCISkjMflJr8bofPd68V3Y/Td9z/K//wt/u5lGH6VPQ8sXR7oxFwXuIjvcEEQ",
	"XmGayMOEZJZapXbwCYtKNZQlKhH/8WU47nR3OS3VPcrLMZrn5aClMpgqLHipQYdSjVbAAvu5TB3cVn15",
	"yjcNZpJ9lw2m3aD7hgbwnV85VFOM7buHFSnWiC7zrOA4rfUWln79menCMyRUuPIT4hSdn1+AnLyNK4Ua",
	"lX23CmdL7Y3azKqU3YcyhOzktiObMDtTU8c/UN+LY0Esz4ZpLFW8kr+CGFQARXeY6eNjfAgh32s7Sui2",
	"/aiVtAL9QlgNjBfrSWWoTeprpZeHLvvljZQUD1iPAKLlDYnRi2XGuNDYgvdwVGSMIZwkiOM5gyeROhcL",
	"LtKsSH6FIRqn0Q2s0Cy3UqUxqiFAgGUeP4jkEkUayOFA21oMUH3um6qTnY14arIyo/92jCi+NFFPUzRd",
	"c8KsUaU3jSiVgeeARD2njCuvwJy1FBRfUFYvI0hByYXc4HnY3UHVeksbmON57/YNY2WO52Dv7VFjM341",
	"K+zhVhDZtYe0O6T9sWPGVoeDs3SWPeS8YI2CahCISrCgIzrOMxpgpFiAT6s+X8ejBcFxgJ60uv+iezg5",
	"xV6Dy/eZFXOc0n+7HPw2iGbT0F1WA3hn9QdvK3GBBwH8PyUp1peqlx31AN6r2itptBy+kFbQRL/sgBz+",
	"/hla7Tb1kA02Y6BZeswaZ3PvwqKqbdDV0wN28HG9axu3U5VBSxuCpLNAGiiEHPd+m1+PjEeMRAXhW5Je",
	"GlhnhcFEVVdMR/f1PmkHLpnDoY1Sm9Iu4dOWAIBs9KPeSN0O90yzeB3WFcmm0C3IPM0KcpHF2lcaAEp1",
	"kXRNbMECLHVJ+CKLA+HqxtD9+5DphcyL8YLgJRggBcJU7Z1RRfLrTXZL0g30ouonJvkwAD2c3mwdtmw1",
	"ozbXiXMKXZF4CBBUdYLwR0J3gAbGHDESPOM4GQRJ9Rhqrp3aZpBLeA2kol+81YaXf2a/1PbVFoSqsdb8",
	"YzYsnmDbqmvVrjDHxaeySKAALnmRWzQgINUDvb86H+wWgAH2XaFDV8YwJPgiOB0wF8elkJ8Utq24HRb4",
	"l4CItNHqH/yqEY8bYJeuOzwAIbgG68AqZT8BLPP7gvAFKXRATAVigZmOrNTOPwbaJjClrpqOlL6ThhdA",
	"dpfCMabgBrA6guwO8cWv2RSMUnjSfudfs2mfy/nXbDrI22yHqsDQ3PEoocu0x9hgyVVfe+1sUEfZoYG1",
	"IV1L5glUMR6pCk1INQw8U9pj3WB2G3acBDHqp559I946ZiUl4wS4/jpRHxySRSwmIQ6n0In6KNHhu5j2",
	"eM5kKFUvgJg45/CGhMxABfaDAKxLVS8I2hOO5YiTggnmkp2M48Kx0GvxyT9Fj//uvHbO+WEEhWuEBk11",
	"9nUP9/o9BSYgjLIlkP9QLqfCgJjVcWNmi0Ju58fZ5SoWOSs5jAj9EdX5JOhFhHNeFiRGmFvziuxt8xJY",
	"Yy81jHT1koNjThmnEYPCzCOSgBG5NSWqRh5SzDBNyoL4wKggCg8MlT3jnYpu4gNSpqlgZB8Q1cQDhJUy",
	"uM4HRDeZlV4GhY9xN+JnlFawXABCqF8GkR+OqO9weg8kMU/I8adscyhOAbNbZDXYcAeeGAgj2DMz2LAR",
	"QB9i3Ij+XeNuUG9tqvSRuLn8APrU6HaHJF8RzCBotR4sVIshGSTVLP1ZJPDIdWf3yIysSEH52te7auOI",
	"ffPOWzUIDu+pO4ZnkjiZMISybqPwSVh3jutPMXOnnRQtSFwmDkvJfPQP+9i2VgiZQ4wmSWK/5bTEX66I",
	"Iw/xAn+hy3JpaZWCmLxEQDG57BdJLmPAxGX7umXQooO0k1q2T0VtLbaqJ7D2bkEKlXb0WZzLF1mZxGhK",
	"zJW/DuEr2cEdZgevx4iUB0mWHrx+ubM4Kukf6AuhMlmbV4TlWcqALWhamBgMmlCuYk6r5CVnbq0vB1KH",
	"JJhcVPjc6UwTUtk6ATBmrijIX0zwo25hxZjQtA32gUGQFSQ4YztgGT3cFwDB5Ua6bgRtuyFAm/bi5PIN",
	"mdG0si82SpdoHyo4mTuu9U+qb2a+uOB0hmXWoeeeK8qWNJ1/YhnomW9CQpQh1R7J9pBbNLS0AzDLYf75",
	"N0DIng8YSTkp8oJCGxlYp9UcWiYRm8xxMXtafXPPq2aUWVYAx/Wfs2IZ0ntB45iEUU43hVajPl3LC3JI",
	"HsjP+gLdx1/9N9s0AvksCmMIugQtZBmTFtQ/NJQhAFaSpfM3PmY/z9J5o3JJAFBP7YqA3rzAKcuzAjI/",
	"zCdZPwVzaikrAfbi5HKMIpwKvfxxdEemLItuCf84QlmBPo4WnOcH6hL74yj4SuL91Xn/tAH1XAtO0R2n",
	"YnZ12Q/xj1/KKbQbnmp6mgye6L073G46mhrTNVaeYIBlLxMlD1zU3H3+2oUnY6218s1vLzUAaAiBNGgr",
	"z2mEE53GXyelCk2IVTjJk74yk8vquzRTDDPk2qwGu9EpAqC+mkKfZW7vxG4pBvERzeRXKd4uScEo4ziV",
	"5Q7AmOWf1nBEb8nknbtMIaaRTA0W5jW6W2TV6QUup9A5CG8yhO7aMwREmUuVWHiWrijHD7JAN5eIZIlp",
	"4qilpL6BGnpFHdgyRZjAM0CWAPLn+OQcyS87F1sa34hWCBcnpXqMEBIdRxHJAdUNwMaq6XgbGG8gwkft",
	"Ci0OlrPrcLiDJFXuZnAkpCvV86qUlUywsGdSXmQJQ4vsDmErQ0/YvEscq5B8WQTAuBrMSU5sKl5QFdz5",
	"cm8BxmpN7ohi9f3ceTDWKLTOoyE5l61ePRTo6x3umW2uxskRVQOZcC0HSlQakarqUOBc/M4SqtJ1zgd6",
	"IFpIdbLaBf4i4x+dE60aBE60DbZNrXmB0zLBsAP+rfURlJZ5CcZFip8h92RWcrDHO/U7eO8nECYhvluR",
	"4p0DwBXUCrwB5CSHPC0kH3zRF3ixpwhw5U1e67ZR1DV5bEb7jpEUINLiG1c5oGNEeATmHnXhspDBh/FW",
	"Y2mDtkOjp3NLwE52LRH8jvXhpaQSW1CEb2hlPtt7t79vvSdbyY0bYI89LNHBK3TFx+pwXkngrNDu2VAx",
	"DLkFjpH0CciykraJGaJQ2vl30vEAHTWLjGdRlsAQzNc+KKp4CAxDFxaRSwHB9MiHAnJ6XRMJTAaAdhEU",
	"uMkKsPTSpSoABMX5qlJE2QxhdOUiR6hdoqENNk9UN4990oL7TTpbXIHWigCuXoYDfnME/+r0577usBK6",
	"srOn93BmaZHRTWmHAghi1mhAXbBpVqaxKnNJmanL5alDDEsDq6KKvGI2Lk5T54um6Oz6Hfrf//nqtfi2",
	"xBwdoO9fff/jwevvD354ffP9D0f/8fej//j7/wOFGShGL23J0562Zc3kBZnRL+/h/AXxyZWpkJfThEb+",
	"EPZqfQzp5pCmCb6rtcCZKgRjnV7OUEFwnKXJGmZyWdLv4XkmN4uMEZNhUpVnY0QGAOIkQXokWbxonZVV",
	"UblDdKPnSaR5gpNkjUpGZExZJiHIKtAlX2SFyaZQ4xxC26DQN8B7WZIaSt6ybLCmk3dX1wY+uBbOIUVM",
	"l0RASeiqu1+qWmavFx9H4r/f/6j/+Fv8cfTyEB3PONGVB0xgw7gBoaqsV/JsiTmN5OR10PLhJtcJTtng",
	"0VeOtDb5s1bwlxXYB2lcCXJDtSv79ure5ggu0dxsFWjVSXQ4rw0U4N/+YsqzhxCwfhS/NvkK3YDZkjr4",
	"3i/dVTKi2P66NXgrrfRiQBh/VTRDzwhIlHTvllAMNYuf99Zcb5UyccbQwIx77ndsgTOUavIs79YyGRrF",
	"oLTqxBdkQvPVjyc0Ljxx9UptI9ES4TguCGPNugz91+v56j+DB/nPjQbxIXLjbNeKEhD0K6/J0s0STZLs",
	"jsROE6fvZOAJ0QqG4AjOCuxP01n2VlUq9tlqvffJzp0XCMCV4jgfts18WZ9X7kxP7pDzVZqjS9JvLT0S",
	"LhHurNPfLK8BlpZcEbi05IpULw4gCmbAq3cLet8r8Pa+JEUEhx62gOS6IezApdHt+pow0fIGsiavZQvE",
	"VBN0c3PeyNh5hf7L1KKPX8JO3wLPZtBx50Z9MPNrxMJ7fTyGRG6TqSKiMxjcRb8zplWABqDbQfrZRcQ2",
	"CN0OBOGOJq/5UF9NY+6JR/9pHQBhug5N9au6wpl+0nDMSnYciETT3ofNsLDN6j0AOGBK8JNzX+gPEpRm",
	"Pf0IRxeqn//qNwVALyPwbIR9ldnlxWLu8H7gYl7K+qRipjlmzMzYuhg1Lxz0BYYucRrDo+iP8mmmMm3B",
	"74PrFaYKOlSmqDFAB8NRXsLATi7fAyCERIqygrAxytJk3TY9tWVqkoIhIWXqbcCnGVOzA9mxe/La6BCd",
	"iQ3OVEXd2Sc91icDb4yovLqWT70YKELZdjpKm6nTL824rH1/CAfBrlxes3SFVrigAgfMeBRom7SH6LoK",
	"38co0SblP8opKVLCCUOn6eoDVqV5ewrsbOTDaxJwczfe3GNdifHr71XJboD7egNTBag3WXRLCl1f0MfL",
	"VioY/nKSpZEqHX4D5+IK0MtOakpUdVP5H1KQpI3qBV1O9mW/wMPoDBjvcpoDXEc4cSBoSdMO+DyhEYbg",
	"H6ITdQ/2CmUFei3flrtb0GihdkabRxjCyR1esyo1laYIc5QQLDg3rc+eL+GKj0uyBM1WOW/5zcGaFz85",
	"4PGCRvBd3I2+tkLVmxVSZsgeDLloR1MfagHKuVELDwBHRMrymUk5b9wAZgWd01SJOYHmX8r5nKbzn3EE",
	"13/1V0K5kRCteje2FHX55oPu5FiV3lbml0U2dVazxTFNCWMoF42ass+SeRJE6zRiOVydGWELUiWEwUyk",
	"TWaXjeyM9RaAq3jvLuix1A9oukYXJ5fsaKN4b9iNvCDS2veuBh2gH14tx+j7Hxdj9LchFfMXdV1hzWnA",
	"QC9AldpVl4GV4q9dV/oXNCoy9OFCzsFIF1kaXBiJOu/84RHBCWb8PfPkUUpnnsCBeebgDjNF3xeCfw+E",
	"dTOuHjOcrlXbNeNk+RJOQ95N0JtGZF8QsomU8LxWB3LezXmdSqq0nrlrUPcM8h3S+j2olCZoSXAqzCXZ",
	"9MC0Ci0WoSfazPGC1xLX6QxyZvFS7AaeFUQ/KKlT+B+S7CXHaMXDbZjtZU13B/le9kQfnvBVz3XDlK/m",
	"YnuSvnqSrZqwPOlW/UlQ/nWFpEF1mW+rSUxeMrqspgtlMTln6DGcHpYYNcwygIuu3+A5CyNP3+Wlr7dH",
	"1Jyb92sg37552qZ7dDZ6wfPoDWm+rAOKnLr2T/O9mgGVozsP+ATdLdiKYxvJ6omNxgCNVaN9SPSEwbon",
	"2z2Pv/Rmu6+ypFz2X598kM2OOcfRQj1OAwX8VLq1L7+m++ao/zXKOi4Ey1eq1XNEQsPhuXJbyEgGnT21",
	"zkoZzFi96S3wpbrIN1QUC//zlqz/6HBqXRC6nenRZPx2rWdL+DreUmosSE0nbHfekGWegAVQdBFJbhp0",
	"3uwkM1wm/KcCp9ECUp7yM5rK79WFbQ3NH2sSoIu9sLK7NMlwLOsJ+Oo1mYZsEiVZSiy/q3WzA9S1yopb",
	"1gtctgIKdIIgYbUqBK92gZr1fseQbAup1ihL3+DidggcobZiXNy2wnuHZPX6KMEWwHXF9S/Hpq/x2rlq",
	"uPQiWTQKRjLPchpB6lH8Diwn/O66T236cFR5LrsQPlROTc/kvFGrur0BFKa2Or36xINNx4cFI/gYYmgG",
	"vA9WP1v7eueYA0LvEvNFEGM7FIEdMmP6C8XkVAgg7eo4ZThUblh26cD3YqpHlKxncbb3elIDugYRqOhU",
	"RR3oVlZ+6Ln+7tz7BFTv6bzNPfCZc10sCL3QqvYI8aK060HahzLHVReNK8GhEbCRx0p3rvI4FpznYrrS",
	"04bZOo0GUaHHPAsjCS75Qjqs5Gf3s17Ndo3HvTw4iXCSTHF0e+3YqvKmT7fR+1P5RwQyDGCGXkj3TPVw",
	"9xiRNCrWOXc8kmoggkHWjSGFaoHGM16il+FSS7ruLcnlwYqwetcuf7NVuKkDwg7B0AXcHG55/bUFaYyi",
	"IkvF+a3QgRn/y/xvwIvkKt2G3bLWSVOPJYb4LOuHh6lWgJkHV4a1/eiWmxki7RJ/QX9/9YqN0cU/fpAX",
	"v6HuPudMN8eQawzm3M7yXrZkRB2npLN5IKYhxKrDI2A4yd9rhSEvxpW2Uy8ay+Pdk657oZZg+5xJYBfZ",
	"1OOn1sjRzzoLOKU43MsiNRoD0KYixZKmTq1dObArba3O/1JXL3FxK0bICmTABHuQ2v4B53pw1cTtSepG",
	"x4sDxiUoGC9kLQspGnUsQZSlHFPHwwYBFqWaJ8/0VB21UON3abLusQ4VJMqQnD+JEVZ5LQfNxBavpdh1",
	"vNiVD4a4bNw7E44uNwxo+3LQAaLLZcml/eNX/TSdFZjxoox4WZAzl+2TclLo5/6s5rVMoLGwC2aUFPXr",
	"kwqxG1Tqq71nmjYPdJ7BDz9eW48+Gh5wup21kDtJMAMDzeRXFInP1WWke/3c6SrS1KzOgtIRVgXDqVV/",
	"HC3XpsHRa3NTa/0m/o/xj6OXQ4TCNfdNSIpMdIAMU+nIsaqib8uelNxM4pvMl59R84j0GOo+YkubdWpB",
	"c7RcH+g/Vb6RvPkXv8o/Bi70Jhj5gpCqgHw6R3lBDsxWIjEyDtl91Qppzn0DTVZ1NRptJVQ4WIjDuPhN",
	"i3pLD3WZNIf+oOCF+U2ABfcSzF+DQJ/9rkFpYJysbIhUGOyQac53E671b9MaE+C+TDDjmgjv8yTDcZ/9",
	"kc3Ua7WaE1Ape8E164TMMRQG8ntlMNpENUPXP1Qg4TDhsJDeFj7RC60exlJ/r8eIFEVWwBcqaniHT7T9",
	"foB3J4QcG+CN0EtGgyRe4OhWha3FdEXjEif1nAQyTAdhVUE3e9MyuoXO3tc/IPVJ3aYbzSsksx6aMhWi",
	"ELtSZEjq2FK2gm1PsHpgecNL3jaGhlgZx79f6zytwesNZEsN6sXJ1enxzembMbo6PX7zf8fo5+Oz89M3",
	"L30mgeNperNcSaXGfKckydK5OBF62Byy6xp7sMvYPsxuOYXydxvcnitI6DJ7EILqpZhafHBOjTdYpQay",
	"yYuBxyXPKo8XKlP6r9J+rZ7G/vKhrqkkzrqXac8i3Dm58F6re94VlJv8SBBCnRkRVHzOZFJ4dmU9uD6e",
	"1/pBU/TTlKax/e/awhvXeG782qtZ1FiuF0DU78q01AHaZnIy/4Bp56eErz+9DCrj8buvyGAHbR5k1Vkh",
	"rQJlnlj5urfVatjmf8+gO4UacMmkr6CzfUnO+3KmZW3NBWbINJe/WvuoLo8JZlPD5RSbU3MXVpQfPq1I",
	"Ic7HATP9jilYcsZTQlJU9YVmN8NLmqw/9e1cOUfV1rmL53RF0jBIsqlbHIBlOFsgXBU5WTnt7Vv7G0K4",
	"TN0TlgXl62shRxTv/ERwQYrjUvmrpvJfP8sEktHR6Nffb0bKwb6U+JZf67EWnOdiF6ocXXmtTblYs7nN",
	"PVHVKNFlglOxSqNNj0avDl8dvpZR7zlJcU5HR6MfDl8d/jBSlwpyahPp09W7TpptVYCo0FTyhHY8197F",
	"qlSIaPf9q1fmeQnt38O5jPQXfSeftUxS0jTYRyWHAo5tnbIm1ptd1YQb6JeK3Ub8P0dqqUcJZXz0hxBr",
	"rFwuZXakOojiJEHYrFWF5JlOoz9kTB8DMCRf1CHH2jWuC8T8pB9BD8ZOAFK+6ko3qnIDL0ry9YEkCRx0",
	"a5hXSrGNe4VAhXk0rWVGmwBfx4ZbJ/fyv8IO+qo2cELUWbVJGvkSpUWabwhVekktVKkF9aNqDG/mt4Qb",
	"ZMjHkwmXdz//7Bjsi+zO3I/KuDSGXqgYcnOBRUUz+QzzyJhyI7bI7j7pFxuMRMNWHE7t1v7jGyOGQGaL",
	"Em8JDyGDF82NWGJztSY+yCvfCq8Vr4/a+x9AcqWa/hiPdNnUJg+8lwEYz+IqgOwqVqVNeYXATcXVxLjY",
	"A1TuVdX0kRlp93q/Uy3hsU0AVFjIB2nbiS5yidyT1rXYzvZAK3api7ETMDxA24+5tB978NesGuDHY7Ot",
	"hcbWB41OWZdRlWX0740Tq77jfqxSe8RdcWZj/T2ItUtYNhDbwGGfydpY1W5UQRNx+9UI3bG3TSSvOdsg",
	"kodGHd6f3Ks/Aq3bFhWD9UR7foC+qOexV4XxuET1Gt6hRHXb38/k2i65HKZ5OKE8RvITpdWzmB7GIl4z",
	"fjtieiL9ppIgsMb9IL8/b/59UFbhehBlzbMafsPz56rVPoxOM9quDM5qzX5jc2Yt2qCw/q3PxqwWsRvB",
	"VeNov0KrOe42aeG1KWc1NiFSNDh5cm/+DDQkG6T65vDmNdtMM8Bd02Rll9Vm4eZP6zjdHW0cNlowVYL1",
	"pLU/ABVp74ctulKfRdxAdvDaY4FM4RN1oIu1HRvByyJltZNP179sj344GnvsgI38s7vj0T+Pl1YGW3vs",
	"kopMkJO2zSaydA1r6r92/Gwiq6oJc6dMZSUr1clkkFTxG4foXZqsUUGW2Up8Vq3kS2m4ILIQpo61SdZo",
	"Smg6rwqf4XStL5frV9zY2GS4yKqgBfqcTVmX506E9C/zM7WQBxK6HaksX8Tw5errRZqWcI1BxsD6QFeE",
	"lQlH5ntIAMVWGEjN2WEUaHQ2SW0xkP7Bsgdg4VFXIxWM4+AYNC+yMlcsYNU6kNkWYkBYwmyH1EF7Wg61",
	"q42s6eDcyG7c1zt3cm8/w/F1ci9/Boxax6ZOdSFUp0hXLRUedqhQNaJDETse/agGbzZWaxGMq5r86Goi",
	"ZNEsK9P4QXtFG9ANDG6yVXqJ8Jbwp0aBILQ5bNsAhHkthsbbMsZ0oBpBgN1QNB/kDLcbxj5bxTNgtQmH",
	"WSlB23oisDW553gevsurjBwhVVVSrGE6746/wfOnv+nFkqjULSUjPfs+KyQGdrD9uUTVMyf3jyYIwDNt",
	"MsGjaubeYPfUFXPYJMrSlHQ8lyHmitUT2SC7Ji9soNRdTqw57MVggYbemQFjocZjxtgIjBr4qLaL1aTh",
	"NW1FaOhYSAuKqahuQQCOCLIfjJrd+CUcZNivk8IziS3T3uuXtUtcOUnu27yT+/ofgyxbq3yWxTHTdeOL",
	"TOXCaWw38ZrCTjZ6umTsqKwQkgRYrVtGsDBzv2XsSts2DLXBHjGrZ2QjBNCazV2yoRO3Ve5Ph3Nun9YK",
	"8rNMfgC7aeLAlNmSqJ2Y+vwnzbDEYfZU9W4O+K6SeoYnWBrI98RP4WkNCRvY6W6CGGgPBldLAtnbUL0C",
	"4qDEtrhF+aYHcofqBFhy1vQHGNoXag5/dVZo294dXtgy0Sf38r9n8dcA8itm9FJcqJazNwPFwhOh+rhb",
	"d0usV9bYAEbSiPtGZcy2BMu99a/KzPfykT0LmqpHx7z3k03eGW1mhjkcJc3JP5k4M3u9T/zYLzjiczYd",
	"qj5El0DHzK8C+j7cML9m0105XcRy3Vj/rFZoMCz/2edQEQj9nE1dfpNfZXXMXVjkEkv7tb+rIbdECK/n",
	"Q9cVbdLCcPnk/nM21dqy34H/OZv23dEZOn0jmPP61EHM9d44e5H0lnCFoT9tjJqygLZJI8f9nYM6wcpU",
	"VyTuKlG5I7bquPDzhGr1LOA8LADHo2kBlxW6ZH2YqJtU754OdiBUHbXPwEtWrepP69EehznHnrghYUWg",
	"nBQot+7eWmIloUvKG/JE104cHX3/Sj7jSpflcnT0+tUr+fKo/hdUCq/7roN8mmzGCHcMXn0ERreHewUM",
	"98eebKyKwpsbW45L5SmOkZYIos1/gNEmphqvfB1W14p6sPlm8fomhlxK7moIIZulMvJOrUeJH0mU7yR9",
	"q7O+K0PXvUtmi1+fNH/2WbXNB6yDhf7kvvq7x/C95lneeCg7hJMrM/ixObkjbc+qN0tsxAFjWfh5Mh6E",
	"XfItGKpTE92K09k6j/edP3w83n81Oohx1dHkmWufuXYjy0EfyQYJ5c2zQEIs741yP7ZtSvxZ8j36LUYo",
	"0cMifJJFG93aVv0QXmGayAcHZGi+KocKU/+8GmwfNDCjXemRdkWDChVuQiTWwg0R6t8UJZZRPlmosprO",
	"POqLk8tfymn9jvl+EHlxcmk9nb6rzKUoX5TTCoUKJQ+4MQ5z+lf3wXvAovLAPU7eV+dSV/8Qcmp0hGCo",
	"BuZmdRenM8tnub+T2FYdpZos3iPTUmOwQ5l6B+jr8wEx/eretec0VNPuG8Kl1zR34nIcFnTgs8K/SWw5",
	"nPQePAWbZAaGK2Zh63GGfTRS7Z4FUgBbBDruB4qmBxwcekhbqeqNDg+74NS/Tsq4Ig10jGiwQ54lNKpe",
	"IQi21ky3QHvt0oyyDwrIwda7wrtZuRvzeb1Yg/LqpxDDTTZeuyw3vbrdSEqDuv2KSnvULRLIa77lBo0A",
	"iex9MblXLQcYcapDnxVn0fHbQqvXkvOhtdeY60PcW8K/Waw5LDo/voJVZQUG0JU1/27RrPPJKdXiWU6F",
	"soa3PFCvnCqnCY3O8sEKXPZDNGeqYAtNkXpe5dChwatxetjyZ5pwUqjqH/Mqf0i9wFToqSxvfzBfhYnk",
	"CsGqXrR6nOuGesnbqsUeL2kKmwwVNWxKm/GNqSHorcvn9Locr1W7R3A76pF373rUqOi4H6sKQwO3xLXp",
	"F2jUVu33idYdI9Nn19rrrSvby1fZg+xa3d9l2F7XT5/75MvZDEnVpYUJIl8ok68I6xUgmjJOsLzn/PHV",
	"3/Vrb/K1d9NCdmEyp5EyebVHU/2A5OTm9Ori7LfjG+vPs9/eVo++QmJK2Zlns98yfiogw/FVM5wwMnZE",
	"j25fQ1bssl8V2Rh2m1zpNeZr1unw5Xj05QAv8b+z9ADndI45ucPrAzv14+h+BCyopxczUkY9Ym3uo2vZ",
	"M7nXfw44OOhl9J0c6tV+e2T0Hh48ZOw/PPQi7y3hgSLmWw4Y3xnlHAcYP82CDzA1GOAEY+2k7Xqme3lG",
	"tbQ33LOk7mMU73HGxy4e+TnJC7Ki5G6ISWeIe6m7DrPqTK/9eCzVYLu37YBNHGbaPfo+9hcP0uzhtywv",
	"q0Y7cUkYGu7ZJ2EPu2+DC9Uo3Ww7T+71XxtYSXrsQGvJJv63RooQo8lLimDjqRentRH1LSPUb8v0oPJx",
	"ZaG3DF89ccgPXO+0LTuCg7mnYU49i+NtW1VbFscTnt0ST1DAW8IZUm10OEBrHiEG1o0a4y+5rfZmWEok",
	"P4p1KcSqxSKBErbHkSgBhrIcZAIqfPxFeW5nslZz2aMIXGvs3UtdbQTXbLhT+Tu5l/8dYCF79scwa/mv",
	"uk+8IxqkQDWODaH2qgmaD1w4n6a4Vjth/29TBB5kNthOpFjRiHzCUZSVKR9636e7I9M9wEH0lvDfzddr",
	"1f3YDL4tfd4kZ5RQkvJPFHix5Lo5f6SaqopkLdKO9SVV/Am7NCvNUsTpkjCOlzkEodGnby72VwCW2i99",
	"QMxTAu3eSirDaznHjJs4WM9yury+G+Oo4iWndVQ/nNLmR4vvO5weYia14AWwt+rr4PAHHNTaT/A8DUZq",
	"2Cn/VKD+AGXgds2ZHW1wBUddQAXD0rdcdngOiVGWInOv+fJZmGwgTLYuPLyGqFOE+CUIpEIn94oxgouY",
	"tUZ02ZVumeK1LU8sjofKeeq5PqK59ayf/1xbShujG26pXldp73ZRTZ/advmTqf1vVcU/y4gnISO01303",
	"aneCc/rplqyHnmaPL8+Q6Kb9Pr2C5pwyfpzTf5A1+zkrAFN/175pNfiuDl5YQncHszbQNVTGP4IM7jns",
	"pWZBoeRXPRUNYPpvQ+aTLzktCPtEAXFzKr4pmZWTgmaxnLo4oeqlhAsd6Z7r7b0PwR/C8Ftl8LuCOs8F",
	"NkvsRERN7tUsQk8Lg7lU9fRx6S7K5ftQq+3DjVH7CNKj480+zqmcPI3hUQxRh7/Vx8kyT4REGqi8qn6w",
	"nrqpwO5DMZnRdqWaqsW6tRO3FmyYqf5NbdDq35N782fYEwu4Au+N86nQMOD+h9d9oOsRa5pPpqhcTe1t",
	"U9d1HV4POB5NSiaxOmi3yD6B4azVSfK9HGgf+6cx5B4c685dVOGpamxtpxqAx5l+lq6oOrgLWIhnrbfO",
	"p2tElpgCZZZUzyYqtmZViSHFH+p5lNGR/mWjE9Kp6Gr2r1kllbMf7fUin6QxTecSb3grFR5pusIJjRWF",
	"kMaVq9RjTdPgh4QtFtT4ajGh4oEKqb1cWMmDyT0rp+8KSRqvZXVFltmq5k/5CnSTQ19kBSrIKrs172ca",
	"9CJqkXyBVR4cjiKScxLr93GqtmvCX3Z5XI3e5nF/ak05RVmhSWIxnSNioMLC9t9RErNFNT/J6w+xnFjM",
	"z1q6Qp778flq+bIAjwC6CQOpsdsMpBBs0fbOHkzNzJqrR7r5vJKCBkWWSCWuGalft7T8lAKbV1lCng79",
	"tyFoBVa6eLtZEFmSXeKMZwgzRuepUQ56Nf67Rgn4j0c+j7b0dFfayi0iV6m9dY394pS7Z1ruyp55ka1o",
	"vPP943XUldU6QmwBIYVXWVIuyadNjzOqe9+p5oNstd+zTXPMXRlnq+bK3BZaG1EWTVowgiIeWuBcXq8W",
	"EoYlnDOVbiS2PInR+6tz6QMo8yTDwn5pHIOQIR6cMao6+XNFO4f3D6RgVVkN4/OqBlzpr1Mi5qIvDBzD",
	"67ajR4gYbbPhfgUfNHoA049HC4JjfVz77wNVLuXgvSTiwfsi6XLmpY9PWjyCXtCZ/vxfAgEvvXT5OnAH",
	"erO5WtvGuwkh6Ti5b7YbEKraGrovPLWzc58ajwwkizcgcghZejO8ghH9lvA/G5Ydjphh+A32gXXBApZt",
	"d8NsJSfLqMKqFmiQVlRm0rNWfNaKT1AryshEWb5nZ8qxzBkpeG9Z3Z2oyYnmN/FV/TVAe7KcRHRGo4rB",
	"5Qm+d79DuvRDxfa7yUXo3ORWaBzKlgE+TSMNFAYDj60nOBUnz1hnIyyIrPZiUOs8v1aSJ/TU+hAbANXS",
	"6ZvRVd5kGsO4PNOId0yh3hrDLyXV/Dc7w4des3zQY+zvDL/bs3vvmb17VB9yRPefzEe7VK+Po1a3TZ2A",
	"8xxIIGs/GHU0/LQWdEgbfXM4DRDEDqYPO3v1H7m+PZx5j1YuETFMO/mU0gMOTu4j0LP46SW7193eZHen",
	"GLKc7sM0c92xJ+Rhz+EOjxnqcGeveVCIQ62awxMDd7RDLEw+0k3YDkjm1dR3WdF7F1X/MNFv9tFEjnrv",
	"ouiCRLeIzmySImq9+AfQV3SpsHBsD7Otu1QTuftEkjA7LqUBdK+pKDFdIxk3ERdC0vvq7wF2WCMAyWeK",
	"2Ts2WO3aN6SA5m1M+MmE8e1yC3sNw4DYsh7dFkBNu+7AMyl3mIS/YQhNEBFbITN9dEz3RsdnTb7FZLDN",
	"5P4kJlFCU+LW6m9Ug3YUH8/8lpvuVuHlzI4W+3PLkaCI0vprMxhQ0yMepCYUCTt6Qv7cItpD+eVzpnKq",
	"YGY5lnGcQ3lF9XpmFZqlChVDGMaEzoYFullU2STcTQ3W5jQ16S0zWkLwivjM0nPRoOf8KNs8WzAtPmjw",
	"T0JmPIB3NuEWRcK220D8GMAd4U8akWIF01PdCaOTLOVFlqDLBKdivLJIRkejBec5O5pMcE4Pp+oFKkwn",
	"q1ej7sWRhnOWzkhB0qgLoyjTGsbo6x9f/38AAAD///Ym0Cd+cgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
