package deploy

import (
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/blaxel-ai/toolkit/cli/core"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	blaxel "github.com/stainless-sdks/blaxel-go"
)

// Resource deployment statuses
type DeployStatus int

const (
	StatusPending DeployStatus = iota
	StatusCompressing
	StatusUploading
	StatusBuilding
	StatusDeploying
	StatusComplete
	StatusFailed
)

// Resource represents a deployable resource
type Resource struct {
	Kind           string
	Name           string
	Status         DeployStatus
	StatusText     string
	BuildLogs      []string
	AutoGenerated  bool
	Error          error
	CallbackSecret string // Secret for async callback URL
	mu             sync.RWMutex
}

// InteractiveModel represents the interactive deployment UI
type InteractiveModel struct {
	resources             []*Resource
	viewport              viewport.Model
	spinner               spinner.Model
	selectedIdx           int
	showLogs              bool
	complete              bool
	waitingForQuitConfirm bool
	width                 int
	height                int
	mu                    sync.RWMutex
	program               *tea.Program
}

// Messages for updating the model
type (
	resourceUpdateMsg struct {
		idx        int
		status     DeployStatus
		statusText string
		err        error
	}
	buildLogMsg struct {
		idx int
		log string
	}
	deployCompleteMsg struct{}
)

// Styles
var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("214"))

	selectedStyle = lipgloss.NewStyle().
			Background(lipgloss.Color("236")).
			Foreground(lipgloss.Color("255"))

	statusStyles = map[DeployStatus]lipgloss.Style{
		StatusPending:     lipgloss.NewStyle().Foreground(lipgloss.Color("241")),
		StatusCompressing: lipgloss.NewStyle().Foreground(lipgloss.Color("214")),
		StatusUploading:   lipgloss.NewStyle().Foreground(lipgloss.Color("214")),
		StatusBuilding:    lipgloss.NewStyle().Foreground(lipgloss.Color("214")),
		StatusDeploying:   lipgloss.NewStyle().Foreground(lipgloss.Color("12")),
		StatusComplete:    lipgloss.NewStyle().Foreground(lipgloss.Color("10")),
		StatusFailed:      lipgloss.NewStyle().Foreground(lipgloss.Color("9")),
	}

	logStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			MarginLeft(2)
)

// NewInteractiveModel creates a new interactive deployment model
func NewInteractiveModel(resources []*Resource) *InteractiveModel {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("214"))

	vp := viewport.New(80, 20)

	return &InteractiveModel{
		resources:   resources,
		viewport:    vp,
		spinner:     s,
		selectedIdx: 0,
		showLogs:    true,
	}
}

func (m *InteractiveModel) Init() tea.Cmd {
	return tea.Batch(
		m.spinner.Tick,
		tea.WindowSize(),
	)
}

func (m *InteractiveModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		// If deployment is complete, any key press exits
		if m.complete {
			return m, tea.Quit
		}

		// Handle quit confirmation
		if m.waitingForQuitConfirm {
			switch msg.String() {
			case "y", "Y":
				return m, tea.Quit
			case "n", "N":
				m.waitingForQuitConfirm = false
				return m, nil
			}
			return m, nil
		}

		switch msg.String() {
		case "ctrl+c":
			// Ctrl+C always quits immediately
			return m, tea.Quit
		case "q":
			// Check if any resource is currently uploading
			m.mu.RLock()
			isUploading := false
			for _, r := range m.resources {
				r.mu.RLock()
				if r.Status == StatusUploading {
					isUploading = true
				}
				r.mu.RUnlock()
				if isUploading {
					break
				}
			}
			m.mu.RUnlock()

			// If uploading, ask for confirmation
			if isUploading {
				m.waitingForQuitConfirm = true
				return m, nil
			}
			// Otherwise quit immediately
			return m, tea.Quit
		case "up", "k":
			if m.selectedIdx > 0 {
				m.selectedIdx--
				m.updateContent()
			}
		case "down", "j":
			if m.selectedIdx < len(m.resources)-1 {
				m.selectedIdx++
				m.updateContent()
			}
		case "l":
			m.showLogs = !m.showLogs
			m.updateContent()
		}

	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.viewport.Width = msg.Width - 4
		m.viewport.Height = msg.Height - 10
		m.updateContent()

	case resourceUpdateMsg:
		m.mu.Lock()
		if msg.idx < len(m.resources) {
			r := m.resources[msg.idx]
			r.mu.Lock()
			r.Status = msg.status
			r.StatusText = msg.statusText
			if msg.err != nil {
				r.Error = msg.err
			}
			r.mu.Unlock()
		}
		m.mu.Unlock()
		if m.width > 0 && m.height > 0 {
			m.updateContent()
		}

	case buildLogMsg:
		m.mu.Lock()
		if msg.idx < len(m.resources) {
			r := m.resources[msg.idx]
			r.mu.Lock()
			r.BuildLogs = append(r.BuildLogs, msg.log)
			// Keep a reasonable buffer of logs (2x viewport capacity)
			// This allows scrolling back while preventing excessive memory usage
			maxLogs := (m.viewport.Height - 6) * 2
			if maxLogs < 100 {
				maxLogs = 100 // Minimum buffer size
			}
			if len(r.BuildLogs) > maxLogs {
				r.BuildLogs = r.BuildLogs[len(r.BuildLogs)-maxLogs:]
			}
			r.mu.Unlock()
		}
		m.mu.Unlock()
		if m.width > 0 && m.height > 0 {
			m.updateContent()
		}

	case deployCompleteMsg:
		m.complete = true
		// Don't quit immediately - wait for user to press a key
		return m, nil

	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		cmds = append(cmds, cmd)
	}

	// Update viewport
	var cmd tea.Cmd
	m.viewport, cmd = m.viewport.Update(msg)
	cmds = append(cmds, cmd)

	return m, tea.Batch(cmds...)
}

func (m *InteractiveModel) View() string {
	if m.complete {
		// Show completion message and wait for user input
		var s strings.Builder
		s.WriteString("\n")
		s.WriteString(titleStyle.Render("Deployment Complete!"))
		s.WriteString("\n\n")

		// Show final status
		s.WriteString("Final Status:\n")
		allSuccess := true
		appUrl := blaxel.GetAppURL()
		currentWorkspace := core.GetWorkspace()

		for _, r := range m.resources {
			r.mu.RLock()
			status := r.Status
			name := r.Name
			kind := r.Kind
			statusText := r.StatusText
			err := r.Error
			r.mu.RUnlock()

			statusIcon := getStatusIcon(status, m.spinner)
			line := fmt.Sprintf("  %s %s/%s", statusIcon, kind, name)

			if status == StatusFailed {
				allSuccess = false
				line = statusStyles[StatusFailed].Render(line)
				s.WriteString(line + "\n")

				// Show error details
				if statusText != "" {
					s.WriteString(fmt.Sprintf("     %s\n", lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render(statusText)))
				}
				if err != nil {
					s.WriteString(fmt.Sprintf("     Error: %s\n", lipgloss.NewStyle().Foreground(lipgloss.Color("9")).Render(err.Error())))
				}

				// Show console URL and logs command for failed resources
				resourceType := strings.ToLower(kind)
				consoleUrl := fmt.Sprintf("%s/%s/global-agentic-network/%s/%s", appUrl, currentWorkspace, resourceType, name)
				s.WriteString(fmt.Sprintf("     Console: %s\n", lipgloss.NewStyle().Foreground(lipgloss.Color("255")).Render(consoleUrl)))
				s.WriteString(fmt.Sprintf("     Logs:    %s\n", lipgloss.NewStyle().Foreground(lipgloss.Color("255")).Render(fmt.Sprintf("bl logs %s %s", resourceType, name))))
			} else {
				line = statusStyles[StatusComplete].Render(line)
				s.WriteString(line + "\n")
				if statusText != "" {
					s.WriteString(fmt.Sprintf("     %s\n", lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render(statusText)))
				}
			}
		}

		s.WriteString("\n")
		if allSuccess {
			config := core.GetConfig()

			// Don't show URL for volume-template deployments
			if core.IsVolumeTemplate(config.Type) {
				s.WriteString(statusStyles[StatusComplete].Render("✓ All resources deployed successfully!"))
				s.WriteString("\n")
			} else {
				appUrl := blaxel.GetAppURL()
				currentWorkspace := core.GetWorkspace()
				availableAt := fmt.Sprintf("%s/%s/global-agentic-network/%s/%s", appUrl, currentWorkspace, config.Type, m.resources[0].Name)
				core.PrintSuccess(fmt.Sprintf("Deployment applied successfull\n%s", availableAt))
				s.WriteString(statusStyles[StatusComplete].Render("✓ All resources deployed successfully! Deployment available at: "))
				s.WriteString(availableAt)
				s.WriteString("\n")

				// Display callback secret if present (only for agents)
				if len(m.resources) > 0 && config.Type == "agent" {
					m.resources[0].mu.RLock()
					callbackSecret := m.resources[0].CallbackSecret
					m.resources[0].mu.RUnlock()
					if callbackSecret != "" {
						s.WriteString("\n")
						s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("214")).Bold(true).Render("Async Callback Configuration:"))
						s.WriteString("\n")
						s.WriteString(fmt.Sprintf("  Callback Secret: %s\n", lipgloss.NewStyle().Foreground(lipgloss.Color("10")).Render(callbackSecret)))
						s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render("  Use this secret to verify webhook callbacks from Blaxel"))
						s.WriteString("\n")
						runCommand := lipgloss.NewStyle().Foreground(lipgloss.Color("12")).Render("bl run agent %s --params async=true -d '{\"inputs\": \"Hello world\"}'", m.resources[0].Name)
						s.WriteString(fmt.Sprintf("  Run your async agent with: %s", runCommand))
					}
				}
			}
		} else {
			s.WriteString(statusStyles[StatusFailed].Render("✗ Some resources failed to deploy"))
		}
		s.WriteString("\n\n")
		s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render("Press any key to exit..."))

		return s.String()
	}

	var s strings.Builder
	s.WriteString("\n")
	s.WriteString(titleStyle.Render("Interactive Deployment"))
	s.WriteString("\n")
	s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render("To deploy in the background, use: bl deploy -y"))
	s.WriteString("\n\n")

	// Resource list
	s.WriteString("Resources:\n")
	for i, r := range m.resources {
		r.mu.RLock()
		status := r.Status
		name := r.Name
		kind := r.Kind
		r.mu.RUnlock()

		// Show simple status text, not the detailed statusText (that's shown in viewport below)
		line := fmt.Sprintf("  %s %s/%s - %s", getStatusIcon(status, m.spinner), kind, name, getStatusText(status))

		if i == m.selectedIdx {
			line = selectedStyle.Render(line)
		} else {
			line = statusStyles[status].Render(line)
		}
		s.WriteString(line + "\n")
	}

	s.WriteString("\n")
	s.WriteString(m.viewport.View())
	s.WriteString("\n")

	// Footer
	if m.waitingForQuitConfirm {
		footer := lipgloss.NewStyle().
			Foreground(lipgloss.Color("214")).
			Bold(true).
			Render("⚠ Upload in progress! Are you sure you want to quit? (y/n)")
		s.WriteString(footer)
	} else {
		footer := "↑/↓: Navigate | l: Toggle logs | q: Quit"
		s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render(footer))
	}

	return s.String()
}

func (m *InteractiveModel) updateContent() {
	m.mu.RLock()
	defer m.mu.RUnlock()

	if m.selectedIdx >= len(m.resources) {
		return
	}

	// Don't update if viewport isn't properly sized yet
	if m.viewport.Width <= 0 || m.viewport.Height <= 0 {
		return
	}

	selected := m.resources[m.selectedIdx]
	selected.mu.RLock()
	defer selected.mu.RUnlock()

	var content strings.Builder
	content.WriteString(fmt.Sprintf("Resource: %s/%s\n", selected.Kind, selected.Name))
	content.WriteString(fmt.Sprintf("Status: %s\n", getStatusText(selected.Status)))
	if selected.StatusText != "" {
		content.WriteString(fmt.Sprintf("Details: %s\n", selected.StatusText))
	}
	if selected.Error != nil {
		content.WriteString(fmt.Sprintf("Error: %s\n", selected.Error))
	}

	// Add console page URL (skip for volume-template)
	config := core.GetConfig()
	if !core.IsVolumeTemplate(config.Type) {
		currentWorkspace := core.GetWorkspace()
		appUrl := blaxel.GetAppURL()
		resourceType := strings.ToLower(selected.Kind)
		consoleUrl := fmt.Sprintf("%s/%s/global-agentic-network/%s/%s", appUrl, currentWorkspace, resourceType, selected.Name)
		content.WriteString(fmt.Sprintf("Console page: %s\n", consoleUrl))
	}

	if m.showLogs && len(selected.BuildLogs) > 0 {
		content.WriteString("\nLogs:\n")
		content.WriteString(strings.Repeat("─", 60) + "\n")

		// Calculate how many logs we can show based on viewport height
		// Reserve ~6 lines for header info
		maxVisibleLogs := m.viewport.Height - 6
		if maxVisibleLogs < 1 {
			maxVisibleLogs = 1
		}

		// Show only the most recent logs that fit in the viewport
		startIdx := 0
		if len(selected.BuildLogs) > maxVisibleLogs {
			startIdx = len(selected.BuildLogs) - maxVisibleLogs
		}

		for i := startIdx; i < len(selected.BuildLogs); i++ {
			content.WriteString(logStyle.Render(selected.BuildLogs[i]) + "\n")
		}
	}

	m.viewport.SetContent(content.String())
	// Auto-scroll to bottom to show latest logs (only if viewport is properly sized)
	if m.viewport.Height > 0 {
		m.viewport.GotoBottom()
	}
}

func getStatusIcon(status DeployStatus, spinner spinner.Model) string {
	switch status {
	case StatusPending:
		return "○"
	case StatusCompressing, StatusUploading, StatusBuilding, StatusDeploying:
		return spinner.View()
	case StatusComplete:
		return "✓"
	case StatusFailed:
		return "✗"
	default:
		return "?"
	}
}

func getStatusText(status DeployStatus) string {
	switch status {
	case StatusPending:
		return "Pending"
	case StatusCompressing:
		return "Compressing"
	case StatusUploading:
		return "Uploading"
	case StatusBuilding:
		return "Building"
	case StatusDeploying:
		return "Deploying"
	case StatusComplete:
		return "Complete"
	case StatusFailed:
		return "Failed"
	default:
		return "Unknown"
	}
}

// UpdateResource updates the status of a resource
func (m *InteractiveModel) UpdateResource(idx int, status DeployStatus, statusText string, err error) {
	if m == nil {
		return
	}
	if m.program == nil {
		// Program not set yet, wait a bit for it to be initialized
		time.Sleep(10 * time.Millisecond)
		if m.program == nil {
			return
		}
	}
	m.program.Send(resourceUpdateMsg{
		idx:        idx,
		status:     status,
		statusText: statusText,
		err:        err,
	})
}

// AddBuildLog adds a build log line for a resource
func (m *InteractiveModel) AddBuildLog(idx int, log string) {
	if m == nil {
		return
	}
	if m.program == nil {
		// Program not set yet, wait a bit for it to be initialized
		time.Sleep(10 * time.Millisecond)
		if m.program == nil {
			return
		}
	}
	m.program.Send(buildLogMsg{
		idx: idx,
		log: log,
	})
}

// Complete marks the deployment as complete
func (m *InteractiveModel) Complete() {
	if m == nil {
		return
	}
	if m.program == nil {
		// Program not set yet, wait a bit for it to be initialized
		time.Sleep(10 * time.Millisecond)
		if m.program == nil {
			return
		}
	}
	m.program.Send(deployCompleteMsg{})
}

// SetProgram sets the tea.Program reference for sending messages
func (m *InteractiveModel) SetProgram(p *tea.Program) {
	if m != nil {
		m.program = p
	}
}

// SetCallbackSecret sets the callback secret for a resource
func (r *Resource) SetCallbackSecret(secret string) {
	if r != nil {
		r.mu.Lock()
		r.CallbackSecret = secret
		r.mu.Unlock()
	}
}
