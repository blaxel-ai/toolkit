package deploy

import (
	"fmt"
	"strings"
	"sync"

	"github.com/blaxel-ai/toolkit/cli/core"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// Resource deployment statuses
type DeployStatus int

const (
	StatusPending DeployStatus = iota
	StatusUploading
	StatusBuilding
	StatusDeploying
	StatusComplete
	StatusFailed
)

// Resource represents a deployable resource
type Resource struct {
	Kind          string
	Name          string
	Status        DeployStatus
	StatusText    string
	BuildLogs     []string
	AutoGenerated bool
	Error         error
	mu            sync.RWMutex
}

// InteractiveModel represents the interactive deployment UI
type InteractiveModel struct {
	resources   []*Resource
	viewport    viewport.Model
	spinner     spinner.Model
	selectedIdx int
	showLogs    bool
	complete    bool
	width       int
	height      int
	mu          sync.RWMutex
}

// Messages for updating the model
type (
	resourceUpdateMsg struct {
		idx        int
		status     DeployStatus
		statusText string
		err        error
	}
	buildLogMsg struct {
		idx int
		log string
	}
	deployCompleteMsg struct{}
	tickMsg           struct{}
)

// Styles
var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("214"))

	selectedStyle = lipgloss.NewStyle().
			Background(lipgloss.Color("236")).
			Foreground(lipgloss.Color("255"))

	statusStyles = map[DeployStatus]lipgloss.Style{
		StatusPending:   lipgloss.NewStyle().Foreground(lipgloss.Color("241")),
		StatusUploading: lipgloss.NewStyle().Foreground(lipgloss.Color("214")),
		StatusBuilding:  lipgloss.NewStyle().Foreground(lipgloss.Color("214")),
		StatusDeploying: lipgloss.NewStyle().Foreground(lipgloss.Color("12")),
		StatusComplete:  lipgloss.NewStyle().Foreground(lipgloss.Color("10")),
		StatusFailed:    lipgloss.NewStyle().Foreground(lipgloss.Color("9")),
	}

	logStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			MarginLeft(2)
)

// NewInteractiveModel creates a new interactive deployment model
func NewInteractiveModel(resources []*Resource) *InteractiveModel {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("214"))

	vp := viewport.New(80, 20)

	return &InteractiveModel{
		resources:   resources,
		viewport:    vp,
		spinner:     s,
		selectedIdx: 0,
		showLogs:    true,
	}
}

func (m *InteractiveModel) Init() tea.Cmd {
	return tea.Batch(
		m.spinner.Tick,
		tea.WindowSize(),
	)
}

func (m *InteractiveModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		// If deployment is complete, any key press exits
		if m.complete {
			return m, tea.Quit
		}

		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		case "up", "k":
			if m.selectedIdx > 0 {
				m.selectedIdx--
				m.updateContent()
			}
		case "down", "j":
			if m.selectedIdx < len(m.resources)-1 {
				m.selectedIdx++
				m.updateContent()
			}
		case "l":
			m.showLogs = !m.showLogs
			m.updateContent()
		}

	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.viewport.Width = msg.Width - 4
		m.viewport.Height = msg.Height - 10
		m.updateContent()

	case resourceUpdateMsg:
		m.mu.Lock()
		if msg.idx < len(m.resources) {
			r := m.resources[msg.idx]
			r.mu.Lock()
			r.Status = msg.status
			r.StatusText = msg.statusText
			if msg.err != nil {
				r.Error = msg.err
			}
			r.mu.Unlock()
		}
		m.mu.Unlock()
		m.updateContent()

	case buildLogMsg:
		m.mu.Lock()
		if msg.idx < len(m.resources) {
			r := m.resources[msg.idx]
			r.mu.Lock()
			r.BuildLogs = append(r.BuildLogs, msg.log)
			// Keep a reasonable buffer of logs (2x viewport capacity)
			// This allows scrolling back while preventing excessive memory usage
			maxLogs := (m.viewport.Height - 6) * 2
			if maxLogs < 100 {
				maxLogs = 100 // Minimum buffer size
			}
			if len(r.BuildLogs) > maxLogs {
				r.BuildLogs = r.BuildLogs[len(r.BuildLogs)-maxLogs:]
			}
			r.mu.Unlock()
		}
		m.mu.Unlock()
		m.updateContent()

	case deployCompleteMsg:
		m.complete = true
		// Don't quit immediately - wait for user to press a key
		return m, nil

	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		cmds = append(cmds, cmd)
	}

	// Update viewport
	var cmd tea.Cmd
	m.viewport, cmd = m.viewport.Update(msg)
	cmds = append(cmds, cmd)

	return m, tea.Batch(cmds...)
}

func (m *InteractiveModel) View() string {
	if m.complete {
		// Show completion message and wait for user input
		var s strings.Builder
		s.WriteString("\n")
		s.WriteString(titleStyle.Render("Deployment Complete!"))
		s.WriteString("\n\n")

		// Show final status
		s.WriteString("Final Status:\n")
		allSuccess := true
		for _, r := range m.resources {
			r.mu.RLock()
			status := r.Status
			name := r.Name
			kind := r.Kind
			r.mu.RUnlock()

			statusIcon := getStatusIcon(status, m.spinner)
			line := fmt.Sprintf("  %s %s/%s", statusIcon, kind, name)

			if status == StatusFailed {
				allSuccess = false
				line = statusStyles[StatusFailed].Render(line)
			} else {
				line = statusStyles[StatusComplete].Render(line)
			}
			s.WriteString(line + "\n")
		}

		s.WriteString("\n")
		if allSuccess {
			config := core.GetConfig()

			// Don't show URL for volume-template deployments
			if config.Type == "volume-template" {
				s.WriteString(statusStyles[StatusComplete].Render("✓ All resources deployed successfully!"))
				s.WriteString("\n")
			} else {
				appUrl := core.GetAppURL()
				currentWorkspace := core.GetWorkspace()
				availableAt := fmt.Sprintf("%s/%s/global-agentic-network/%s/%s", appUrl, currentWorkspace, config.Type, m.resources[0].Name)
				core.PrintSuccess(fmt.Sprintf("Deployment applied successfull\n%s", availableAt))
				s.WriteString(statusStyles[StatusComplete].Render("✓ All resources deployed successfully! Deployment available at: "))
				s.WriteString(availableAt)
				s.WriteString("\n")
			}
		} else {
			s.WriteString(statusStyles[StatusFailed].Render("✗ Some resources failed to deploy"))
		}
		s.WriteString("\n\n")
		s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render("Press any key to exit..."))

		return s.String()
	}

	var s strings.Builder
	s.WriteString("\n")
	s.WriteString(titleStyle.Render("Interactive Deployment"))
	s.WriteString("\n")
	s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render("To deploy in the background, use: bl deploy -y"))
	s.WriteString("\n\n")

	// Resource list
	s.WriteString("Resources:\n")
	for i, r := range m.resources {
		r.mu.RLock()
		status := r.Status
		statusText := r.StatusText
		name := r.Name
		kind := r.Kind
		r.mu.RUnlock()

		line := fmt.Sprintf("  %s %s/%s", getStatusIcon(status, m.spinner), kind, name)
		if statusText != "" {
			line += fmt.Sprintf(" - %s", statusText)
		}

		if i == m.selectedIdx {
			line = selectedStyle.Render(line)
		} else {
			line = statusStyles[status].Render(line)
		}
		s.WriteString(line + "\n")
	}

	s.WriteString("\n")
	s.WriteString(m.viewport.View())
	s.WriteString("\n")

	// Footer
	footer := "↑/↓: Navigate | l: Toggle logs | q: Quit"
	s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render(footer))

	return s.String()
}

func (m *InteractiveModel) updateContent() {
	m.mu.RLock()
	defer m.mu.RUnlock()

	if m.selectedIdx >= len(m.resources) {
		return
	}

	selected := m.resources[m.selectedIdx]
	selected.mu.RLock()
	defer selected.mu.RUnlock()

	var content strings.Builder
	content.WriteString(fmt.Sprintf("Resource: %s/%s\n", selected.Kind, selected.Name))
	content.WriteString(fmt.Sprintf("Status: %s\n", getStatusText(selected.Status)))
	if selected.StatusText != "" {
		content.WriteString(fmt.Sprintf("Details: %s\n", selected.StatusText))
	}
	if selected.Error != nil {
		content.WriteString(fmt.Sprintf("Error: %s\n", selected.Error))
	}

	// Add console page URL (skip for volume-template)
	config := core.GetConfig()
	if config.Type != "volume-template" {
		currentWorkspace := core.GetWorkspace()
		appUrl := core.GetAppURL()
		resourceType := strings.ToLower(selected.Kind)
		consoleUrl := fmt.Sprintf("%s/%s/global-agentic-network/%s/%s", appUrl, currentWorkspace, resourceType, selected.Name)
		content.WriteString(fmt.Sprintf("Console page: %s\n", consoleUrl))
	}

	if m.showLogs && len(selected.BuildLogs) > 0 {
		content.WriteString("\nLogs:\n")
		content.WriteString(strings.Repeat("─", 60) + "\n")

		// Calculate how many logs we can show based on viewport height
		// Reserve ~6 lines for header info
		maxVisibleLogs := m.viewport.Height - 6
		if maxVisibleLogs < 1 {
			maxVisibleLogs = 1
		}

		// Show only the most recent logs that fit in the viewport
		startIdx := 0
		if len(selected.BuildLogs) > maxVisibleLogs {
			startIdx = len(selected.BuildLogs) - maxVisibleLogs
		}

		for i := startIdx; i < len(selected.BuildLogs); i++ {
			content.WriteString(logStyle.Render(selected.BuildLogs[i]) + "\n")
		}
	}

	m.viewport.SetContent(content.String())
	// Auto-scroll to bottom to show latest logs
	m.viewport.GotoBottom()
}

func getStatusIcon(status DeployStatus, spinner spinner.Model) string {
	switch status {
	case StatusPending:
		return "○"
	case StatusUploading, StatusBuilding, StatusDeploying:
		return spinner.View()
	case StatusComplete:
		return "✓"
	case StatusFailed:
		return "✗"
	default:
		return "?"
	}
}

func getStatusText(status DeployStatus) string {
	switch status {
	case StatusPending:
		return "Pending"
	case StatusUploading:
		return "Uploading"
	case StatusBuilding:
		return "Building"
	case StatusDeploying:
		return "Deploying"
	case StatusComplete:
		return "Complete"
	case StatusFailed:
		return "Failed"
	default:
		return "Unknown"
	}
}

// UpdateResource updates the status of a resource
func (m *InteractiveModel) UpdateResource(idx int, status DeployStatus, statusText string, err error) {
	if m != nil {
		// Send update message to the model
		go func() {
			m.Update(resourceUpdateMsg{
				idx:        idx,
				status:     status,
				statusText: statusText,
				err:        err,
			})
		}()
	}
}

// AddBuildLog adds a build log line for a resource
func (m *InteractiveModel) AddBuildLog(idx int, log string) {
	if m != nil {
		go func() {
			m.Update(buildLogMsg{
				idx: idx,
				log: log,
			})
		}()
	}
}

// Complete marks the deployment as complete
func (m *InteractiveModel) Complete() {
	if m != nil {
		go func() {
			m.Update(deployCompleteMsg{})
		}()
	}
}
