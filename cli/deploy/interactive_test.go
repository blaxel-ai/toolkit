package deploy

import (
	"errors"
	"testing"

	"github.com/charmbracelet/bubbles/spinner"
	"github.com/stretchr/testify/assert"
)

func TestDeployStatusConstants(t *testing.T) {
	// Verify status constants have expected values
	assert.Equal(t, DeployStatus(0), StatusPending)
	assert.Equal(t, DeployStatus(1), StatusCompressing)
	assert.Equal(t, DeployStatus(2), StatusUploading)
	assert.Equal(t, DeployStatus(3), StatusBuilding)
	assert.Equal(t, DeployStatus(4), StatusDeploying)
	assert.Equal(t, DeployStatus(5), StatusComplete)
	assert.Equal(t, DeployStatus(6), StatusFailed)
}

func TestResourceStruct(t *testing.T) {
	t.Run("basic fields", func(t *testing.T) {
		r := Resource{
			Kind:       "Agent",
			Name:       "my-agent",
			Status:     StatusPending,
			StatusText: "Waiting to start",
		}

		assert.Equal(t, "Agent", r.Kind)
		assert.Equal(t, "my-agent", r.Name)
		assert.Equal(t, StatusPending, r.Status)
		assert.Equal(t, "Waiting to start", r.StatusText)
	})

	t.Run("with error", func(t *testing.T) {
		r := Resource{
			Kind:   "Function",
			Name:   "my-function",
			Status: StatusFailed,
			Error:  errors.New("deployment failed"),
		}

		assert.Equal(t, StatusFailed, r.Status)
		assert.NotNil(t, r.Error)
		assert.Equal(t, "deployment failed", r.Error.Error())
	})

	t.Run("auto generated", func(t *testing.T) {
		r := Resource{
			Kind:          "Image",
			Name:          "auto-image",
			AutoGenerated: true,
		}

		assert.True(t, r.AutoGenerated)
	})
}

func TestSetCallbackSecret(t *testing.T) {
	r := &Resource{
		Kind: "Agent",
		Name: "test-agent",
	}

	r.SetCallbackSecret("secret-123")

	r.mu.RLock()
	secret := r.CallbackSecret
	r.mu.RUnlock()

	assert.Equal(t, "secret-123", secret)
}

func TestSetCallbackSecretNil(t *testing.T) {
	var r *Resource
	// Should not panic
	r.SetCallbackSecret("secret")
}

func TestGetStatusText(t *testing.T) {
	tests := []struct {
		status   DeployStatus
		expected string
	}{
		{StatusPending, "Pending"},
		{StatusCompressing, "Compressing"},
		{StatusUploading, "Uploading"},
		{StatusBuilding, "Building"},
		{StatusDeploying, "Deploying"},
		{StatusComplete, "Complete"},
		{StatusFailed, "Failed"},
		{DeployStatus(99), "Unknown"},
	}

	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			result := getStatusText(tt.status)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestNewInteractiveModel(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1"},
		{Kind: "Function", Name: "func-1"},
	}

	model := NewInteractiveModel(resources)

	assert.NotNil(t, model)
	assert.Len(t, model.resources, 2)
	assert.Equal(t, 0, model.selectedIdx)
	assert.True(t, model.showLogs)
	assert.False(t, model.complete)
	assert.False(t, model.waitingForQuitConfirm)
}

func TestInteractiveModelInit(t *testing.T) {
	model := NewInteractiveModel([]*Resource{})

	cmd := model.Init()
	// Init should return a batch command (spinner tick + window size)
	assert.NotNil(t, cmd)
}

func TestResourceUpdateMsg(t *testing.T) {
	msg := resourceUpdateMsg{
		idx:        0,
		status:     StatusComplete,
		statusText: "Deployed successfully",
		err:        nil,
	}

	assert.Equal(t, 0, msg.idx)
	assert.Equal(t, StatusComplete, msg.status)
	assert.Equal(t, "Deployed successfully", msg.statusText)
	assert.Nil(t, msg.err)
}

func TestBuildLogMsg(t *testing.T) {
	msg := buildLogMsg{
		idx: 1,
		log: "Building image...",
	}

	assert.Equal(t, 1, msg.idx)
	assert.Equal(t, "Building image...", msg.log)
}

func TestDeployCompleteMsg(t *testing.T) {
	msg := deployCompleteMsg{}
	// Just verify it's the right type
	assert.NotNil(t, msg)
}

func TestInteractiveModelUpdateResourceNil(t *testing.T) {
	var model *InteractiveModel
	// Should not panic
	model.UpdateResource(0, StatusComplete, "done", nil)
}

func TestInteractiveModelAddBuildLogNil(t *testing.T) {
	var model *InteractiveModel
	// Should not panic
	model.AddBuildLog(0, "test log")
}

func TestInteractiveModelCompleteNil(t *testing.T) {
	var model *InteractiveModel
	// Should not panic
	model.Complete()
}

func TestInteractiveModelSetProgramNil(t *testing.T) {
	var model *InteractiveModel
	// Should not panic
	model.SetProgram(nil)
}

func TestResourceBuildLogs(t *testing.T) {
	r := &Resource{
		Kind:      "Agent",
		Name:      "test",
		BuildLogs: []string{},
	}

	// Add build logs
	r.BuildLogs = append(r.BuildLogs, "Log line 1")
	r.BuildLogs = append(r.BuildLogs, "Log line 2")

	assert.Len(t, r.BuildLogs, 2)
	assert.Equal(t, "Log line 1", r.BuildLogs[0])
	assert.Equal(t, "Log line 2", r.BuildLogs[1])
}

func TestGetStatusIcon(t *testing.T) {
	sp := spinner.New()

	tests := []struct {
		status   DeployStatus
		expected string
	}{
		{StatusPending, "○"},
		{StatusComplete, "✓"},
		{StatusFailed, "✗"},
		{DeployStatus(99), "?"},
	}

	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			result := getStatusIcon(tt.status, sp)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestInteractiveModelUpdateWithResourceMsg(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1", Status: StatusPending},
	}
	model := NewInteractiveModel(resources)

	// Simulate resource update message
	msg := resourceUpdateMsg{
		idx:        0,
		status:     StatusComplete,
		statusText: "Deployed",
		err:        nil,
	}

	updatedModel, _ := model.Update(msg)
	m := updatedModel.(*InteractiveModel)

	assert.Equal(t, StatusComplete, m.resources[0].Status)
	assert.Equal(t, "Deployed", m.resources[0].StatusText)
}

func TestInteractiveModelUpdateWithBuildLogMsg(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1", BuildLogs: []string{}},
	}
	model := NewInteractiveModel(resources)

	// Simulate build log message
	msg := buildLogMsg{
		idx: 0,
		log: "Building step 1...",
	}

	updatedModel, _ := model.Update(msg)
	m := updatedModel.(*InteractiveModel)

	assert.Contains(t, m.resources[0].BuildLogs, "Building step 1...")
}

func TestInteractiveModelUpdateWithCompleteMsg(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1"},
	}
	model := NewInteractiveModel(resources)

	msg := deployCompleteMsg{}

	updatedModel, _ := model.Update(msg)
	m := updatedModel.(*InteractiveModel)

	assert.True(t, m.complete)
}

func TestInteractiveModelUpdateWithErrorMsg(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1"},
	}
	model := NewInteractiveModel(resources)

	testErr := errors.New("deployment failed")
	msg := resourceUpdateMsg{
		idx:        0,
		status:     StatusFailed,
		statusText: "Failed",
		err:        testErr,
	}

	updatedModel, _ := model.Update(msg)
	m := updatedModel.(*InteractiveModel)

	assert.Equal(t, StatusFailed, m.resources[0].Status)
	assert.Equal(t, testErr, m.resources[0].Error)
}

func TestInteractiveModelView(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1", Status: StatusComplete, StatusText: "Deployed"},
		{Kind: "Function", Name: "func-1", Status: StatusBuilding, StatusText: "Building"},
	}
	model := NewInteractiveModel(resources)

	view := model.View()

	// View should contain resource info
	assert.Contains(t, view, "agent-1")
	assert.Contains(t, view, "func-1")
}

func TestInteractiveModelViewWithLogs(t *testing.T) {
	resources := []*Resource{
		{
			Kind:      "Agent",
			Name:      "agent-1",
			Status:    StatusBuilding,
			BuildLogs: []string{"Step 1: Building...", "Step 2: Testing..."},
		},
	}
	model := NewInteractiveModel(resources)
	model.showLogs = true

	view := model.View()

	assert.Contains(t, view, "agent-1")
}

func TestInteractiveModelViewComplete(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1", Status: StatusComplete},
	}
	model := NewInteractiveModel(resources)
	model.complete = true

	view := model.View()

	// Should show completion message
	assert.NotEmpty(t, view)
}

func TestInteractiveModelUpdateResourceNoProgram(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1", Status: StatusPending},
	}
	model := NewInteractiveModel(resources)

	// Without a program, UpdateResource should not panic and should just return
	model.UpdateResource(0, StatusComplete, "Done", nil)

	// Resources are not updated directly because messages aren't processed without a program
	// This verifies the function doesn't panic when program is nil
}

func TestInteractiveModelUpdateResourceOutOfBounds(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1"},
	}
	model := NewInteractiveModel(resources)

	// Should not panic
	model.UpdateResource(99, StatusComplete, "Done", nil)
}

func TestInteractiveModelAddBuildLogNoProgram(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1", BuildLogs: []string{}},
	}
	model := NewInteractiveModel(resources)

	// Without a program, AddBuildLog should not panic
	model.AddBuildLog(0, "Log line 1")
	model.AddBuildLog(0, "Log line 2")
}

func TestInteractiveModelAddBuildLogOutOfBounds(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1"},
	}
	model := NewInteractiveModel(resources)

	// Should not panic
	model.AddBuildLog(99, "test")
}

func TestInteractiveModelCompleteNoProgram(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1"},
	}
	model := NewInteractiveModel(resources)

	// Without a program, Complete should not panic
	model.Complete()
}

func TestInteractiveModelSetProgram(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1"},
	}
	model := NewInteractiveModel(resources)

	// SetProgram with nil should not panic
	model.SetProgram(nil)
	assert.Nil(t, model.program)
}

func TestUpdateContent(t *testing.T) {
	resources := []*Resource{
		{Kind: "Agent", Name: "agent-1", Status: StatusComplete, StatusText: "Deployed"},
	}
	model := NewInteractiveModel(resources)

	// updateContent should not panic
	model.updateContent()
}
